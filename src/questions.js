const questions = [
  {
    id: 1478,
    question: "Что такое замыкание",
    explanation:
      'Замыкание — это функция, которая запоминает своё лексическое окружение даже после того, как она выполняется вне своей области видимости. Другими словами, функция, объявленная в определённой области видимости, сохраняет доступ к переменным этой области, даже когда она вызывается за пределами своего первоначального контекста.\nЭто важно по нескольким причинам:\n1.\nИнкапсуляция данных:\nПозволяют скрыть переменные внутри функции, делая их недоступными извне, кроме как через другую функцию, созданную в той же области видимости.\n2.\nСохранение состояния:\nПозволяют сохранять состояние между вызовами функции, без использования глобальных переменных.\n3.\nКаррирование и функциональное программирование:\nОблегчают каррирование и другие техники функционального программирования, позволяя функциям работать с переменными, которые были в их области видимости в момент создания.\nПример:\nfunction создатьСчетчик() {\n    let количество = 0; // переменная количество "замкнута" внутри функции увеличить\n    function увеличить() {\n        количество += 1;\n        return количество;\n    }\n    return увеличить;\n}\nconst счетчик = создатьСчетчик();\nconsole.log(счетчик()); // 1\nconsole.log(счетчик()); // 2\nВ этом примере, функция\n`увеличить`\nимеет доступ к переменной\n`количество`\n, даже после того как\n`создатьСчетчик`\nзавершила выполнение. Это происходит благодаря механизму замыканий:\n`увеличить`\n"запоминает" переменные, которые были в её области видимости в момент создания.\nЗамыкание — это когда функция запоминает и имеет доступ к переменным из своей области видимости, даже после того, как она выполняется в другом контексте. Это позволяет функциям сохранять данные между вызовами и обеспечивать инкапсуляцию состояния, что очень полезно для создания приватных переменных и управления состоянием в программе.',
    videos: [
      {
        url: "https://youtu.be/N1gKaF6BhDc?t=1415",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 1415,
      },
      {
        url: "https://www.youtube.com/live/t52BuzKzqWw?feature=share&t=862",
        title: "Публичное собеседование: junior-fron…",
        time: 862,
      },
      {
        url: "https://www.youtube.com/live/fk_eTY2IZQE?feature=share&t=514",
        title: "Публичное собеседование: фронтендер …",
        time: 514,
      },
      {
        url: "https://youtu.be/gV6eobXisYU?t=279",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 279,
      },
      {
        url: "https://youtu.be/NRufVTyELC4?t=1538",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 1538,
      },
      {
        url: "https://youtu.be/lq4eefCCuVo?t=887",
        title: "Реальное СОБЕСЕДОВАНИЕ на FRONTEND р…",
        time: 887,
      },
      {
        url: "https://youtu.be/Y1SekvuZ3M4?t=721",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 721,
      },
      {
        url: "https://youtu.be/LcAQMKXpcqg?t=681",
        title: "СОБЕСЕДОВАНИЕ JUNIOR FRONTEND РАЗРАБ…",
        time: 681,
      },
      {
        url: "https://youtu.be/cRqBsepPgoI?t=1988",
        title: "Собеседование frontend junior+ разра…",
        time: 1988,
      },
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=1469",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 1469,
      },
      {
        url: "https://youtu.be/g5LdFoV6iUg?t=786",
        title: "#12 Фронтенд-разработчик нейросети н…",
        time: 786,
      },
      {
        url: "https://youtu.be/25lCunO6yDQ?t=3072",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 3072,
      },
      {
        url: "https://www.youtube.com/watch?v=1Ej0Wx2TkSs&t=4760s",
        title: "#16 Собеседование Senior Frontend ра…",
        time: 4760,
      },
      {
        url: "https://youtu.be/qika0TkDFz4?t=6197",
        title: "#7 Первое собеседование Junior Front…",
        time: 6197,
      },
    ],
    rating: 46,
    image: null,
  },
  {
    id: 1481,
    question: "Различие методов call apply bind",
    explanation:
      'Методы\n`call`\n,\n`apply`\nи\n`bind`\nпринадлежат к функциональному объекту\n`Function`\nи используются для указания контекста\n`this`\nпри вызове функции. Хотя все три метода позволяют контролировать значение\n`this`\nвнутри функции, между ними существуют ключевые различия в способе использования и поведении.\ncall\nВызывает функцию, явно устанавливая\n`this`\nв первом аргументе. Остальные аргументы передаются в вызываемую функцию как есть.\nПример:\nfunction greet(message, name) {\n  console.log(`${message}, ${name}. This is ${this}`);\n}\ngreet.call("Earth", "Hello", "Alice"); // "Hello, Alice. This is Earth"\nЗдесь он используется для вызова функции\n`greet`\nс\n`this`\n, установленным в\n`"Earth"`\n, и двумя дополнительными аргументами\n`"Hello"`\nи\n`"Alice"`\n.\napply\nОчень похож на\n`call`\n, но принимает аргументы в виде массива, а не по отдельности.\nПример:\nfunction greet(message, name) {\n  console.log(`${message}, ${name}. This is ${this}`);\n}\ngreet.apply("Earth", ["Hello", "Alice"]); // "Hello, Alice. This is Earth"\nВ этом случае он вызывает функцию\n`greet`\nс\n`this`\n, установленным в\n`"Earth"`\n, и аргументами, переданными в виде массива.\nbind\nСоздаёт новую функцию, которая, когда она вызывается, имеет установленный контекст\n`this`\n, указанный в первом аргументе. В отличие от\n`call`\nи\n`apply`\n,\n`bind`\nне вызывает функцию сразу, а возвращает новую функцию, которую можно вызвать позже.\nПример:\nfunction greet(message, name) {\n  console.log(`${message}, ${name}. This is ${this}`);\n}\nconst greetEarth = greet.bind("Earth", "Hello", "Alice");\ngreetEarth(); // "Hello, Alice. This is Earth"\nЗдесь он используется для создания новой функции\n`greetEarth`\n, которая при вызове выводит тот же результат, что и предыдущие примеры, но с тем отличием, что контекст\n`this`\nи аргументы были заранее заданы.\n`call`\nвызывает функцию с указанным контекстом\n`this`\nи отдельными аргументами.\n`apply`\nаналогичен\n`call`\n, но принимает аргументы в виде массива.\n`bind`\nсоздаёт новую функцию с предустановленным контекстом\n`this`\nи аргументами, если они были предоставлены, но не вызывает её немедленно.\nЭти методы позволяют более гибко управлять контекстом выполнения функций, что является мощным инструментом, особенно при работе с объектно-ориентированным кодом и асинхронными вызовами.',
    videos: [
      {
        url: "https://www.youtube.com/live/N1gKaF6BhDc?feature=share&t=1189",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 1189,
      },
      {
        url: "https://youtu.be/VzorPrTjUII?t=931",
        title: "Middle за год? Собеседование #3 fron…",
        time: 931,
      },
      {
        url: "https://youtu.be/VzorPrTjUII?t=962",
        title: "Middle за год? Собеседование #3 fron…",
        time: 962,
      },
      {
        url: "https://youtu.be/YwRgLQ0SoKk?t=692",
        title: "Собеседование frontend разработчика",
        time: 692,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=1083",
        title: "Собеседование cтажера Frontend разра…",
        time: 1083,
      },
      {
        url: "https://youtu.be/e2r3JAuMSSg?t=3511",
        title: "#1. Публичное собеседование JUNIOR F…",
        time: 3511,
      },
    ],
    rating: 20,
    image: null,
  },

  {
    id: 1495,
    question: "Какие отличия классов id знаешь",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/t52BuzKzqWw?feature=share&t=3052",
        title: "Публичное собеседование: junior-fron…",
        time: 3052,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1496,
    question: "Какая разница между <script> <script async> <scrypt defer>",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=998",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 998,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1497,
    question: "Как работают cookies",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=k0dAETyBPvU&t=3720s",
        title: "#8 Маркетолог ушел на фронт. Собесед…",
        time: 3720,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1498,
    question: "В чем различие article и section",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=EaTZXKlpsj0&t=1057s",
        title: "#11 Фронтендер в 17 лет? Собеседован…",
        time: 1057,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1499,
    question: "Что такое doctype и для чего он нужен",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=400",
        title: "Public interview for Frontend/HTML/C…",
        time: 400,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1500,
    question: "Для чего нужны data атрибуты",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=1276",
        title: "Public interview for Frontend/HTML/C…",
        time: 1276,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1501,
    question: "Для чего необходим viewport",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/e2r3JAuMSSg?t=5283",
        title: "#1. Публичное собеседование JUNIOR F…",
        time: 5283,
      },
    ],
    rating: 3,
    image: null,
  },

  {
    id: 1552,
    question: "Что такое методолгия bem",
    explanation:
      "Методология БЭМ как я понимаю это компонентный подход к веб-разработке. В его основе лежит принцип разделения интерфейса на независимые блоки. Он позволяет легко и быстро разрабатывать интерфейсы любой сложности и повторно использовать существующий код, избегая «Copy-Paste».\nOct. 22, 2023, Яндекс",
    videos: [
      {
        url: "https://www.youtube.com/live/t52BuzKzqWw?feature=share&t=2551",
        title: "Публичное собеседование: junior-fron…",
        time: 2551,
      },
      {
        url: "https://youtu.be/4YRG6cMAASI?t=559",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 559,
      },
      {
        url: "https://youtu.be/gV6eobXisYU?t=987",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 987,
      },
      {
        url: "https://youtu.be/PLwrvZahiO4?t=425",
        title: "Собеседование на JavaScript разработ…",
        time: 425,
      },
    ],
    rating: 13,
    image: null,
  },
  {
    id: 1553,
    question: "Какими способами можно скрыть элемент",
    explanation:
      "Скрыть элемент на веб-странице можно несколькими способами. Разные методы подходят для различных сценариев использования, например, когда нужно полностью удалить элемент из потока документа или просто сделать его невидимым для пользователя, но сохранить в потоке документа. Вот некоторые из наиболее часто используемых способов:\n1.\n`display: none`\nСамый прямолинейный способ. Это свойство полностью убирает элемент из потока документа, и он не занимает никакого пространства.\n.element {\n  display: none;\n}\n2.\n`visibility: hidden`\nЭлемент остаётся в потоке документа и продолжает занимать своё пространство, но становится невидимым. В отличие от\n`display: none`\n,\n`visibility: hidden`\nсохраняет место элемента в макете.\n.element {\n  visibility: hidden;\n}\n3.\n`opacity: 0`\nУстанавливает уровень прозрачности элемента. Значение\n`0`\nделает элемент полностью прозрачным, но, как и в случае с\n`visibility: hidden`\n, элемент остаётся видимым для DOM и продолжает занимать место.\n.element {\n  opacity: 0;\n}\n4.\nИспользование абсолютного позиционирования\nМожно абсолютно позиционировать элемент за пределами видимой области экрана, сделав его таким образом невидимым для пользователя.\n.element {\n  position: absolute;\n  left: -9999px;\n}\n5.\n`height: 0`\nи\n`overflow: hidden`\nЕсли задать элементу высоту\n`0`\nи установить\n`overflow: hidden`\n, содержимое элемента скроется, но сам элемент по-прежнему будет присутствовать в потоке документа, не занимая при этом видимого пространства.\n.element {\n  height: 0;\n  overflow: hidden;\n}\n6.\n`clip`\nили\n`clip-path`\nС помощью этого можно обрезать элемент таким образом, что его содержимое станет невидимым. Это более сложный и менее распространённый способ, который может быть использован для специфических целей.\n.element {\n  position: absolute;\n  clip: rect(0 0 0 0);\n}\nВыбор метода зависит от конкретной задачи:\nЕсли элемент не должен занимать место в макете и его не нужно восстанавливать, подходит\n`display: none`\n.\nЕсли элемент должен сохранить своё место, но быть невидимым, используйте\n`visibility: hidden`\nили\n`opacity: 0`\n.\nДля временного скрытия элемента с возможностью быстрого восстановления без изменения макета страницы можно использовать\n`visibility: hidden`\nили\n`opacity: 0`\n.\nКаждый метод имеет свои особенности и подходит для определённых ситуаций, поэтому выбор зависит от целей скрытия элемента и требований к взаимодействию с ним.",
    videos: [
      {
        url: "https://youtu.be/ZEKcJgVI-YM?t=2188",
        title: "Талант в 18 лет? Собеседование #2 fr…",
        time: 2188,
      },
      {
        url: "https://youtu.be/BonLyarPpqE?t=1729",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 1729,
      },
      {
        url: "https://youtu.be/qika0TkDFz4?t=4244",
        title: "#7 Первое собеседование Junior Front…",
        time: 4244,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1554,
    question: "Какие методологии знаешь",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/t52BuzKzqWw?feature=share&t=2807",
        title: "Публичное собеседование: junior-fron…",
        time: 2807,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1555,
    question: "Для чего нужен flex",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/JERUf-xKU1o?feature=share&t=1107",
        title: "Публичное собеседование #6: Дмитрий …",
        time: 1107,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1556,
    question: "Что такое блочная модель",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/5gplqEVgajc?t=2116",
        title: "Cобеседование Junior Frontend разраб…",
        time: 2116,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1557,
    question: "Как работают свойства flex-grow и flex-shrink",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=4613",
        title: "Public interview for Frontend/HTML/C…",
        time: 4613,
      },
    ],
    rating: 3,
    image: null,
  },

  {
    id: 1621,
    question: "Что такое virtual dom",
    explanation:
      "Virtual DOM (виртуальный Document Object Model) - это концепция, широко используемая в разработке интерфейсов, особенно в библиотеке React от Facebook, а также в других современных фронтенд-фреймворках. DOM - это структура данных, используемая браузерами для представления веб-страниц. Она позволяет программам изменять структуру, стиль и содержание веб-страницы, взаимодействуя с HTML и CSS. Проблема обычного DOM заключается в том, что он может быть довольно медленным при частых обновлениях, поскольку изменения в нем приводят к перерисовке элементов страницы, что может быть ресурсоёмким процессом.\nЭта концепция призвана решить данную проблему. Вместо того чтобы напрямую взаимодействовать с реальным DOM при каждом изменении, изменения сначала применяются к виртуальному, который является лёгкой копией реального DOM. После этого, с помощью процесса, называемого согласованием (reconciliation), виртуальный DOM сравнивается с предыдущей его версией, чтобы определить, какие именно изменения необходимо внести в реальный. Это позволяет минимизировать количество операций с реальным DOM, что значительно увеличивает производительность приложения.\nПример кода без Virtual DOM и с Virtual DOM:\nБез Virtual DOM:\nconst element = document.getElementById('myElement');\nelement.textContent = 'Новый текст';\nВ этом случае каждое изменение непосредственно обновляет DOM, что может быть неэффективно при множественных обновлениях.\nС использованием Virtual DOM (пример на React):\nclass MyComponent extends React.Component {\n  render() {\n    return <div>Новый текст</div>;\n  }\n}\nВ этом случае, при изменении состояния компонента, React сначала применяет изменения к виртуальному DOM, а затем, используя согласование, оптимально обновляет реальный.\nвиртуальный Document Object Model позволяет писать код, как если бы можно было менять любую часть веб-страницы в любой момент, не беспокоясь о производительности. Это делает разработку интерфейсов более интуитивно понятной и эффективной.\nVirtual DOM - это технология для оптимизации обновлений веб-интерфейсов, позволяющая ускорить и упростить разработку сложных пользовательских интерфейсов, минимизируя взаимодействие с медленным реальным DOM.",
    videos: [
      {
        url: "https://youtu.be/P2x_lmvVOfE?t=880",
        title: "Собеседование JUNIOR FRONTEND REACT …",
        time: 880,
      },
      {
        url: "https://youtu.be/gV6eobXisYU?t=1179",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 1179,
      },
      {
        url: "https://youtu.be/Y1SekvuZ3M4?t=1366",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 1366,
      },
      {
        url: "https://youtu.be/hDl7w9U-Ly8?t=1415",
        title: "Собеседование на Junior Frontend раз…",
        time: 1415,
      },
      {
        url: "https://youtu.be/YwRgLQ0SoKk?t=3328",
        title: "Собеседование frontend разработчика",
        time: 3328,
      },
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=5340s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 5340,
      },
      {
        url: "https://www.youtube.com/watch?v=EaTZXKlpsj0&t=6920s",
        title: "#11 Фронтендер в 17 лет? Собеседован…",
        time: 6920,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=2889",
        title: "Собеседование cтажера Frontend разра…",
        time: 2889,
      },
    ],
    rating: 26,
    image: null,
  },
  {
    id: 1622,
    question: "Что такое dom дерево",
    explanation:
      "DOM (Document Object Model) дерево — это интерфейс, который представляет содержимое веб-страницы в виде иерархической структуры объектов. Каждый элемент страницы, включая текст, теги и атрибуты, становится узлом в этом дереве. Он позволяет языкам программирования, взаимодействовать с содержимым веб-страницы, изменяя его структуру, стиль и содержание.\nСтруктура DOM дерева\nУзлы (Nodes):\nБазовые части. Узлы могут представлять элементы (\n`Element`\n), текст (\n`Text`\n), комментарии (\n`Comment`\n) и т.д.\nКорневой узел (Root Node):\nОбычно узел\n`document`\n, который служит входной точкой к содержимому веб-страницы.\nРодительские узлы (Parent Nodes):\nУзлы, содержащие другие узлы (дочерние узлы).\nДочерние узлы (Child Nodes):\nУзлы, находящиеся внутри другого узла.\nСоседние узлы (Sibling Nodes):\nУзлы, расположенные на одном и том же уровне иерархии.\nКак работает DOM\nКогда браузер загружает веб-страницу, он создаёт такое дерево на основе HTML-документа. Это преобразование позволяет скриптам динамически изменять визуальное представление страницы, добавляя, удаляя или модифицируя элементы и их атрибуты.\nПримеры взаимодействия с DOM\nМожно выполнять различные операции с ним, такие как:\nПоиск элементов:\nС помощью методов вроде\n`getElementById`\n,\n`getElementsByClassName`\n,\n`querySelector`\nи\n`querySelectorAll`\n.\nСоздание и добавление элементов:\nИспользуя методы\n`createElement`\nи\n`appendChild`\n.\nУдаление элементов:\nС помощью\n`removeChild`\n.\nИзменение атрибутов и стилей:\nЧерез обращение к свойствам элементов, таким как\n`className`\n, `style` и другим.\nВажность DOM\nИграет ключевую роль в интерактивности и динамическом поведении веб-страниц. Благодаря ему, веб-страницы могут отвечать на действия пользователя, обновляясь без необходимости перезагрузки страницы. Это лежит в основе таких технологий, как AJAX и SPA (Single Page Application), которые позволяют создавать быстрые и плавные веб-приложения.\nDOM дерево — это иерархическая структура, представляющая содержимое веб-страницы как объекты. Это позволяет создавать динамические и интерактивные веб-приложения, изменяя содержимое, структуру и внешний вид страницы на лету.",
    videos: [
      {
        url: "https://youtu.be/gV6eobXisYU?t=748",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 748,
      },
      {
        url: "https://youtu.be/jf5TkGzWqiM?t=162",
        title: "Собеседование JUNIOR FRONTEND REACT …",
        time: 162,
      },
      {
        url: "https://youtu.be/gt-Glqr-1DM?t=918",
        title: "Собеседование frontend junior+ разра…",
        time: 918,
      },
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=2743",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 2743,
      },
    ],
    rating: 13,
    image: null,
  },
  {
    id: 1623,
    question: "Что такое rest api",
    explanation:
      "REST API (Representational State Transfer Application Programming Interface) — это архитектурный стиль взаимодействия компонентов распределенного приложения в сети. В контексте веб-разработки, он позволяет веб-сервисам общаться друг с другом через HTTP, используя стандартные методы HTTP (GET, POST, PUT, DELETE и т.д.) для выполнения операций над данными.\nОсновные принципы REST:\n1.\nБез состояния (Stateless):\nКаждый запрос от клиента к серверу должен содержать всю информацию, необходимую для его выполнения. Сервер не сохраняет состояние клиента между запросами.\n2.\nЕдинообразие интерфейса (Uniform Interface):\nОпределяет стандартный способ взаимодействия между клиентом и сервером, что облегчает и унифицирует разработку и взаимодействие компонентов системы.\n3.\nКэширование (Cacheable):\nОтветы на запросы могут быть кэшируемыми или некэшируемыми, что позволяет улучшить производительность системы за счет уменьшения нагрузки на сервер.\n4.\nКлиент-сервер (Client-Server):\nРазделение обязанностей между клиентом (например, пользовательским интерфейсом) и сервером (хранилище данных), что упрощает разработку и масштабирование компонентов независимо друг от друга.\n5.\nМногоуровневая система (Layered System):\nКлиент не может обязательно знать, общается ли он напрямую с сервером или через посредников, что повышает безопасность системы и позволяет использовать балансировщики нагрузки, кэширующие сервера и т.д.\n6.\nКод по требованию (Code on Demand, необязательно):\nСервер может временно расширять или настраивать функциональность клиента, передавая ему исполняемый код.\nПримеры использования REST API:\n1.\nВеб-сервисы:\nВеб-сайты используют его для запроса данных с сервера (например, загрузка списка пользователей, публикации сообщений в блоге).\n2.\nМобильные приложения:\nМобильные приложения общаются с сервером для получения и отправки данных (например, проверка погоды, отправка сообщений).\n3.\nИнтеграция с внешними сервисами:\nПриложения могут интегрироваться с внешними API для расширения своего функционала (например, использование карт Google Maps, интеграция с социальными сетями).\nREST API — это набор принципов и ограничений для создания веб-сервисов, который обеспечивает гибкое и эффективное взаимодействие между компонентами распределенных систем через HTTP. Благодаря своей простоте, масштабируемости и гибкости, REST стал доминирующим стилем для разработки API для веб-приложений.",
    videos: [
      {
        url: "https://youtu.be/gV6eobXisYU?t=2048",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 2048,
      },
      {
        url: "https://youtu.be/gt-Glqr-1DM?t=613",
        title: "Собеседование frontend junior+ разра…",
        time: 613,
      },
      {
        url: "https://youtu.be/gt-Glqr-1DM?t=671",
        title: "Собеседование frontend junior+ разра…",
        time: 671,
      },
      {
        url: "https://youtu.be/KvPUlwkSs_E?t=849",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 849,
      },
    ],
    rating: 13,
    image: null,
  },
  {
    id: 1624,
    question: "Что такое http",
    explanation:
      "HTTP (HyperText Transfer Protocol) — это протокол передачи гипертекста, основной протокол для передачи данных. Он используется для загрузки веб-страниц с сервера на клиентский браузер, а также для отправки данных от клиента к серверу. Является протоколом прикладного уровня модели OSI (Open Systems Interconnection) и работает поверх протокола TCP/IP.\nОсновные характеристики HTTP:\nБезсостоянийность (Stateless):\nНе сохраняет информацию о состоянии между различными запросами. Каждый запрос обрабатывается независимо, без знания предыдущих запросов. Это означает, что информация о состоянии должна передаваться отдельно, если она нужна для последовательных запросов.\nПростота:\nПредоставляет простой синтаксис для запросов и ответов, что облегчает разработку веб-приложений.\nРасширяемость:\nПозволяет легко добавлять новые методы и заголовки для запросов и ответов, что делает его гибким и адаптируемым к новым требованиям и технологиям.\nКак работает HTTP:\n1.\nКлиент (обычно веб-браузер) отправляет HTTP-запрос к серверу.\nЗапрос может быть сделан при вводе URL в адресную строку браузера, при нажатии на ссылку на веб-странице или при отправке формы. Запрос включает в себя метод (например, GET для запроса данных или POST для отправки данных), URL, версию протокола HTTP, необходимые заголовки и тело запроса (для методов, передающих данные, таких как POST).\n2.\nСервер обрабатывает полученный запрос\nи отправляет обратно HTTP-ответ, который включает в себя статус выполнения (код состояния), заголовки ответа и тело ответа (обычно HTML-документ, изображение, данные JSON и т.д.).\n3.\nКлиент обрабатывает ответ\nот сервера. Например, браузер может отобразить HTML-страницу или обновить часть текущей страницы, если это был AJAX-запрос.\nМетоды HTTP:\nПротокол определяет набор методов запросов, которые указывают действие, которое должно быть выполнено для данного ресурса. Наиболее часто используемые методы:\nGET:\nЗапрос содержимого указанного ресурса.\nPOST:\nОтправка данных на сервер для создания нового ресурса.\nPUT:\nОбновление существующего ресурса данными из запроса.\nDELETE:\nУдаление указанного ресурса.\nHEAD:\nЗапрос заголовков для указанного ресурса.\nOPTIONS:\nЗапрос поддерживаемых методов для ресурса.\nВерсии HTTP:\nСуществует несколько версий, включая 1.0, 1.1, и 2. Каждая новая версия протокола вносит улучшения в эффективность, безопасность и скорость передачи данных.\nHTTP — это основа взаимодействия, позволяющая веб-клиентам и серверам общаться друг с другом. Благодаря своей простоте, расширяемости и универсальности, HTTP остается ключевым компонентом веб-технологий.",
    videos: [
      {
        url: "https://www.youtube.com/live/JERUf-xKU1o?feature=share&t=2362",
        title: "Публичное собеседование #6: Дмитрий …",
        time: 2362,
      },
      {
        url: "https://youtu.be/gV6eobXisYU?t=1952",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 1952,
      },
      {
        url: "https://youtu.be/BonLyarPpqE?t=290",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 290,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1625,
    question: "Что такое cors",
    explanation:
      "CORS (Cross-Origin Resource Sharing — «совместное использование ресурсов между разными источниками») — это механизм, который позволяет веб-страницам запрашивать ресурсы с другого домена, отличного от домена, с которого была загружена сама страница. По умолчанию, в целях безопасности, веб-браузеры ограничивают кросс-доменные запросы с использованием так называемой политики одного источника (Same-Origin Policy). Он предоставляет веб-серверам возможность явно разрешить некоторые кросс-доменные запросы, сохраняя при этом безопасность.\nКак он работает\nКогда веб-приложение пытается сделать запрос к ресурсу, который находится на другом домене (кросс-доменный запрос), браузер автоматически добавляет к запросу заголовок\n`Origin`\n. Этот заголовок содержит домен, с которого был сделан запрос. Веб-сервер, к которому направлен запрос, затем проверяет этот заголовок и решает, разрешить ли запрос. Если сервер разрешает запросы из этого источника, он отвечает с соответствующими CORS заголовками, указывающими, какие действия разрешены. Один из таких заголовков —\n`Access-Control-Allow-Origin`\n, который может быть установлен в\n`*`\n(что означает разрешение для всех доменов) или в конкретный домен.\nПримеры:\n`Access-Control-Allow-Origin`:\nУказывает, какие домены могут получать доступ к ресурсу. Может быть установлен в конкретный домен или\n`*`\nдля разрешения всех доменов.\n`Access-Control-Allow-Methods`:\nУказывает, какие HTTP методы разрешены при доступе к ресурсу.\n`Access-Control-Allow-Headers`:\nУказывает, какие HTTP заголовки могут быть использованы во время запроса.\nПочему CORS важен\nРешает важную проблему безопасности, позволяя контролировать, какие веб-сайты могут использовать ресурсы вашего веб-сайта. Это предотвращает множество видов атак, таких как CSRF (Cross-Site Request Forgery — подделка межсайтовых запросов), позволяя при этом легитимным сайтам запрашивать данные через браузер.\nПроблемы с CORS\nХотя он повышает безопасность, неправильная настройка CORS может привести к уязвимостям. Например, слишком широкое использование\n`Access-Control-Allow-Origin: *`\nможет случайно разрешить небезопасные кросс-доменные запросы. Разработчики должны тщательно настраивать политики CORS, чтобы избежать потенциальных проблем с безопасностью.\nCORS является ключевым элементом современной веб-разработки, позволяя безопасно реализовывать кросс-доменные запросы и взаимодействия между веб-приложениями. Правильное понимание и настройка CORS необходимы для обеспечения безопасности и гибкости веб-приложений.",
    videos: [
      {
        url: "https://www.youtube.com/live/fk_eTY2IZQE?feature=share&t=1574",
        title: "Публичное собеседование: фронтендер …",
        time: 1574,
      },
      {
        url: "https://youtu.be/k0dAETyBPvU?t=3028",
        title: "#8 Маркетолог ушел на фронт. Собесед…",
        time: 3028,
      },
      {
        url: "https://youtu.be/HCXDrVikPGk?t=4119",
        title: "Собеседование на Middle Frontend раз…",
        time: 4119,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1626,
    question: "Какие методы http запросов знаешь",
    explanation:
      "HTTP (HyperText Transfer Protocol) определяет набор методов запросов, которые указывают действие, запрашиваемое от ресурса. Каждый из методов имеет свои особенности и предназначения. Вот основные из них:\n1.\nGET\nИспользуется для запроса данных с указанного ресурса. Такие запросы должны только извлекать данные и не влиять на их состояние.\n2.\nPOST\nПрименяется для отправки данных на сервер для создания нового ресурса. Часто используется при отправке форм.\n3.\nPUT\nИспользуется для обновления существующего ресурса или создания нового по указанному URI. В отличие от POST, он является идемпотентным, то есть несколько идентичных запросов будут иметь такой же эффект, как одиночный запрос.\n4.\nDELETE\nУдаляет указанный ресурс.\n5.\nHEAD\nАналогичен методу GET, но сервер в ответ отправляет только заголовки и статус-код, без тела ответа. Используется для извлечения метаданных.\n6.\nOPTIONS\nИспользуется для описания параметров связи для целевого ресурса. На практике этот метод может использоваться для проверки возможностей веб-сервера или для проверки поддерживаемых методов HTTP без выполнения запроса.\n7.\nPATCH\nПрименяется для частичного изменения ресурса. В отличие от PUT, он применяет частичные обновления к ресурсу.\n8.\nCONNECT\nИспользуется для установления туннеля к серверу, указанному в целевом ресурсе. Часто применяется для HTTPS-запросов через прокси-сервер.\n9.\nTRACE\nВыполняет вызов возвращаемого тестового сообщения с ресурса. Этот метод используется для диагностических целей, например, для просмотра того, что изменяется в запросе при прохождении через промежуточные серверы.\nКаждый из этих методов поддерживает различные аспекты взаимодействия с ресурсами и имеет свои собственные семантики в контексте RESTful веб-сервисов и веб-приложений. Правильный выбор метода запроса важен для соблюдения принципов безопасности, идемпотентности и эффективности взаимодействия с веб-ресурсами.",
    videos: [
      {
        url: "https://youtu.be/gV6eobXisYU?t=2006",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 2006,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=1939",
        title: "Собеседование cтажера Frontend разра…",
        time: 1939,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1627,
    question: "Что такое ооп",
    explanation:
      'Объектно-ориентированное программирование (ООП) — это парадигма, которая использует "объекты" — структуры данных, состоящие из полей данных (атрибутов или свойств) и методов (функций или процедур) — для проектирования приложений и компьютерных программ. Основные принципы:\n1.\nИнкапсуляция\nпозволяет скрыть детали реализации объекта и показывать пользователям только необходимые для взаимодействия свойства и методы. Это обеспечивает модульность программы и помогает защитить объекты от неправильного использования.\n2.\nНаследование\nпозволяет создавать новые классы на основе существующих, перенимая их свойства и методы. Это облегчает повторное использование кода и может значительно упростить программу.\n3.\nПолиморфизм\nдает возможность использовать один и тот же интерфейс для различных базовых форм данных или объектов. С его помощью можно, например, вызывать один и тот же метод для разных объектов, и в зависимости от типа объекта будет выполнена соответствующая реализация метода.\n4.\nАбстракция\nпозволяет сосредоточиться на важных атрибутах объекта, минимизируя или игнорируя несущественные детали. Это помогает уменьшить сложность программы и повысить ее уровень обобщения.\nОбъектно-ориентированное программирование используется во многих современных языках программирования. ООП помогает создавать модульные и масштабируемые программы, которые легче поддерживать и обновлять.',
    videos: [
      {
        url: "https://www.youtube.com/watch?v=BonLyarPpqE&t=4280s",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 4280,
      },
      {
        url: "https://www.youtube.com/watch?v=1Ej0Wx2TkSs&t=6380s",
        title: "#16 Собеседование Senior Frontend ра…",
        time: 6380,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1628,
    question: "Какие решения по оптимизации страницы знаешь",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/2zVAkqcUI4o?t=2104",
        title: "СОБЕСЕДОВАНИЕ Middle FRONTEND разраб…",
        time: 2104,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1629,
    question: "Для кого необходима семантическая верстка",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/gt-Glqr-1DM?t=1018",
        title: "Собеседование frontend junior+ разра…",
        time: 1018,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1630,
    question: "В чем смысл инкапсуляции",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/1Ej0Wx2TkSs?t=6482",
        title: "#16 Собеседование Senior Frontend ра…",
        time: 6482,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1631,
    question: "Как избежать баг flash of unstyled content",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/lrdaRbJctaA?t=1166",
        title: "Frontend интервью. Ильнура, первая р…",
        time: 1166,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1632,
    question: "Расскажи о себе",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/N1gKaF6BhDc?t=181",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 181,
      },
      {
        url: "https://youtu.be/xGyI3uOXRjY?t=156",
        title: "Tech Interview Fest | Пробное собесе…",
        time: 156,
      },
      {
        url: "https://www.youtube.com/live/5U3Fy9mpu5Q?feature=share&t=1139",
        title: "Публичное собеседование с frontend-р…",
        time: 1139,
      },
      {
        url: "https://www.youtube.com/live/qgdsHdkQYYQ?feature=share&t=244",
        title: "Публичное собеседование: Middle фрон…",
        time: 244,
      },
      {
        url: "https://youtu.be/Jmpft3r3E2E?t=200",
        title: "Публичное собеседование: frontend-ра…",
        time: 200,
      },
      {
        url: "https://www.youtube.com/live/t52BuzKzqWw?feature=share&t=160",
        title: "Публичное собеседование: junior-fron…",
        time: 160,
      },
      {
        url: "https://www.youtube.com/live/MdRE18dGmNU?feature=share&t=517",
        title: "Публичное собеседование: Junior Fron…",
        time: 517,
      },
      {
        url: "https://www.youtube.com/live/5U3Fy9mpu5Q?feature=share&t=224",
        title: "Публичное собеседование с frontend-р…",
        time: 224,
      },
      {
        url: "https://www.youtube.com/live/JERUf-xKU1o?feature=share&t=394",
        title: "Публичное собеседование #6: Дмитрий …",
        time: 394,
      },
      {
        url: "https://www.youtube.com/live/wGVdU1Jje2M?feature=share&t=194",
        title: "Frontend-разработчик: публичное собе…",
        time: 194,
      },
      {
        url: "https://youtu.be/U3-TSl4cRn0?t=87",
        title: "Из питониста во фронтендеры: собесед…",
        time: 87,
      },
      {
        url: "https://youtu.be/lq4eefCCuVo?t=263",
        title: "Реальное СОБЕСЕДОВАНИЕ на FRONTEND р…",
        time: 263,
      },
      {
        url: "https://youtu.be/AWaL_1V9dEY?t=195",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 195,
      },
      {
        url: "https://youtu.be/PLwrvZahiO4?t=14",
        title: "Собеседование на JavaScript разработ…",
        time: 14,
      },
      {
        url: "https://youtu.be/hDl7w9U-Ly8?t=36",
        title: "Собеседование на Junior Frontend раз…",
        time: 36,
      },
      {
        url: "https://youtu.be/VzorPrTjUII?t=1",
        title: "Middle за год? Собеседование #3 fron…",
        time: 1,
      },
      {
        url: "https://youtu.be/ZEKcJgVI-YM?t=2",
        title: "Талант в 18 лет? Собеседование #2 fr…",
        time: 2,
      },
      {
        url: "https://youtu.be/B1IbTKdgCeE?t=1",
        title: "Крушитель алгоритмов? Собеседование …",
        time: 1,
      },
      {
        url: "https://youtu.be/MHrKcnyN46M?t=5",
        title: "СОБЕСЕДОВАНИЕ НА FRONTEND РАЗРАБОТЧИ…",
        time: 5,
      },
      {
        url: "https://youtu.be/jI6Zu6xAdps?t=4",
        title: "СОБЕСЕДОВАНИЕ REACT Middle Frontend …",
        time: 4,
      },
      {
        url: "https://youtu.be/NpQFVZoy4T8?t=9",
        title: "FRONTEND СОБЕСЕДОВАНИЕ С БЫВШИМ РУКО…",
        time: 9,
      },
      {
        url: "https://youtu.be/gt-Glqr-1DM?t=14",
        title: "Собеседование frontend junior+ разра…",
        time: 14,
      },
      {
        url: "https://youtu.be/cRqBsepPgoI?t=39",
        title: "Собеседование frontend junior+ разра…",
        time: 39,
      },
      {
        url: "https://youtu.be/tR7AO0NLsi8?t=39",
        title: "Делаем криптобиржу с синьором. Собес…",
        time: 39,
      },
      {
        url: "https://youtu.be/ScRTey_dvhI?t=32",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 32,
      },
      {
        url: "https://youtu.be/d5weK2w1V4A?t=16",
        title: "Собеседование Junior Frontend разраб…",
        time: 16,
      },
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=43",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 43,
      },
      {
        url: "https://youtu.be/HCXDrVikPGk?t=92",
        title: "Собеседование на Middle Frontend раз…",
        time: 92,
      },
      {
        url: "https://youtu.be/BOCkaqdbdCg?t=62",
        title: "Собеседование на Junior Frontend раз…",
        time: 62,
      },
      {
        url: "https://youtu.be/wP7XVriACtA?t=150",
        title: "Frontend Собеседование на Junior раз…",
        time: 150,
      },
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=143",
        title: "Первое интервью фронтендера самоучки…",
        time: 143,
      },
      {
        url: "https://youtu.be/OzLjBPjsGgg?t=92",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 92,
      },
      {
        url: "https://youtu.be/cq4QjslBPuc?t=385",
        title: "Public Technical Interview for a Jav…",
        time: 385,
      },
      {
        url: "https://youtu.be/eSurtsCCnA0?t=116",
        title: "Собеседование JavaScript-разработчик…",
        time: 116,
      },
      {
        url: "https://youtu.be/IvJIuPkzEns?t=139",
        title: "Реальное Собеседование JavaScript Ра…",
        time: 139,
      },
    ],
    rating: 96,
    image: null,
  },
  {
    id: 1633,
    question: "Расскажи про event loop",
    explanation:
      "Event Loop (цикл событий) — это один из ключевых аспектов асинхронного программирования, обеспечивающий возможность выполнения JavaScript-кода в однопоточном режиме, не блокируя выполнение других операций. Это достигается за счёт использования цикла, который постоянно проверяет, есть ли задачи для выполнения, и если они есть, то выполняет их одну за другой.\nJavaScript работает в одном потоке, что означает, что в любой момент времени может выполняться только одна операция. Однако, благодаря Event Loop, он способен обрабатывать асинхронные действия, такие как запросы к серверу, таймеры или обработка событий пользовательского интерфейса, не останавливаясь для ожидания их завершения.\nРаботает Event Loop следующим образом:\n1.\nCall Stack (Стек вызовов):\nСодержит текущий стек выполнения функций. Когда функция вызывается, она добавляется в стек вызовов, а когда выполнение функции заканчивается, она удаляется из стека.\n2.\nCallback Queue (Очередь обратных вызовов):\nКогда асинхронная операция завершается, её callback (функция обратного вызова) помещается в очередь обратных вызовов.\n3.\nEvent Loop:\nЦикл событий непрерывно проверяет стек вызовов на наличие функций для выполнения. Если стек вызовов пуст, Event Loop извлекает первую функцию из очереди обратных вызовов и помещает её в стек вызовов для выполнения.\nЭто позволяет JavaScript обрабатывать длительные операции, такие как загрузка данных, не блокируя главный поток и обеспечивая отзывчивость приложения.\nПример кода:\nconsole.log('Первое сообщение');\nsetTimeout(() => {\n    console.log('Сообщение из setTimeout');\n}, 0);\nconsole.log('Второе сообщение');\nВ этом примере, несмотря на то что `setTimeout` имеет задержку в 0 миллисекунд, вывод в консоль будет следующим:\nПервое сообщение\nВторое сообщение\nСообщение из setTimeout\nЭто происходит потому, что вызов\n`setTimeout`\nпомещает его callback в очередь обратных вызовов, который будет выполнен только после того, как выполнение текущего кода в стеке вызовов завершится и стек станет пустым.\nEvent Loop позволяет JavaScript выполнять асинхронные операции, обрабатывая их по мере завершения, не блокируя при этом главный поток выполнения. Это делает возможным создание отзывчивых и асинхронных веб-приложений.",
    videos: [
      {
        url: "https://youtu.be/PgQ4Bn8g4Fg?t=1427",
        title: "Публичное собеседование: Frontend-ра…",
        time: 1427,
      },
      {
        url: "https://www.youtube.com/live/t52BuzKzqWw?feature=share&t=446",
        title: "Публичное собеседование: junior-fron…",
        time: 446,
      },
      {
        url: "https://youtu.be/5gplqEVgajc?t=2570",
        title: "Cобеседование Junior Frontend разраб…",
        time: 2570,
      },
      {
        url: "https://youtu.be/PLwrvZahiO4?t=1462",
        title: "Собеседование на JavaScript разработ…",
        time: 1462,
      },
      {
        url: "https://youtu.be/VzorPrTjUII?t=224",
        title: "Middle за год? Собеседование #3 fron…",
        time: 224,
      },
      {
        url: "https://youtu.be/ZEKcJgVI-YM?t=607",
        title: "Талант в 18 лет? Собеседование #2 fr…",
        time: 607,
      },
      {
        url: "https://youtu.be/B1IbTKdgCeE?t=566",
        title: "Крушитель алгоритмов? Собеседование …",
        time: 566,
      },
      {
        url: "https://youtu.be/2zVAkqcUI4o?t=171",
        title: "СОБЕСЕДОВАНИЕ Middle FRONTEND разраб…",
        time: 171,
      },
      {
        url: "https://youtu.be/LcAQMKXpcqg?t=2056",
        title: "СОБЕСЕДОВАНИЕ JUNIOR FRONTEND РАЗРАБ…",
        time: 2056,
      },
      {
        url: "https://youtu.be/BsIcbU4LB0k?t=323",
        title: "ИНТЕРЕСНОЕ СОБЕСЕДОВАНИЕ JUNIOR Fron…",
        time: 323,
      },
      {
        url: "https://youtu.be/NpQFVZoy4T8?t=1040",
        title: "FRONTEND СОБЕСЕДОВАНИЕ С БЫВШИМ РУКО…",
        time: 1040,
      },
      {
        url: "https://youtu.be/gt-Glqr-1DM?t=3329",
        title: "Собеседование frontend junior+ разра…",
        time: 3329,
      },
      {
        url: "https://youtu.be/cRqBsepPgoI?t=2275",
        title: "Собеседование frontend junior+ разра…",
        time: 2275,
      },
      {
        url: "https://www.youtube.com/watch?v=g5LdFoV6iUg&t=2810s",
        title: "#12 Фронтенд-разработчик нейросети н…",
        time: 2810,
      },
      {
        url: "https://youtu.be/NnN4jq2lfGI?t=43",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 43,
      },
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=3767s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 3767,
      },
      {
        url: "https://youtu.be/qGdV5YOmtrs?t=1151",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 1151,
      },
      {
        url: "https://youtu.be/qika0TkDFz4?t=6919",
        title: "#7 Первое собеседование Junior Front…",
        time: 6919,
      },
      {
        url: "https://youtu.be/KvPUlwkSs_E?t=1060",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 1060,
      },
      {
        url: "https://youtu.be/DjY76sVa7xY?t=1134",
        title: "Камбоджи. Техническое собеседование …",
        time: 1134,
      },
    ],
    rating: 66,
    image: null,
  },
  {
    id: 1634,
    question: "Почему выбрано направление frontend и javascript",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/xGyI3uOXRjY?t=441",
        title: "Tech Interview Fest | Пробное собесе…",
        time: 441,
      },
      {
        url: "https://youtu.be/-HfKMcP_yt4?t=172",
        title: "Публичное собеседование: frontend-ра…",
        time: 172,
      },
      {
        url: "https://www.youtube.com/live/Awnog8KYub4?feature=share&t=216",
        title: "Публичное собеседование: Ведущий fro…",
        time: 216,
      },
      {
        url: "https://www.youtube.com/live/MdRE18dGmNU?feature=share&t=1279",
        title: "Публичное собеседование: Junior Fron…",
        time: 1279,
      },
      {
        url: "https://www.youtube.com/live/5U3Fy9mpu5Q?feature=share&t=229",
        title: "Публичное собеседование с frontend-р…",
        time: 229,
      },
      {
        url: "https://youtu.be/U3-TSl4cRn0?t=554",
        title: "Из питониста во фронтендеры: собесед…",
        time: 554,
      },
      {
        url: "https://youtu.be/NRufVTyELC4?t=467",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 467,
      },
      {
        url: "https://youtu.be/PLwrvZahiO4?t=56",
        title: "Собеседование на JavaScript разработ…",
        time: 56,
      },
      {
        url: "https://youtu.be/VzorPrTjUII?t=32",
        title: "Middle за год? Собеседование #3 fron…",
        time: 32,
      },
      {
        url: "https://youtu.be/ScRTey_dvhI?t=114",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 114,
      },
      {
        url: "https://www.youtube.com/watch?v=ozvUaikP6cs&t=75s",
        title: "#6 Как волноваться и не облажаться? …",
        time: 75,
      },
      {
        url: "https://youtu.be/d5weK2w1V4A?t=34",
        title: "Собеседование Junior Frontend разраб…",
        time: 34,
      },
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=111",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 111,
      },
      {
        url: "https://youtu.be/1Ej0Wx2TkSs?t=63",
        title: "#16 Собеседование Senior Frontend ра…",
        time: 63,
      },
      {
        url: "https://youtu.be/NnN4jq2lfGI?t=43",
        title: "#14 Собеседование Senior Frontend ра…",
        time: 43,
      },
      {
        url: "https://youtu.be/x7HRQkrWz6Y?t=568",
        title: "#10 Собеседование Frontend Senior ра…",
        time: 568,
      },
      {
        url: "https://www.youtube.com/watch?v=lrdaRbJctaA&t=75s",
        title: "Frontend интервью. Ильнура, первая р…",
        time: 75,
      },
      {
        url: "https://www.youtube.com/watch?v=ktdN2upYX1I&t=122s",
        title: "Стать фронтендером после 30: из рабо…",
        time: 122,
      },
    ],
    rating: 60,
    image: null,
  },
  {
    id: 1635,
    question: "Что такое promise и какие состояния у него есть",
    explanation:
      'Promise (обещание) — это объект, представляющий завершение (или неудачу) асинхронной операции и её результат. Он позволяет ассоциировать обработчики с асинхронным действием, тем самым избавляя от необходимости использовать обратные вызовы (callback-функции). Они упрощают работу с асинхронными операциями, такими как AJAX-запросы или чтение файлов, позволяя написать код, который проще понять и поддерживать.\nСостояния:\n1.\nPending (Ожидание):\nНачальное состояние; асинхронная операция не завершена.\n2.\nFulfilled (Исполнено):\nОперация завершена успешно, и promise возвращает результат.\n3.\nRejected (Отклонено):\nОперация завершена с ошибкой, и promise возвращает причину отказа.\nПример:l\net обещание = new Promise(function(resolve, reject) {\n    // Эмуляция асинхронной операции, например, запроса к серверу\n    setTimeout(() => {\n        // Условие успешного выполнения операции\n        if (/* условие успеха */) {\n            resolve("данные получены");\n        } else {\n            reject("ошибка при получении данных");\n        }\n    }, 1000);\n});\nобещание.then(\n    function(результат) { console.log(результат); }, // обработчик успеха\n    function(ошибка) { console.log(ошибка); } // обработчик ошибки\n);\nPromise поддерживает цепочки вызовов (\n`then`\n), что позволяет организовывать асинхронный код последовательно и читабельно. Кроме того, существуют вспомогательные методы, такие как\n`Promise.all`\n,\n`Promise.race`\n,\n`Promise.resolve`\n, и\n`Promise.reject`\n, которые облегчают работу с группами асинхронных операций.\nPromise — это способ организации асинхронного кода, который предоставляет более удобный и понятный интерфейс для работы с асинхронными операциями, чем традиционные callback-функции. У каждого обещания есть три состояния: ожидание, исполнено и отклонено, которые помогают управлять результатом асинхронных операций.',
    videos: [
      {
        url: "https://youtu.be/N1gKaF6BhDc?t=1989",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 1989,
      },
      {
        url: "https://youtu.be/xGyI3uOXRjY?t=2291",
        title: "Tech Interview Fest | Пробное собесе…",
        time: 2291,
      },
      {
        url: "https://youtu.be/gV6eobXisYU?t=417",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 417,
      },
      {
        url: "https://youtu.be/PLwrvZahiO4?t=919",
        title: "Собеседование на JavaScript разработ…",
        time: 919,
      },
      {
        url: "https://youtu.be/PLwrvZahiO4?t=945",
        title: "Собеседование на JavaScript разработ…",
        time: 945,
      },
      {
        url: "https://youtu.be/VzorPrTjUII?t=369",
        title: "Middle за год? Собеседование #3 fron…",
        time: 369,
      },
      {
        url: "https://youtu.be/ZEKcJgVI-YM?t=774",
        title: "Талант в 18 лет? Собеседование #2 fr…",
        time: 774,
      },
      {
        url: "https://youtu.be/jI6Zu6xAdps?t=258",
        title: "СОБЕСЕДОВАНИЕ REACT Middle Frontend …",
        time: 258,
      },
      {
        url: "https://www.youtube.com/watch?v=qika0TkDFz4&t=6560s",
        title: "#7 Первое собеседование Junior Front…",
        time: 6560,
      },
      {
        url: "https://www.youtube.com/watch?v=3D0IVhYzXJM&t=1490s",
        title: "#2 Собеседование смелого Frontend Mi…",
        time: 1490,
      },
      {
        url: "https://youtu.be/lrdaRbJctaA?t=2488",
        title: "Frontend интервью. Ильнура, первая р…",
        time: 2488,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=2024",
        title: "Собеседование cтажера Frontend разра…",
        time: 2024,
      },
      {
        url: "https://youtu.be/KvPUlwkSs_E?t=994",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 994,
      },
      {
        url: "https://youtu.be/e2r3JAuMSSg?t=3681",
        title: "#1. Публичное собеседование JUNIOR F…",
        time: 3681,
      },
    ],
    rating: 46,
    image: null,
  },
  {
    id: 1636,
    question: "Расскажи про проекты, которые ты кодил на js",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/-HfKMcP_yt4?t=1113",
        title: "Публичное собеседование: frontend-ра…",
        time: 1113,
      },
      {
        url: "https://www.youtube.com/live/5U3Fy9mpu5Q?feature=share&t=1139",
        title: "Frontend-разработчик: публичное собе…",
        time: 1139,
      },
      {
        url: "https://youtu.be/9nBbRK-Gfjg?t=177",
        title: "Мок-интервью для джуна-фронтендера: …",
        time: 177,
      },
      {
        url: "https://youtu.be/AWaL_1V9dEY?t=239",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 239,
      },
      {
        url: "https://youtu.be/ElCvv0iFWq4?t=77",
        title: "СОБЕСЕДОВАНИЕ Middle Frontend разраб…",
        time: 77,
      },
      {
        url: "https://youtu.be/LcAQMKXpcqg?t=8",
        title: "СОБЕСЕДОВАНИЕ JUNIOR FRONTEND РАЗРАБ…",
        time: 8,
      },
      {
        url: "https://youtu.be/BsIcbU4LB0k?t=44",
        title: "ИНТЕРЕСНОЕ СОБЕСЕДОВАНИЕ JUNIOR Fron…",
        time: 44,
      },
      {
        url: "https://youtu.be/HCXDrVikPGk?t=103",
        title: "Собеседование на Middle Frontend раз…",
        time: 103,
      },
      {
        url: "https://youtu.be/HCXDrVikPGk?t=390",
        title: "Собеседование на Middle Frontend раз…",
        time: 390,
      },
      {
        url: "https://youtu.be/wP7XVriACtA?t=552",
        title: "Frontend Собеседование на Junior раз…",
        time: 552,
      },
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=395",
        title: "Первое интервью фронтендера самоучки…",
        time: 395,
      },
    ],
    rating: 36,
    image: null,
  },
  {
    id: 1637,
    question: "Какие типы данных существуют в javascript",
    explanation:
      'Существует несколько основных типов данных, которые можно разделить на две категории: примитивные типы и объекты.\nПримитивные типы\n1.\nNumber:\nпредставляет как целые числа, так и числа с плавающей точкой. Например,\n`42`\nили\n`3.14`\n.\n2.\nString:\nпредставляет текстовые данные. Строки неизменяемы. Пример:\n`"Привет, мир!"`\n.\n3.\nBoolean:\nимеет два значения,\n`true`\nи\n`false`\n, и используется для работы с логическими операциями.\n4.\nUndefined:\nпеременная имеет тип\n`undefined`\n, если она была объявлена, но ей не было присвоено никакого значения.\n5.\nNull:\nспециальное значение, которое представляет собой "ничего" или "пустое значение". Важно отметить, что\n`null`\nявляется объектом из-за ошибки в ранних версиях JavaScript.\n6.\nSymbol:\nуникальное и неизменяемое значение, используемое как ключ для свойств объекта. Создают уникальные идентификаторы в объектах.\n7.\nBigInt:\nтип данных, позволяющий работать с целыми числами произвольной точности. Введен для представления чисел, которые больше, чем максимальное значение, которое может представить тип\n`Number`\n.\nОбъекты:\nObject: могут содержать наборы пар ключ-значение, где ключи - строки или символы, а значения — любой тип данных. Используются для представления коллекций данных, сложных структур или для создания пользовательских типов данных с помощью классов и прототипов.\nСпециальные типы:\n- Массивы: используются для хранения упорядоченных коллекций данных.\n- Функции: объекты первого класса, поддерживающие вызов.\n- Дата: для работы с датами и временем.\n- Регулярные выражения: для работы с регулярными выражениями.\nВажно понимать разницу между примитивными типами и объектами, поскольку это влияет на способ работы с переменными и передачу данных в функции.',
    videos: [
      {
        url: "https://youtu.be/gV6eobXisYU?t=64",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 64,
      },
      {
        url: "https://youtu.be/gt-Glqr-1DM?t=1737",
        title: "Собеседование frontend junior+ разра…",
        time: 1737,
      },
      {
        url: "https://youtu.be/cRqBsepPgoI?t=1634",
        title: "Собеседование frontend junior+ разра…",
        time: 1634,
      },
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=2065s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 2065,
      },
      {
        url: "https://www.youtube.com/watch?v=k0dAETyBPvU&t=845s",
        title: "#8 Маркетолог ушел на фронт. Собесед…",
        time: 845,
      },
      {
        url: "https://www.youtube.com/watch?v=wP7XVriACtA&t=1486s",
        title: "Frontend Собеседование на Junior раз…",
        time: 1486,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=435",
        title: "Собеседование cтажера Frontend разра…",
        time: 435,
      },
      {
        url: "https://youtu.be/0fI5sTI5uck?t=599",
        title: "Собеседование в Яндексе - Разработчи…",
        time: 599,
      },
    ],
    rating: 26,
    image: null,
  },
  {
    id: 1638,
    question: "Какая самая интересная задача у тебя была",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/NRufVTyELC4?t=526",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 526,
      },
      {
        url: "https://www.youtube.com/watch?v=ozvUaikP6cs&t=275s",
        title: "#6 Как волноваться и не облажаться? …",
        time: 275,
      },
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=245",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 245,
      },
      {
        url: "https://www.youtube.com/watch?v=k0dAETyBPvU&t=380s",
        title: "#8 Маркетолог ушел на фронт. Собесед…",
        time: 380,
      },
      {
        url: "https://www.youtube.com/watch?v=1Ej0Wx2TkSs&t=458s",
        title: "#16 Собеседование Senior Frontend ра…",
        time: 458,
      },
      {
        url: "https://www.youtube.com/watch?v=NnN4jq2lfGI&t=300s",
        title: "#14 Собеседование Senior Frontend ра…",
        time: 300,
      },
      {
        url: "https://youtu.be/3D0IVhYzXJM?t=261",
        title: "#2 Собеседование смелого Frontend Mi…",
        time: 261,
      },
      {
        url: "https://youtu.be/BOCkaqdbdCg?t=3732",
        title: "Собеседование на Junior Frontend раз…",
        time: 3732,
      },
    ],
    rating: 26,
    image: null,
  },
  {
    id: 1639,
    question: "Чем let отличается от var",
    explanation:
      'Ключевые слова\n`let`\nи\n`var`\nиспользуются для объявления переменных, но между ними есть несколько важных различий, касающихся области видимости, поднятия (hoisting) и создания блока.\nОбласть видимости (Scope)\nvar:\nОбъявления переменных с использованием\n`var`\nимеют функциональную область видимости, что означает, что переменная, объявленная с помощью нее внутри функции, доступна везде в этой функции.\nlet:\nВ отличие от\n`var`\n,\n`let`\nимеет блочную область видимости. Это означает, что переменная, объявленная с помощью нее в блоке (например, в цикле или условном операторе), будет доступна только в пределах этого блока.\nПоднятие (Hoisting)\nvar:\nПеременные, объявленные с ее помощью, поднимаются в начало функции или скрипта. Это означает, что они могут быть использованы до своего объявления, хотя до инициализации они будут иметь значение\n`undefined`\n.\nlet:\nПеременные, объявленные с ее помощью, также поднимаются, но не инициализируются. Попытка доступа к такой переменной до её объявления приведет к ошибке\n`ReferenceError`\n. Это поведение известно как "временная мертвая зона" (temporal dead zone, TDZ).\nСоздание в глобальном контексте\nvar:\nПеременные, объявленные с ее помощью в глобальном контексте, становятся свойствами глобального объекта (\n`window`\nв браузерах).\nlet:\nПеременные, объявленные с ее помощью в глобальном контексте, не становятся свойствами глобального объекта.\nПримеры\nif (true) {\n  var varVariable = "Я доступен везде в функции";\n  let letVariable = "Я доступен только в этом блоке";\n}\nconsole.log(varVariable); // Работает, потому что var имеет функциональную область видимости\nconsole.log(letVariable); // Ошибка, потому что let имеет блочную область видимости\nconsole.log(a); // undefined из-за поднятия\nvar a = 3;\nconsole.log(b); // ReferenceError из-за временной мертвой зоны\nlet b = 4;\n`let`\nпредоставляет более строгую и предсказуемую область видимости переменных, что улучшает управляемость кодом и уменьшает вероятность ошибок, связанных с неожиданным доступом или изменением данных.\n`var`\nможет быть полезен, когда нужна функциональная область видимости, но сейчас\n`let`\nи\n`const`\n(для объявления констант) являются предпочтительными вариантами для управления переменными.\nВ то время как\n`var`\nобъявляет переменную, доступную во всей функции, а\n`let`\nограничивает видимость переменной блоком, в котором она объявлена.',
    videos: [
      {
        url: "https://youtu.be/Y1SekvuZ3M4?t=827",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 827,
      },
      {
        url: "https://youtu.be/PLwrvZahiO4?t=562",
        title: "Собеседование на JavaScript разработ…",
        time: 562,
      },
      {
        url: "https://youtu.be/YwRgLQ0SoKk?t=220",
        title: "Собеседование frontend разработчика",
        time: 220,
      },
      {
        url: "https://youtu.be/cRqBsepPgoI?t=1801",
        title: "Собеседование frontend junior+ разра…",
        time: 1801,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=574",
        title: "Собеседование cтажера Frontend разра…",
        time: 574,
      },
      {
        url: "https://youtu.be/OzLjBPjsGgg?t=1195",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 1195,
      },
      {
        url: "https://youtu.be/e2r3JAuMSSg?t=2624",
        title: "#1. Публичное собеседование JUNIOR F…",
        time: 2624,
      },
      {
        url: "https://youtu.be/SjU80VK0-SQ?t=169",
        title: "[150k+] Собеседование в Москва Сити …",
        time: 169,
      },
    ],
    rating: 26,
    image: null,
  },
  {
    id: 1640,
    question: "Какой опыт во frontend",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/9nBbRK-Gfjg?t=169",
        title: "Мок-интервью для джуна-фронтендера: …",
        time: 169,
      },
      {
        url: "https://youtu.be/2zVAkqcUI4o?t=41",
        title: "СОБЕСЕДОВАНИЕ Middle FRONTEND разраб…",
        time: 41,
      },
      {
        url: "https://youtu.be/BsIcbU4LB0k?t=12",
        title: "ИНТЕРЕСНОЕ СОБЕСЕДОВАНИЕ JUNIOR Fron…",
        time: 12,
      },
      {
        url: "https://youtu.be/gt-Glqr-1DM?t=15",
        title: "Собеседование frontend junior+ разра…",
        time: 15,
      },
      {
        url: "https://youtu.be/cRqBsepPgoI?t=40",
        title: "Собеседование frontend junior+ разра…",
        time: 40,
      },
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=149",
        title: "Первое интервью фронтендера самоучки…",
        time: 149,
      },
      {
        url: "https://youtu.be/2s1hZUtWchs?t=53",
        title: "Скайп - собеседование Frontend Devel…",
        time: 53,
      },
    ],
    rating: 23,
    image: null,
  },
  {
    id: 1641,
    question: "Чем var отличается от const",
    explanation:
      'Ключевые слова\n`var`\nи\n`const`\nиспользуются для объявления переменных, но они имеют ряд существенных различий, которые важно понимать для правильного использования в коде.\nОбласть видимости (Scope)\nvar:\nОбъявления переменных с ее использованием имеют функциональную область видимости (function scope), что означает, что переменная доступна везде в функции, где была объявлена.\nconst:\nКак и\n`let`\n, она имеет блочную область видимости (block scope), ограничивая доступность переменной блоком (например, циклом или условным оператором), в котором была объявлена.\nПереназначение и изменение\nvar:\nПеременные, объявленные с помощью нее, могут быть переназначены и изменены. Это означает, что после объявления переменной её можно не только изменить, но и полностью переназначить на другое значение.\nconst:\nПеременные, объявленные с помощью нее, не могут быть переназначены. Однако, если переменная представляет собой объект или массив, её содержимое может быть изменено (например, можно добавить новое свойство в объект или новый элемент в массив). Важно понимать, что `const` предотвращает переназначение самой переменной, но не защищает содержимое объекта от изменений.\nПоднятие (Hoisting)\nvar:\nПеременные, объявленные через нее, поднимаются в начало своей функциональной области видимости перед выполнением кода. Однако до их объявления в коде они будут иметь значение `undefined`.\nconst:\nПодобно\n`let`\n, ее объявления тоже поднимаются, но доступ к переменной до её объявления в коде приведёт к ошибке\n`ReferenceError`\n. Это явление известно как "временная мертвая зона".\nИнициализация\nvar:\nЭти переменные можно объявить без инициализации, и их начальное значение будет\n`undefined`\n.\nconst:\nЭти переменные требуют обязательной инициализации при объявлении. Если попытаться объявить его без инициализации, это приведет к синтаксической ошибке.\nПримеры\nvar varVariable = 1;\nvarVariable = 2; // Переназначение возможно\nconst constVariable = { a: 1 };\nconstVariable.a = 2; // Изменение содержимого объекта возможно\n// constVariable = { b: 3 }; // Переназначение вызовет ошибку\nif (true) {\n  var varScope = "доступна везде в функции";\n  const constScope = "доступна только в этом блоке";\n}\nconsole.log(varScope); // Выведет строку\nconsole.log(constScope); // Ошибка: constScope не определена\nИспользование\n`var`\n,\n`let`\nи\n`const`\nзависит от нужд разработки.\n`var`\nпредоставляет функциональную область видимости и большую гибкость за счёт возможности переназначения, но это может привести к ошибкам из-за непреднамеренных изменений или переназначений.\n`const`\nиспользуется для объявления переменных, значение которых не должно изменяться, что помогает предотвратить случайное переназначение и делает код более предсказуемым. Сейчас\n`let`\nи\n`const`\nявляются предпочтительными для блочной области видимости и контроля за изменяемостью данных.',
    videos: [
      {
        url: "https://youtu.be/Y1SekvuZ3M4?t=651",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 651,
      },
      {
        url: "https://youtu.be/YwRgLQ0SoKk?t=220",
        title: "Собеседование frontend разработчика",
        time: 220,
      },
      {
        url: "https://youtu.be/cRqBsepPgoI?t=1801",
        title: "Собеседование frontend junior+ разра…",
        time: 1801,
      },
      {
        url: "https://youtu.be/d5weK2w1V4A?t=384",
        title: "Собеседование Junior Frontend разраб…",
        time: 384,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=574",
        title: "Собеседование cтажера Frontend разра…",
        time: 574,
      },
      {
        url: "https://youtu.be/OzLjBPjsGgg?t=1195",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 1195,
      },
      {
        url: "https://youtu.be/SjU80VK0-SQ?t=169",
        title: "[150k+] Собеседование в Москва Сити …",
        time: 169,
      },
    ],
    rating: 23,
    image: null,
  },
  {
    id: 1642,
    question: "Ближайшие планы на будущее",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=ozvUaikP6cs&t=245s",
        title: "#6 Как волноваться и не облажаться? …",
        time: 245,
      },
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=375",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 375,
      },
      {
        url: "https://www.youtube.com/watch?v=k0dAETyBPvU&t=542s",
        title: "#8 Маркетолог ушел на фронт. Собесед…",
        time: 542,
      },
      {
        url: "https://www.youtube.com/watch?v=1Ej0Wx2TkSs&t=1130s",
        title: "#16 Собеседование Senior Frontend ра…",
        time: 1130,
      },
      {
        url: "https://youtu.be/qika0TkDFz4?t=537",
        title: "#7 Первое собеседование Junior Front…",
        time: 537,
      },
      {
        url: "https://www.youtube.com/watch?v=3D0IVhYzXJM&t=408s",
        title: "#2 Собеседование смелого Frontend Mi…",
        time: 408,
      },
      {
        url: "https://www.youtube.com/watch?v=8Xuftz2IiAI&t=865s",
        title: "Первое интервью фронтендера самоучки…",
        time: 865,
      },
    ],
    rating: 23,
    image: null,
  },
  {
    id: 1643,
    question:
      "Что знаешь о различии между function expression и function declaration",
    explanation:
      "Существует два основных способа объявления функций: Function Declaration (Объявление Функции) и Function Expression (Функциональное Выражение). Хотя оба подхода определяют функции, между ними есть несколько ключевых различий, влияющих на поведение и использование функций в коде.\nFunction Declaration (Объявление Функции)\nСпособ объявления функции, при котором используется ключевое слово `function`, за которым следует имя функции.\nПример:\nfunction sum(a, b) {\n  return a + b;\n}\nОсобенности:\nПоднятие (Hoisting):\nПоднимаются вверх их области видимости перед выполнением кода, что позволяет вызывать функции до их объявления в коде.\nОбласть видимости:\nОпределяется её местом в коде: в глобальной области видимости, в области видимости другой функции или в блочной области видимости (в строгом режиме).\nМутабельность:\nИмя функции является неизменным и не может быть переназначено.\nFunction Expression (Функциональное Выражение)\nСпособ объявления функции, при котором функция создаётся в рамках выражения. Функциональные выражения могут быть анонимными или именованными.\nПример:\nconst sum = function(a, b) {\n  return a + b;\n};\nОсобенности:\nПоднятие (Hoisting):\nПеременные, объявленные через\n`var`\n, поднимаются, но инициализируются значением\n`undefined`\n, поэтому функциональное выражение не будет доступно до его объявления в коде. Если функциональное выражение объявлено через\n`let`\nили\n`const`\n, то оно вообще не будет доступно до объявления из-за временной мертвой зоны.\nАнонимные и именованные функции:\nФункциональные выражения могут быть анонимными (не иметь имени) или именованными. Именованные функциональные выражения могут быть полезны для улучшения читаемости кода и при отладке.\nИспользование в выражениях:\nФункциональные выражения могут использоваться в любых местах, где допустимы выражения, например, в качестве аргументов для других функций.\nОсновное различие между Function Declaration и Function Expression заключается в том, что объявления функций поднимаются и доступны в своей области видимости до выполнения кода, в то время как функциональные выражения доступны только после своего объявления в коде. Выбор между этими двумя способами объявления функций зависит от конкретной задачи, стиля программирования и предпочтений разработчика. Function Expression предоставляет большую гибкость, особенно когда необходимо использовать анонимные функции или присваивать функции переменным.",
    videos: [
      {
        url: "https://youtu.be/N1gKaF6BhDc?t=1082",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 1082,
      },
      {
        url: "https://youtu.be/PLwrvZahiO4?t=685",
        title: "Собеседование на JavaScript разработ…",
        time: 685,
      },
      {
        url: "https://youtu.be/ScRTey_dvhI?t=1196",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 1196,
      },
      {
        url: "https://youtu.be/ktdN2upYX1I?t=1482",
        title: "Собеседование на Middle Frontend раз…",
        time: 1482,
      },
      {
        url: "https://www.youtube.com/watch?v=BOCkaqdbdCg&t=2335s",
        title: "Собеседование на Junior Frontend раз…",
        time: 2335,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=1223",
        title: "Собеседование cтажера Frontend разра…",
        time: 1223,
      },
    ],
    rating: 20,
    image: null,
  },
  {
    id: 1644,
    question: "В чём разница между классической функцией и стрелочной",
    explanation:
      'Классические функции (объявленные через ключевое слово `function`) и стрелочные функции (введённые в ES6 через\n`=>`\nсинтаксис) являются двумя способами объявления функций, но между ними есть несколько важных различий:\n1.\nСинтаксис\nКлассическая функция:\nfunction add(a, b) {\n  return a + b;\n}\nСтрелочная функция:\nconst add = (a, b) => a + b;\nПредлагают более краткий синтаксис для написания функций, особенно если функция состоит из одного выражения.\n2. К\nонтекст `this`\nВ классических функциях контекст определяется тем, как функция была вызвана. В стрелочных функциях контекст наследуется из окружающего контекста (лексический контекст\n`this`\n), где функция была объявлена.\nПример с классической функцией:\nconst obj = {\n  id: 42,\n  counter: function() {\n    setTimeout(function() {\n      console.log(this.id); // `this` ссылается на глобальный объект или undefined в строгом режиме, а не на obj\n    }, 1000);\n  }\n};\nПример со стрелочной функцией:\nconst obj = {\n  id: 42,\n  counter: function() {\n    setTimeout(() => {\n      console.log(this.id); // `this` корректно ссылается на obj, так как стрелочная функция наследует `this` из окружения\n    }, 1000);\n  }\n};\n3.\nКонструктор\nКлассические функции могут использоваться с помощью ключевого слова\n`new`\n. Стрелочные функции не могут быть использованы как конструкторы, и попытка это сделать приведет к ошибке.\nПример с классической функцией:\nfunction Person(name) {\n  this.name = name;\n}\nconst person = new Person("Alice");\nПопытка использовать стрелочную функцию как конструктор:\nconst Person = (name) => {\n  this.name = name;\n};\n// const person = new Person("Alice"); // Ошибка: Person не является конструктором\n4.\nАргументы\nВ классических функциях можно использовать объект\n`arguments`\n, который содержит аргументы, переданные функции. В стрелочных функциях нет объекта\n`arguments`\n, но можно использовать оператор расширения\n`...`\nдля достижения аналогичного результата.\nОсновные различия между классическими и стрелочными функциями заключаются в синтаксисе, поведении\n`this`\n, использовании в качестве конструктора и доступе к аргументам функции. Стрелочные функции предлагают более краткий синтаксис и удобны для написания коротких функций, а также при работе с контекстом\n`this`\nв обратных вызовах и замыканиях. Однако для более сложных сценариев, требующих использования\n`this`\nв различных контекстах или создания конструкторов, предпочтительнее использовать классические функции.',
    videos: [
      {
        url: "https://youtu.be/xGyI3uOXRjY?t=1506",
        title: "Tech Interview Fest | Пробное собесе…",
        time: 1506,
      },
      {
        url: "https://youtu.be/gV6eobXisYU?t=257",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 257,
      },
      {
        url: "https://youtu.be/Y1SekvuZ3M4?t=1255",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 1255,
      },
      {
        url: "https://youtu.be/VzorPrTjUII?t=984",
        title: "Middle за год? Собеседование #3 fron…",
        time: 984,
      },
      {
        url: "https://youtu.be/YwRgLQ0SoKk?t=771",
        title: "Собеседование frontend разработчика",
        time: 771,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=1240",
        title: "Собеседование cтажера Frontend разра…",
        time: 1240,
      },
    ],
    rating: 20,
    image: null,
  },
  {
    id: 1645,
    question: "Какие были обязанности в прошлом проекте",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/JERUf-xKU1o?feature=share&t=769",
        title: "Публичное собеседование #6: Дмитрий …",
        time: 769,
      },
      {
        url: "https://www.youtube.com/live/wGVdU1Jje2M?feature=share&t=650",
        title: "Мок-интервью для джуна-фронтендера: …",
        time: 650,
      },
      {
        url: "https://youtu.be/NRufVTyELC4?t=613",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 613,
      },
      {
        url: "https://youtu.be/lq4eefCCuVo?t=278",
        title: "Реальное СОБЕСЕДОВАНИЕ на FRONTEND р…",
        time: 278,
      },
      {
        url: "https://youtu.be/ElCvv0iFWq4?t=77",
        title: "СОБЕСЕДОВАНИЕ Middle Frontend разраб…",
        time: 77,
      },
      {
        url: "https://youtu.be/2s1hZUtWchs?t=147",
        title: "Скайп - собеседование Frontend Devel…",
        time: 147,
      },
    ],
    rating: 20,
    image: null,
  },
  {
    id: 1646,
    question: "В чем разница == и ===",
    explanation:
      "Операторы\n`==`\n(равно) и\n`===`\n(строго равно) используются для сравнения значений, но работают по-разному, что важно понимать для написания надёжного и предсказуемого кода.\nОператор == (равно)\nСравнивает значения двух переменных, но перед сравнением производит приведение типов, если переменные относятся к разным типам. Это означает, что если вы сравниваете число с строкой, JavaScript попытается преобразовать строку в число, а затем сравнить эти два значения. Этот процесс может привести к неинтуитивным результатам.\nПримеры:\n'2' == 2 // true, так как строка '2' преобразуется в число 2 перед сравнением\n0 == false // true, так как 0 и false считаются эквивалентными\nnull == undefined // true, специальное правило языка\nОператор === (строго равно)\nВ отличие от\n`==`\n, он сравнивает и значения, и типы без приведения типов. Если типы различаются, оператор немедленно возвращает\n`false`\n, не пытаясь преобразовать один тип в другой. Это делает сравнение более строгим и предсказуемым.\nПримеры:\n'2' === 2 // false, так как типы различаются\n0 === false // false, разные типы: число и булево значение\nnull === undefined // false, разные типы\nПочему важно знать разницу\nПонимание разницы между\n`==`\nи\n`===`\nкритически важно, чтобы избежать ошибок, связанных с неожиданным приведением типов. Использование\n`===`\nпомогает гарантировать, что сравниваемые значения совпадают по типу и значению, что является более безопасным подходом в большинстве случаев. В целом, рекомендуется использовать\n`===`\nдля сравнения значений, чтобы код был более читабельным и предсказуемым.\n`==`\nсравнивает значения, приводя их к общему типу, что может привести к неожиданным результатам из-за неявного приведения типов.\n`===`\nсравнивает как значения, так и типы без приведения типов, обеспечивая более строгое и предсказуемое сравнение. Использование\n`===`\nрекомендуется для большей надёжности и читабельности кода.",
    videos: [
      {
        url: "https://youtu.be/5gplqEVgajc?t=4074",
        title: "Cобеседование Junior Frontend разраб…",
        time: 4074,
      },
      {
        url: "https://youtu.be/gV6eobXisYU?t=100",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 100,
      },
      {
        url: "https://youtu.be/d5weK2w1V4A?t=1315",
        title: "Собеседование Junior Frontend разраб…",
        time: 1315,
      },
      {
        url: "https://www.youtube.com/watch?v=EaTZXKlpsj0&t=5440s",
        title: "#11 Фронтендер в 17 лет? Собеседован…",
        time: 5440,
      },
      {
        url: "https://youtu.be/lrdaRbJctaA?t=1716",
        title: "Frontend интервью. Ильнура, первая р…",
        time: 1716,
      },
      {
        url: "https://youtu.be/ktdN2upYX1I?t=1667",
        title: "Стать фронтендером после 30: из рабо…",
        time: 1667,
      },
    ],
    rating: 20,
    image: null,
  },
  {
    id: 1647,
    question: "Что такое макро и микро задачи",
    explanation:
      "Макро- и микро-задачи являются частью механизма асинхронного программирования и внутренней модели выполнения, которые помогают управлять порядком выполнения асинхронных операций. Эти понятия связаны с циклом событий (event loop) и очередью задач. Давайте разберемся, что они собой представляют и как работают.\nМикро-задачи (Microtasks)\nЭто задачи, которые запланированы для выполнения сразу после текущего выполненного скрипта, но до того, как event loop продолжит обрабатывать следующую макро-задачу. Примеры:\nОбещания (Promises):\n`then`\n,\n`catch`\n,\n`finally`\n`queueMicrotask()`\nМакро-задачи (Macrotasks)\nЭто задачи, которые обрабатываются event loop, каждая макро-задача извлекается из очереди и выполняется до конца, прежде чем event loop перейдет к следующей макро-задаче. Примеры:\n`setTimeout`\n`setInterval`\n`setImmediate`\n(Node.js)\nI/O операции\nИнтерактивные действия, такие как клики мыши и нажатия клавиш\nРазличия и порядок выполнения\nОсновное различие между макро- и микро-задачами заключается в их приоритете выполнения:\nПосле каждой макро-задачи, перед тем как переходить к следующей макро-задаче, event loop обрабатывает все микро-задачи в очереди микро-задач. Это означает, что микро-задачи выполняются чаще и имеют более высокий приоритет по сравнению с макро-задачами.\nЕсли во время выполнения микро-задач добавляются новые микро-задачи, они также будут выполнены в текущем цикле, перед переходом к следующей макро-задаче. Это может привести к \"голоданию\" макро-задач, если микро-задачи постоянно добавляются.\nПример:\nsetTimeout(() => console.log('Макро-задача 1'), 0);\nPromise.resolve().then(() => console.log('Микро-задача 1'));\nsetTimeout(() => console.log('Макро-задача 2'), 0);\nPromise.resolve().then(() => console.log('Микро-задача 2'));\nВ этом примере порядок вывода будет следующим:\n1. Микро-задача 1\n2. Микро-задача 2\n3. Макро-задача 1\n4. Макро-задача 2\nЭто демонстрирует, как микро-задачи имеют приоритет и выполняются до того, как event loop переходит к следующей макро-задаче.\nПонимание различий между макро- и микро-задачами важно для эффективной работы с асинхронным кодом, поскольку это влияет на порядок выполнения операций и может быть источником трудноуловимых ошибок или неожиданного поведения программы.",
    videos: [
      {
        url: "https://youtu.be/PLwrvZahiO4?t=1615",
        title: "Собеседование на JavaScript разработ…",
        time: 1615,
      },
      {
        url: "https://youtu.be/ZEKcJgVI-YM?t=683",
        title: "Талант в 18 лет? Собеседование #2 fr…",
        time: 683,
      },
      {
        url: "https://youtu.be/2zVAkqcUI4o?t=267",
        title: "СОБЕСЕДОВАНИЕ Middle FRONTEND разраб…",
        time: 267,
      },
      {
        url: "https://youtu.be/LcAQMKXpcqg?t=2218",
        title: "СОБЕСЕДОВАНИЕ JUNIOR FRONTEND РАЗРАБ…",
        time: 2218,
      },
      {
        url: "https://youtu.be/NpQFVZoy4T8?t=1185",
        title: "FRONTEND СОБЕСЕДОВАНИЕ С БЫВШИМ РУКО…",
        time: 1185,
      },
      {
        url: "https://youtu.be/e2r3JAuMSSg?t=4330",
        title: "#1. Публичное собеседование JUNIOR F…",
        time: 4330,
      },
    ],
    rating: 20,
    image: null,
  },
  {
    id: 1648,
    question: "Какие способы изоляции стилей ты знаешь",
    explanation:
      "Изоляция стилей в веб-разработке важна для предотвращения конфликтов CSS и обеспечения того, чтобы стили одного компонента или раздела страницы не влияли на другие. Существует несколько таких подходов:\n1.\nИспользование уникальных имен классов\nЭто самый простой способ избежать конфликтов. Может быть достигнуто с помощью методологий именования, таких как BEM (Блок, Элемент, Модификатор), которая предлагает чёткую структуру для именования классов.\n2.\nCSS-модули\nОни представляют собой подход, при котором классы и идентификаторы, определенные в CSS-файле, автоматически преобразуются в уникальные имена. Это позволяет избежать конфликтов имен классов между различными компонентами. Они оддерживаются в сборщиках, таких как Webpack, и во фреймворках, например, в Create React App.\n3.\nCSS-in-JS\nБиблиотеки CSS-in-JS, такие как Styled-components и Emotion, позволяют писать CSS прямо в JavaScript-файлах. Это обеспечивает полную изоляцию стилей, поскольку стили применяются непосредственно к компонентам, и конфликты имен классов исключаются.\n4.\nShadow DOM\nТехнология, позволяющая инкапсулировать DOM-дерево и стили компонента так, что они не влияют на основной документ. Это ключевая часть Web Components и позволяет создавать полностью изолированные компоненты.\n5.\nScoped CSS\nНекоторые современные фреймворки и инструменты, такие как Vue.js, предлагают возможность использования scoped стилей, где CSS применяется исключительно к компоненту, в котором он объявлен, без воздействия на остальную часть приложения.\n6.\nИспользование IFRAME\nРазмещение контента внутри\n`<iframe>`\nпозволяет полностью изолировать его стили от остальной части страницы. Это крайний способ, который может быть полезен для встраивания стороннего контента, но он приносит дополнительную сложность и ограничения.\n7.\nCSS-переменные для темизации\nСами по себе не обеспечивают изоляцию, их можно использовать для создания гибкой системы тем, которая позволяет контролировать влияние глобальных стилей на компоненты и облегчает поддержание стилевой согласованности.\nИзоляция стилей — важный аспект разработки надёжных и масштабируемых веб-приложений. Выбор метода зависит от конкретных требований проекта, технологического стека и предпочтений разработчика. Использование современных инструментов и подходов, таких как CSS-модули, CSS-in-JS и Web Components, может значительно упростить управление стилями и повысить качество конечного продукта.",
    videos: [
      {
        url: "https://youtu.be/YwRgLQ0SoKk?t=4066",
        title: "Собеседование frontend разработчика",
        time: 4066,
      },
      {
        url: "https://youtu.be/ScRTey_dvhI?t=6810",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 6810,
      },
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=6335",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 6335,
      },
      {
        url: "https://www.youtube.com/watch?v=BonLyarPpqE&t=2060s",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 2060,
      },
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=956s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 956,
      },
      {
        url: "https://www.youtube.com/watch?v=1Ej0Wx2TkSs&t=1690s",
        title: "#16 Собеседование Senior Frontend ра…",
        time: 1690,
      },
    ],
    rating: 20,
    image: null,
  },
  {
    id: 1649,
    question: "В чём отличие null от undefined",
    explanation:
      '`null`\nи\n`undefined`\nоба представляют значения, которые указывают на "отсутствие значения", но между ними есть ключевые отличия:\nundefined\nПеременная была объявлена, но не была инициализирована, то есть ей не было присвоено какое-либо значение. Это значение по умолчанию для переменных, объявленных с помощью\n`var`\n,\n`let`\nили\n`const`\n, а также для аргументов функций, которым не были переданы значения, и для возвращаемого значения функций, которые не возвращают явно какое-либо значение.\nТакже является типом данных. То есть\n`typeof undefined`\nвернёт\n`"undefined"`\n.\nnull\nИспользуется для явного указания на отсутствие объекта или значения. Это сигнал для программиста о том, что переменная должна служить для хранения объекта, но в данный момент она "пуста" или не указывает на какой-либо объект.\nВ отличие от `undefined`, он является объектом. То есть\n`typeof null`\nвернёт\n`"object"`\n, что может быть немного запутывающим. Это известная особенность языка, сохраняемая для обратной совместимости.\nКогда использовать\nИспользуйте\n`undefined`\nдля проверки, была ли переменная инициализирована или определена функция/параметр.\nИспользуйте\n`null`\nв качестве намеренного отсутствия какого-либо объектного значения. Это полезно, например, при инициализации переменной, которая позже должна быть назначена объекту.\nСравнение\nПри нестрогом сравнении (\n`==`\n)\n`null`\nи\n`undefined`\nсчитаются равными, потому что оба представляют отсутствие значения. То есть\n`null == undefined`\nвернёт\n`true`\n.При строгом сравнении (\n`===`\n), которое учитывает тип данных\nПри строгом сравнении (\n`===`\n), которое учитывает тип данных, они считаются различными:\n`null === undefined`\nвернёт\n`false`\n.\nВ целом,\n`null`\nи\n`undefined`\nиграют важную роль в представлении и обработке отсутствия данных, но их семантическое значение и использование различаются, что важно учитывать при разработке программ.',
    videos: [
      {
        url: "https://youtu.be/xGyI3uOXRjY?t=1242",
        title: "Tech Interview Fest | Пробное собесе…",
        time: 1242,
      },
      {
        url: "https://youtu.be/gV6eobXisYU?t=175",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 175,
      },
      {
        url: "https://youtu.be/jf5TkGzWqiM?t=79",
        title: "Собеседование JUNIOR FRONTEND REACT …",
        time: 79,
      },
      {
        url: "https://youtu.be/EaTZXKlpsj0?t=5036",
        title: "#11 Фронтендер в 17 лет? Собеседован…",
        time: 5036,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=483",
        title: "Собеседование cтажера Frontend разра…",
        time: 483,
      },
    ],
    rating: 16,
    image: null,
  },
  {
    id: 1650,
    question: "Можешь рассказать о семантическом вресионировании",
    explanation:
      "Семантическое версионирование (Semantic Versioning, часто сокращается как SemVer) — это система управления версиями, которая стремится быть как можно более предсказуемой и прозрачной. Она основана на трех цифрах, разделенных точками, например, 1.4.8, где каждая из цифр обозначает определенный тип изменений в ПО:\n1.\nМажорная версия\n(Major version) — первая цифра. Увеличивается, когда вносятся изменения, совместимые только в одну сторону. Это означает, что новая версия может содержать изменения, которые не будут работать с предыдущими версиями программного обеспечения без модификации кода. Например, удаление функций или изменение их поведения так, что старый код перестает работать.\n2.\nМинорная версия\n(Minor version) — вторая цифра. Увеличивается, когда добавляются новые функциональности, которые не нарушают обратную совместимость с более старыми версиями. Это означает, что вы можете обновиться до этой версии без изменений в существующем коде, и все будет работать.\n3.\nПатч-версия\n(Patch version) — третья цифра. Увеличивается при внесении исправлений ошибок, которые не влияют на API и не добавляют новых функций, сохраняя обратную совместимость. Эти изменения обычно безопасны и рекомендуется обновляться как можно скорее.\nЭта система также может включать дополнительные обозначения для пре-релизов (например, 1.0.0-alpha.1) и сборок (например, 1.0.0+20130313144700), которые предоставляют дополнительную информацию о версии.\nПреимущества:\nПредсказуемость:\nМожно определить характер изменений по номеру версии, что упрощает управление зависимостями.\nПрозрачность:\nЛегко понять, какие изменения были внесены между разными версиями.\nСовместимость:\nПомогает в поддержании совместимости между разными версиями библиотек или приложений.\nПример:\n// Версия 1.0.0: Исходная версия вашей библиотеки\n// Версия 1.1.0: Добавление новой функции, совместимой с предыдущими версиями\n// Версия 1.1.1: Исправление ошибки в новой функции, не влияющее на существующий API\n// Версия 2.0.0: Удаление старой функции, что делает эту версию несовместимой с кодом, написанным для версии 1.x.x\nСемантическое версионирование — это система управления версиями, основанная на трех числах: мажорной, минорной и патч-версии, которые указывают на уровень изменений в программе. Это помогает легче управлять зависимостями и обеспечивает прозрачность изменений в ПО.",
    videos: [
      {
        url: "https://youtu.be/Jmpft3r3E2E?t=2666",
        title: "Публичное собеседование: frontend-ра…",
        time: 2666,
      },
      {
        url: "https://youtu.be/5gplqEVgajc?t=1492",
        title: "Cобеседование Junior Frontend разраб…",
        time: 1492,
      },
      {
        url: "https://youtu.be/hDl7w9U-Ly8?t=210",
        title: "Собеседование на Junior Frontend раз…",
        time: 210,
      },
      {
        url: "https://youtu.be/gt-Glqr-1DM?t=1016",
        title: "Собеседование frontend junior+ разра…",
        time: 1016,
      },
      {
        url: "https://www.youtube.com/watch?v=qGdV5YOmtrs&t=3490s",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 3490,
      },
    ],
    rating: 16,
    image: null,
  },
  {
    id: 1651,
    question: "Что такое this",
    explanation:
      '`this`\nявляется ключевым словом, которое используется в функциях и методах и указывает на объект, в контексте которого они были вызваны.Его значение зависит от того, как именно вызывается функция, и может изменяться в различных контекстах выполнения.\nКонтексты использования:\n1.\nГлобальный контекст:\nглобальном контексте (вне каких-либо функций) он ссылается на глобальный объект. В браузере глобальным объектом является\nwindow\n, в Node.js —\nglobal\n.\nconsole.log(this === window); // в браузере вернет true\n2.\nФункции (не строгий режим):\nВ функциях, вызванных обычным способом (не как методы объекта), он ссылается на глобальный объект. В строгом режиме (\n`"use strict"`\n)\n`this`\nбудет\n`undefined`\n, если функция вызвана не как метод объекта.\nfunction show() {\n      console.log(this === window); // true в браузере в нестрогом режиме\n      console.log(this); // undefined в строгом режиме\n    }\n    show();\n3.\nМетоды объекта:\nКогда функция вызывается как метод объекта, он ссылается на объект, частью которого является метод.\nconst obj = {\n      myMethod() {\n        console.log(this);\n      }\n    };\n    obj.myMethod(); // this ссылается на obj\n4.\nКонструкторы:\nВ функции-конструкторе, вызванной с\n`new`\n, он ссылается на вновь созданный объект.\nfunction Person(name) {\n      this.name = name;\n    }\n    const person = new Person("Alice");\n    console.log(person.name); // Alice\n5.\nСтрелочные функции:\nСтрелочные функции не имеют собственного контекста, вместо этого они захватывают его из внешнего лексического окружения.\nconst obj = {\n      method: function() {\n        const arrowFunc = () => console.log(this);\n        arrowFunc(); // this ссылается на obj\n      }\n    };\n    obj.method();\n6.\nЯвное привязывание:\nС помощью методов\n`call`\n,\n`apply`\nи\n`bind`\nможно явно указать контекст для функции.\nfunction show() {\n      console.log(this);\n    }\n    const obj = {name: "Explicit context"};\n    show.call(obj); // this в show() ссылается на obj\nВажность понимания\n`this`\nПонимание механизма его работы важно для эффективного использования, особенно при работе с объектно-ориентированным кодом и при создании сложных веб-приложений, где часто требуется контролировать контекст выполнения функций и методов.',
    videos: [
      {
        url: "https://www.youtube.com/live/t52BuzKzqWw?feature=share&t=745",
        title: "Публичное собеседование: junior-fron…",
        time: 745,
      },
      {
        url: "https://www.youtube.com/live/fk_eTY2IZQE?feature=share&t=396",
        title: "Публичное собеседование: фронтендер …",
        time: 396,
      },
      {
        url: "https://youtu.be/BOCkaqdbdCg?t=1687",
        title: "Собеседование на Junior Frontend раз…",
        time: 1687,
      },
      {
        url: "https://youtu.be/DjY76sVa7xY?t=688",
        title: "Камбоджи. Техническое собеседование …",
        time: 688,
      },
      {
        url: "https://youtu.be/e2r3JAuMSSg?t=3767",
        title: "#1. Публичное собеседование JUNIOR F…",
        time: 3767,
      },
    ],
    rating: 16,
    image: null,
  },
  {
    id: 1653,
    question: "Какие технологии используете",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/JERUf-xKU1o?feature=share&t=2113",
        title: "Публичное собеседование #6: Дмитрий …",
        time: 2113,
      },
      {
        url: "https://youtu.be/9nBbRK-Gfjg?t=178",
        title: "Мок-интервью для джуна-фронтендера: …",
        time: 178,
      },
      {
        url: "https://youtu.be/HCXDrVikPGk?t=104",
        title: "Собеседование на Middle Frontend раз…",
        time: 104,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=172",
        title: "Собеседование cтажера Frontend разра…",
        time: 172,
      },
      {
        url: "https://youtu.be/DjY76sVa7xY?t=39",
        title: "Камбоджи. Техническое собеседование …",
        time: 39,
      },
    ],
    rating: 16,
    image: null,
  },
  {
    id: 1654,
    question: "Какими способами можно объявить переменные, назовите отличия",
    explanation:
      'Переменные можно объявить тремя основными способами: используя ключевые слова\n`var`\n,\n`let`\nи\n`const`\n. Рассмотрим каждый из них подробнее:\n1.\n`var`:\nОбласть видимости:\nИмеет функциональную область видимости, что означает, что переменная, объявленная с помощью нее внутри функции, доступна в любом месте этой функции. Если она объявлена вне функции, она становится глобальной.\nПоднятие (Hoisting):\nПеременные, объявленные через нее, поднимаются в начало функции или глобальной области видимости, но инициализация остаётся на своём месте. Это значит, что переменную можно использовать до её объявления в коде.\nПерезаписываемость:\nМожно повторно объявить и изменить переменную, используя ее.\n2.\n`let`:\nОбласть видимости:\nИмеет блочную область видимости, ограниченную фигурными скобками\n`{}`\n, в которых она была объявлена, например, внутри циклов, условий или блоков кода.\nПоднятие (Hoisting):\nПоднятие происходит, но в отличие от\n`var`\n, доступ к переменной до её объявления вызывает ошибку\n`ReferenceError`\n.\nПерезаписываемость:\nМожно изменить значение переменной, но нельзя повторно объявить её в той же области видимости.\n3.\n`const`:\nОбласть видимости:\nКак и\n`let`\n, имеет блочную область видимости.\nПоднятие (Hoisting):\nПоднимается так же, как и\n`let`\n, с теми же ограничениями доступа до объявления.\nПерезаписываемость:\nНельзя изменить значение. Однако, если переменная ссылается на объект или массив, то можно изменить содержимое объекта или массива, но не саму ссылку.\nНеобходима инициализация:\nПри объявлении переменной с `const` необходимо сразу же инициализировать её значением.\nПримеры:\n// Использование var\nvar x = 5;\nconsole.log(x); // 5\nvar x = 10; // Переопределение возможно\nconsole.log(x); // 10\n// Использование let\nlet y = "hello";\nconsole.log(y); // hello\ny = "world"; // Переопределение значения допустимо\nconsole.log(y); // world\n// let y = "test"; // Ошибка: Identifier \'y\' has already been declared\n// Использование const\nconst z = { message: "constant" };\nconsole.log(z.message); // constant\nz.message = "changed"; // Изменение свойства объекта допустимо\nconsole.log(z.message); // changed\n// const z = "new"; // Ошибка: Identifier \'z\' has already been declared\n`var`\nимеет функциональную область видимости, поднимается и позволяет переопределение переменных.\n`let`\nимеет блочную область видимости, поднимается с ограничением доступа до объявления и позволяет изменять значения, но не допускает повторное объявление в той же области видимости.\n`const`\nтакже имеет блочную область видимости, требует инициализации при объявлении, запрещает изменение присвоенного значения (хотя позволяет изменять содержимое объектов) и не допускает повторного объявления.',
    videos: [
      {
        url: "https://youtu.be/gV6eobXisYU?t=119",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 119,
      },
      {
        url: "https://youtu.be/gt-Glqr-1DM?t=1927",
        title: "Собеседование frontend junior+ разра…",
        time: 1927,
      },
      {
        url: "https://youtu.be/25lCunO6yDQ?t=2784",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 2784,
      },
      {
        url: "https://youtu.be/KvPUlwkSs_E?t=1150",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 1150,
      },
      {
        url: "https://youtu.be/IvJIuPkzEns?t=317",
        title: "Реальное Собеседование JavaScript Ра…",
        time: 317,
      },
    ],
    rating: 16,
    image: null,
  },
  {
    id: 1656,
    question: "Какие бывают хуки",
    explanation:
      "Хуки позволяют использовать состояние и другие возможности React без написания классов. С их появлением в версии 16.8, разработчики получили доступ к мощному и выразительному инструменту для создания компонентов. Рассмотрим основные примеры, а также некоторые дополнительные, которые предоставляет React.\nОсновные хуки:\n1.\nuseState\nПозволяет добавлять состояние к функциональным компонентам.\nПример:\nconst [count, setCount] = useState(0);\n2.\nuseEffect\nДаёт возможность выполнять побочные эффекты в компоненте, такие как обращения к API, подписки или таймеры.\nПример:\nuseEffect(() => {\n       document.title = `Вы нажали ${count} раз`;\n     }, [count]); // Зависимость от состояния count\n3.\nuseContext\nДаёт возможность получить текущее значение контекста, что упрощает доступ к данным в глубоко вложенных компонентах без их явной передачи через пропсы.\nПример:\nconst value = useContext(MyContext);\nДополнительные хуки:\n1.\nuseReducer\nАльтернатива\n`useState`\nдля более сложного управления состоянием, использует концепцию редьюсера для обработки сложных изменений состояния.\nПример:\nconst [state, dispatch] = useReducer(reducer, initialState);\n2.\nuseCallback\nВозвращает мемоизированный колбэк, который изменяется только если изменяются зависимости.\nПример:\nconst memoizedCallback = useCallback(() => {\n       doSomething(a, b);\n     }, [a, b]);\n3.\nuseMemo\nВозвращает мемоизированное значение, пересчитывается только при изменении зависимостей.\nПример:\nconst memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\n4.\nuseRef\nВозвращает изменяемый ref-объект, который можно использовать для доступа к DOM-элементам или хранения любого мутируемого значения.\nПример:\nconst myRef = useRef(initialValue);\n5.\nuseImperativeHandle\nИспользуется для передачи родительским компонентам инстанса значения из дочерних компонентов, обычно для управления фокусом, выделением текста или анимацией.\nПример:\nuseImperativeHandle(ref, () => ({\n       focus: () => {\n         myTextInput.current.focus();\n       }\n     }));\n6.\nuseLayoutEffect\nПохож на\n`useEffect`\n, но выполняется синхронно после всех изменений DOM. Используется для чтения макета из DOM и реагирования на эти изменения синхронно.\nПример:\nuseLayoutEffect(() => {\n       // Измерения или взаимодействия с DOM\n     }, [dependencies]);\n7.\nuseDebugValue\nМожет использоваться для отображения метки для пользовательских хуков в React DevTools.\nПример:\nuseDebugValue(value);\nОсновные хуки\n(\n`useState`\n,\n`useEffect`\n,\n`useContext`\n) позволяют добавлять состояние, работать с побочными эффектами и использовать контекст в функциональных компонентах\nДополнительные хуки\nпредоставляют более специализированные или углублённые возможности для оптимизации, работы с рефами, мемоизации и других задач, связанных с жизненным циклом компонентов и управлением рендерингом.",
    videos: [
      {
        url: "https://youtu.be/Y1SekvuZ3M4?t=1663",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 1663,
      },
      {
        url: "https://youtu.be/hDl7w9U-Ly8?t=1150",
        title: "Собеседование на Junior Frontend раз…",
        time: 1150,
      },
      {
        url: "https://youtu.be/gt-Glqr-1DM?t=5747",
        title: "Собеседование frontend junior+ разра…",
        time: 5747,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=3401",
        title: "Собеседование cтажера Frontend разра…",
        time: 3401,
      },
      {
        url: "https://youtu.be/e2r3JAuMSSg?t=4484",
        title: "#1. Публичное собеседование JUNIOR F…",
        time: 4484,
      },
    ],
    rating: 16,
    image: null,
  },
  {
    id: 1658,
    question: "Что такое мемоизация",
    explanation:
      "Меморизация — это оптимизационная техника, используемая для ускорения выполнения программ путём сохранения результатов дорогостоящих функций и повторного использования этих результатов, когда снова возникают одинаковые входные данные, вместо того чтобы повторно выполнять функцию.\nКак это работает\nПри первом вызове функции с определённым набором аргументов результат выполнения функции сохраняется в каком-либо хранилище (чаще всего в виде объекта или карты). При последующих вызовах функции с теми же аргументами, вместо выполнения функции, возвращается сохранённый результат. Это значительно сокращает время выполнения, особенно если исходная функция требует значительных вычислительных ресурсов.\nПрименение:\nМеморизация часто применяется для оптимизации производительности в различных областях, включая:\nРекурсивные вычисления, например, вычисление чисел Фибоначчи.\nДорогостоящие вычисления, которые часто повторяются с одними и теми же аргументами.\nОптимизация производительности веб-приложений, например, в React, где меморизация помогает избежать ненужных перерисовок компонентов.\nПримеры:\nПростой пример меморизации:\nfunction memoize(fn) {\n  const cache = {};\n  return function(...args) {\n    const key = args.toString();\n    if (cache[key]) {\n      return cache[key];\n    } else {\n      const result = fn.apply(this, args);\n      cache[key] = result;\n      return result;\n    }\n  };\n}\n// Пример использования меморизации для функции вычисления факториала\nconst factorial = memoize(function(n) {\n  if (n === 0) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n});\nconsole.log(factorial(5));  // Вычисляется и сохраняется в кэше\nconsole.log(factorial(5));  // Возвращается результат из кэша, вычислений не происходит\nМеморизация — это техника сохранения результатов выполнения функций для их быстрого повторного использования, что позволяет существенно ускорить выполнение программы, особенно при работе с дорогостоящими вычислениями или рекурсивными функциями. Это достигается за счёт того, что вместо повторного выполнения функции с теми же аргументами, результат возвращается из специального хранилища (кэша).",
    videos: [
      {
        url: "https://youtu.be/Y1SekvuZ3M4?t=1853",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 1853,
      },
      {
        url: "https://youtu.be/jf5TkGzWqiM?t=2184",
        title: "Собеседование JUNIOR FRONTEND REACT …",
        time: 2184,
      },
      {
        url: "https://youtu.be/YwRgLQ0SoKk?t=3757",
        title: "Собеседование frontend разработчика",
        time: 3757,
      },
      {
        url: "https://youtu.be/ElCvv0iFWq4?t=3661",
        title: "СОБЕСЕДОВАНИЕ Middle Frontend разраб…",
        time: 3661,
      },
      {
        url: "https://youtu.be/OzLjBPjsGgg?t=1937",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 1937,
      },
    ],
    rating: 16,
    image: null,
  },
  {
    id: 1659,
    question: "В чём отличие хранения данных в local storage от куки",
    explanation:
      "Хранение данных в Local Storage и использование куки (cookies) — это два различных способа сохранения информации на стороне клиента в веб-разработке. Каждый из них имеет свои особенности, преимущества и недостатки:\nLocal Storage\n1.\nОбъем данных:\nПредоставляет значительно больше пространства для хранения данных по сравнению с куки — до 5-10 МБ в зависимости от браузера.\n2.\nДоступность:\nДанные, сохраненные нем, доступны только на том же домене и не отправляются на сервер при каждом запросе, в отличие от куки.\n3.\nСрок хранения:\nДанные нем сохраняются бессрочно или до тех пор, пока не будут явно удалены кодом или пользователем через настройки браузера.\n4.\nБезопасность:\nТак как данные из него не отправляются на сервер с каждым запросом, риск перехвата этих данных ниже, чем у куки. Однако, поскольку данные доступны через JavaScript, Local Storage уязвим к XSS-атакам (межсайтовому скриптингу).\nКуки (Cookies)\n1.\nОбъем данных:\nОграничены размером, обычно максимум 4 КБ на одно куки.\n2.\nДоступность:\nОтправляются на сервер при каждом HTTP-запросе к домену, который их установил, что может быть полезно для аутентификации или отслеживания сессий пользователя.\n3.\nСрок хранения:\nСрок жизни куки может быть установлен при их создании. Если срок не установлен, куки считается сессионным и удаляется при закрытии браузера.\n4.\nБезопасность:\nКуки могут быть настроены как `\nHttpOnly`\n, что делает их недоступными и уменьшает риск XSS-атак. Также куки могут быть помечены как\n`Secure`\n, что означает их отправку только по защищенным соединениям (HTTPS).\nLocal Storage\nлучше подходит для хранения больших объемов данных, которые не требуется отправлять на сервер с каждым запросом. Это хороший выбор для сохранения настроек пользователя или данных форм на стороне клиента.\nКуки\nлучше использовать для управления сессиями пользователя или для хранения небольших объемов данных, которые должны быть доступны как на клиенте, так и на сервере. Куки также могут служить для реализации механизмов аутентификации и отслеживания состояния сессий.\nВыбор между Local Storage и куки зависит от конкретных требований приложения, включая необходимый объем хранения, требования к безопасности и необходимость обмена данными между клиентом и сервером.",
    videos: [
      {
        url: "https://youtu.be/jf5TkGzWqiM?t=246",
        title: "Собеседование JUNIOR FRONTEND REACT …",
        time: 246,
      },
      {
        url: "https://youtu.be/B1IbTKdgCeE?t=1080",
        title: "Крушитель алгоритмов? Собеседование …",
        time: 1080,
      },
      {
        url: "https://youtu.be/gt-Glqr-1DM?t=1095",
        title: "Собеседование frontend junior+ разра…",
        time: 1095,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=2536",
        title: "Собеседование cтажера Frontend разра…",
        time: 2536,
      },
      {
        url: "https://youtu.be/OzLjBPjsGgg?t=522",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 522,
      },
    ],
    rating: 16,
    image: null,
  },
  {
    id: 1660,
    question: "В чём разница между foreach и map",
    explanation:
      "`forEach`\nи\n`map`\n— это два метода массивов, предназначенные для итерации по элементам массива, но они используются в разных целях и работают по-разному.\nforEach\nНазначение:\nИспользуется для выполнения заданной функции один раз для каждого элемента в массиве. Основное назначение — выполнение побочных эффектов (например, вывод в консоль, запись в файл и т.д.).\nВозвращаемое значение:\nНе возвращает никакого значения (то есть возвращает\n`undefined`\n). Это означает, что результат его работы нельзя присвоить переменной.\nИзменение оригинального массива:\nМожет изменять оригинальный массив, если внутри функции-коллбэка производятся изменения его элементов.\nconst array1 = ['a', 'b', 'c'];\narray1.forEach(element => console.log(element));\n// Выводит каждый элемент в консоль\nmap\nНазначение:\nИспользуется для создания нового массива, заполненного результатами вызова предоставленной функции на каждом элементе исходного массива. Основное назначение — трансформация данных.\nВозвращаемое значение:\nВозвращает новый массив, который содержит результаты применения функции к каждому элементу исходного массива. Это позволяет использовать его в цепочках вызовов и присваивать результат его работы переменной.\nИзменение оригинального массива:\nНе изменяет оригинальный массив, что делает его предпочтительным в функциональном программировании.\nconst array2 = [1, 4, 9];\nconst map1 = array2.map(x => x * 2);\nconsole.log(map1);\n// Выводит новый массив [2, 8, 18]\nОсновные различия\nЦель использования: `forEach`\nдля выполнения операций или побочных эффектов на каждом элементе массива;\n`map`\nдля создания нового массива на основе обработки каждого элемента исходного массива.\nВозвращаемое значение: `forEach`\nвозвращает\n`undefined`\n, в то время как\n`map`\nвозвращает новый массив.\nИзменение исходного массива:\n`forEach`\nможет изменять исходный массив, если это предусмотрено логикой коллбэка;\n`map`\nне изменяет исходный массив, а создаёт новый.\n`forEach`\nиспользуется для выполнения функции на каждом элементе массива без создания нового массива. Он идеален для ситуаций, когда вам нужно применить какой-либо побочный эффект.\n`map`\n, в свою очередь, применяется для трансформации исходного массива в новый, без изменения исходного массива",
    videos: [
      {
        url: "https://youtu.be/PLwrvZahiO4?t=743",
        title: "Собеседование на JavaScript разработ…",
        time: 743,
      },
      {
        url: "https://youtu.be/ozvUaikP6cs?t=785",
        title: "#6 Как волноваться и не облажаться? …",
        time: 785,
      },
      {
        url: "https://youtu.be/wP7XVriACtA?t=1915",
        title: "Frontend Собеседование на Junior раз…",
        time: 1915,
      },
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=1671",
        title: "Первое интервью фронтендера самоучки…",
        time: 1671,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=1678",
        title: "Собеседование cтажера Frontend разра…",
        time: 1678,
      },
    ],
    rating: 16,
    image: null,
  },
  {
    id: 1661,
    question: "Что такое дженерик",
    explanation:
      'Дженерики (Generics) — это мощный инструмент, позволяющий создавать компоненты (как правило, функции, классы и интерфейсы), работающие с любым типом данных. Основная цель — обеспечение строгой типизации при работе с различными типами данных, не теряя при этом гибкости и переиспользуемости кода.\nКак это работает\nВместо указания конкретного типа данных при создании компонента, используется параметр типа — переменная, которая затем заменяется на реальный тип данных при использовании компонента. Это позволяет компоненту работать с различными типами данных без изменения его исходного кода.\nПреимущества дженериков\nБезопасность типов:\nПозволяют проверить тип данных на этапе компиляции, предотвращая возможные ошибки, связанные с неправильным использованием типов данных.\nПереиспользуемость кода:\nС помощью можно создать универсальные алгоритмы и структуры данных, работающие с любыми типами данных, что сокращает дублирование кода.\nЧитаемость кода:\nИспользование их делает код более понятным, поскольку намерения разработчика становятся очевидными благодаря явному указанию типов данных.\nПримеры:\nВ TypeScript\nВ нем дженерики активно используются для повышения безопасности типов.\nfunction identity<T>(arg: T): T {\n    return arg;\n}\nlet output1 = identity<string>("myString");  // тип T становится string\nlet output2 = identity<number>(100);  // тип T становится number\nВ Java\nТакже поддерживает дженерики, позволяя создавать классы, интерфейсы и методы с обобщенными типами.\npublic class Box<T> {\n    private T t;\n    public void set(T t) { this.t = t; }\n    public T get() { return t; }\n}\nBox<Integer> integerBox = new Box<>();\nДженерики — это концепция в программировании, позволяющая компонентам работать с разными типами данных, при этом сохраняя строгую типизацию. Это достигается за счет использования параметров типа, которые заменяются на конкретные типы данных при использовании компонента, улучшая тем самым безопасность, переиспользуемость и читаемость кода.',
    videos: [
      {
        url: "https://youtu.be/hDl7w9U-Ly8?t=982",
        title: "Собеседование на Junior Frontend раз…",
        time: 982,
      },
      {
        url: "https://youtu.be/VzorPrTjUII?t=2143",
        title: "Middle за год? Собеседование #3 fron…",
        time: 2143,
      },
      {
        url: "https://youtu.be/YwRgLQ0SoKk?t=4331",
        title: "Собеседование frontend разработчика",
        time: 4331,
      },
      {
        url: "https://youtu.be/ZEKcJgVI-YM?t=2670",
        title: "Талант в 18 лет? Собеседование #2 fr…",
        time: 2670,
      },
      {
        url: "https://youtu.be/OzLjBPjsGgg?t=3253",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 3253,
      },
    ],
    rating: 16,
    image: null,
  },
  {
    id: 1662,
    question: "Для чего нужен eventloop в js",
    explanation:
      "Event Loop (цикл событий) — это фундаментальная концепция, особенно в контексте JavaScript и его выполнения в браузере и Node.js. Основная его задача — обеспечить выполнение асинхронного кода, такого как обработка событий, выполнение обратных вызовов (callbacks) и промисов, не блокируя при этом выполнение остального кода.\nКак работает Event Loop\nJavaScript — это однопоточный язык программирования, что означает, что он может выполнять только одну операцию за раз. Однако, благодаря Event Loop, он способен обрабатывать асинхронные операции, такие как запросы к серверу, таймеры и взаимодействие с пользователем, не останавливая основной поток выполнения кода.\nПроцесс работы Event Loop включает в себя несколько ключевых компонентов:\n1.\nCall Stack (Стек вызовов):\nЗдесь хранятся все функции, которые нужно выполнить. Добавляет функции в стек вызовов и выполняет их по порядку, сначала завершая выполнение функций, которые находятся на вершине стека.\n2.\nCallback Queue (Очередь обратных вызовов):\nКогда асинхронная операция завершается (например, приходит ответ от сервера), соответствующий обратный вызов помещается в очередь обратных вызовов.\n3.\nEvent Loop:\nСледит за стеком вызовов и очередью обратных вызовов. Если стек вызовов пуст, он переносит первую функцию из очереди обратных вызовов в стек вызовов, чтобы она была выполнена.\nЗачем это нужно\nEvent Loop позволяет JavaScript быть асинхронным и неблокирующим, что критически важно для создания отзывчивых приложений. Без него асинхронные операции, такие как загрузка данных с сервера или ожидание завершения таймера, заблокировали бы выполнение всего скрипта, делая веб-страницы и приложения медленными и неотзывчивыми.\nПример:\nПредставьте, что вы пишете код, который запрашивает данные с сервера и затем обновляет веб-страницу этими данными. Без асинхронности и Event Loop вам пришлось бы ждать, пока не придет ответ от сервера, прежде чем пользователь сможет взаимодействовать со страницей. С ним пользователь может продолжать взаимодействовать со страницей, пока данные загружаются в фоновом режиме.\nEvent Loop обеспечивает асинхронное выполнение кода, позволяя приложениям оставаться отзывчивыми и эффективно обрабатывать длительные или отложенные операции, не блокируя при этом основной поток выполнения. Это достигается за счет циклического мониторинга стека вызовов и переноса обратных вызовов из очереди обратных вызовов в стек вызовов, когда это возможно.",
    videos: [
      {
        url: "https://youtu.be/VzorPrTjUII?t=278",
        title: "Middle за год? Собеседование #3 fron…",
        time: 278,
      },
      {
        url: "https://youtu.be/ZEKcJgVI-YM?t=647",
        title: "Талант в 18 лет? Собеседование #2 fr…",
        time: 647,
      },
      {
        url: "https://youtu.be/B1IbTKdgCeE?t=573",
        title: "Крушитель алгоритмов? Собеседование …",
        time: 573,
      },
      {
        url: "https://youtu.be/BsIcbU4LB0k?t=323",
        title: "ИНТЕРЕСНОЕ СОБЕСЕДОВАНИЕ JUNIOR Fron…",
        time: 323,
      },
      {
        url: "https://youtu.be/ScRTey_dvhI?t=2910",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 2910,
      },
    ],
    rating: 16,
    image: null,
  },
  {
    id: 1664,
    question: "Расскажи про области видимости",
    explanation:
      'Область видимости (Scope) в программировании определяет контекст выполнения кода, в котором переменные, функции и объекты доступны для использования. Области видимости играют ключевую роль в структуре и безопасности кода, позволяя разграничивать доступ к данным и избегать конфликтов имен.\nВиды областей видимости\n1.\nГлобальная область видимости:\nПеременные, объявленные вне всех функций или блоков кода, находятся в глобальной области видимости. Они доступны из любой части кода в том же контексте выполнения.\n2.\nЛокальная (или функциональная) область видимости:\nПеременные, объявленные внутри функции, доступны только в пределах этой функции и вложенных в неё функций.\n3.\nБлочная область видимости:\nВведена в ES6 с помощью ключевых слов\n`let`\nи\n`const`\n, позволяет ограничить область видимости переменной блоком кода (например, циклом или условным оператором).\nГлобальная область видимости:\nvar globalVar = "Я глобальная переменная";\nfunction exampleFunction() {\n  console.log(globalVar); // Доступ к глобальной переменной внутри функции\n}\nconsole.log(globalVar); // Доступ к глобальной переменной вне функции\nЛокальная область видимости:\nfunction exampleFunction() {\n  var localVar = "Я локальная переменная";\n  console.log(localVar); // Доступна только внутри функции\n}\nexampleFunction();\nconsole.log(localVar); // Ошибка: localVar не определена\nБлочная область видимости:\nif (true) {\n  let blockVar = "Я переменная блочной видимости";\n  console.log(blockVar); // Доступна только внутри блока\n}\nconsole.log(blockVar); // Ошибка: blockVar не определена\nЗамыкание — это функция, вместе со всеми переменными, которые ей доступны из своей области видимости, включая переменные из внешних областей видимости. Замыкания позволяют сохранять состояние внутри функции и обращаться к переменным из внешней области видимости даже после того, как функция была выполнена.\nfunction outerFunction() {\n  var outerVar = "Я внешняя переменная";\n  function innerFunction() {\n    console.log(outerVar); // Доступ к переменной из внешней области видимости\n  }\n  return innerFunction;\n}\nvar myFunction = outerFunction();\nmyFunction(); // Вывод: "Я внешняя переменная"\nОбласть видимости важна для структурирования и организации кода, она помогает избегать конфликтов имен и обеспечивает безопасность данных, ограничивая доступ к переменным из разных частей программы. Понимание областей видимости и замыканий жизненно важно для разработки надёжных и эффективных приложений.',
    videos: [
      {
        url: "https://youtu.be/xGyI3uOXRjY?t=1284",
        title: "Tech Interview Fest | Пробное собесе…",
        time: 1284,
      },
      {
        url: "https://youtu.be/d5weK2w1V4A?t=533",
        title: "Собеседование Junior Frontend разраб…",
        time: 533,
      },
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=1469",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 1469,
      },
      {
        url: "https://youtu.be/BOCkaqdbdCg?t=1860",
        title: "Собеседование на Junior Frontend раз…",
        time: 1860,
      },
    ],
    rating: 13,
    image: null,
  },
  {
    id: 1667,
    question: "С какими hook приходилось работать",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/xGyI3uOXRjY?t=2974",
        title: "Tech Interview Fest | Пробное собесе…",
        time: 2974,
      },
      {
        url: "https://www.youtube.com/live/Jmpft3r3E2E?feature=share&t=1400",
        title: "Публичное собеседование: frontend-ра…",
        time: 1400,
      },
      {
        url: "https://youtu.be/jf5TkGzWqiM?t=2142",
        title: "Собеседование JUNIOR FRONTEND REACT …",
        time: 2142,
      },
      {
        url: "https://youtu.be/YwRgLQ0SoKk?t=3524",
        title: "Собеседование frontend разработчика",
        time: 3524,
      },
    ],
    rating: 13,
    image: null,
  },
  {
    id: 1669,
    question: "Расскажи про свой опыт с react",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/qgdsHdkQYYQ?t=2898",
        title: "Публичное собеседование: Middle фрон…",
        time: 2898,
      },
      {
        url: "https://youtu.be/Jmpft3r3E2E?t=483",
        title: "Публичное собеседование: frontend-ра…",
        time: 483,
      },
      {
        url: "https://youtu.be/AWaL_1V9dEY?t=549",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 549,
      },
      {
        url: "https://youtu.be/gt-Glqr-1DM?t=5371",
        title: "Собеседование frontend junior+ разра…",
        time: 5371,
      },
    ],
    rating: 13,
    image: null,
  },
  {
    id: 1670,
    question: "Как делается http запрос",
    explanation:
      "HTTP-запросы — это основа взаимодействия, позволяющие клиентам (например, браузерам) общаться с серверами. Это происходит с использованием протокола HTTP (HyperText Transfer Protocol). Клиент отправляет его серверу, а сервер отвечает HTTP-ответом. Запросы могут быть сделаны для различных целей, включая получение данных (GET запрос), отправку данных для создания или обновления ресурсов (POST, PUT запросы), удаление ресурсов (DELETE запрос) и др.\nСтруктура HTTP-запроса\nСостоит из следующих частей:\n1.\nСтартовая строка (Start line):\nОпределяет метод запроса (например, GET, POST), URI (Uniform Resource Identifier) запрашиваемого ресурса и версию HTTP.\n2.\nЗаголовки (Headers):\nСодержат дополнительную информацию для сервера, например тип контента, который клиент может принимать (Accept), тип контента, который отправляется (Content-Type), параметры аутентификации и другие.\n3.\nПустая строка:\nРазделяет заголовки и тело запроса.\n4.\nТело запроса (Body) (необязательно):\nСодержит данные, отправляемые в запросе. Используется с методами POST, PUT и другими, но не с GET.\nСпособы отправки HTTP-запросов\nИспользование веб-браузера\nСамый простой способ его отправки — использование веб-браузера. Когда вы вводите URL в адресную строку и нажимаете Enter, браузер отправляет GET-запрос к серверу, запрашивая содержимое страницы.\nИспользование инструментов\ncURL:\nКомандная утилита для отправки запросов через терминал или командную строку.\ncurl -X GET \"http://example.com\"\nPostman:\nГрафический интерфейс пользователя (GUI) для отправки HTTP-запросов, удобный для тестирования API.\nHTTP клиенты в языках программирования:\nБольшинство языков программирования предоставляют библиотеки для работы с HTTP. Например, `fetch` в JavaScript, `requests` в Python, `HttpClient` в .NET.\nПример с использованием Fetch API\nfetch('http://example.com/movies.json')\n  .then(response => response.json())\n  .then(data => console.log(data))\n  .catch(error => console.error('Ошибка:', error));\nЭтот код отправляет GET-запрос к\n`http://example.com/movies.json`\n, преобразует ответ и выводит его в консоль.\nHTTP-запросы являются фундаментальной частью веб-разработки, позволяя клиентам и серверам обмениваться данными. Существует множество способов для выполнения HTTP-запросов, включая использование веб-браузеров, специализированных инструментов и программных библиотек в различных языках программирования. Важно понимать структуру запроса и правильно использовать методы HTTP для эффективного взаимодействия с веб-серверами.",
    videos: [
      {
        url: "https://www.youtube.com/live/JERUf-xKU1o?feature=share&t=2275",
        title: "Публичное собеседование #6: Дмитрий …",
        time: 2275,
      },
      {
        url: "https://youtu.be/gV6eobXisYU?t=1964",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 1964,
      },
      {
        url: "https://www.youtube.com/watch?v=BonLyarPpqE&t=743s",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 743,
      },
      {
        url: "https://www.youtube.com/watch?v=k0dAETyBPvU&t=2090s",
        title: "#8 Маркетолог ушел на фронт. Собесед…",
        time: 2090,
      },
    ],
    rating: 13,
    image: null,
  },
  {
    id: 1671,
    question: "Что нравится во frontend",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/fk_eTY2IZQE?feature=share&t=267",
        title: "Публичное собеседование: фронтендер …",
        time: 267,
      },
      {
        url: "https://youtu.be/NRufVTyELC4?t=2594",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 2594,
      },
      {
        url: "https://youtu.be/lq4eefCCuVo?t=400",
        title: "Реальное СОБЕСЕДОВАНИЕ на FRONTEND р…",
        time: 400,
      },
      {
        url: "https://youtu.be/ktdN2upYX1I?t=362",
        title: "Стать фронтендером после 30: из рабо…",
        time: 362,
      },
    ],
    rating: 13,
    image: null,
  },
  {
    id: 1673,
    question:
      "Расскажи про самую сложную задачу, с которой столкнулся во время работы над этим проектом",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/wGVdU1Jje2M?feature=share&t=694",
        title: "Frontend-разработчик: публичное собе…",
        time: 694,
      },
      {
        url: "https://youtu.be/9nBbRK-Gfjg?t=335",
        title: "Мок-интервью для джуна-фронтендера: …",
        time: 335,
      },
      {
        url: "https://youtu.be/5GkMyQAGLXg?t=1457",
        title: "Собеседование frontend-разработчика …",
        time: 1457,
      },
      {
        url: "https://youtu.be/ScRTey_dvhI?t=565",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 565,
      },
    ],
    rating: 13,
    image: null,
  },
  {
    id: 1674,
    question: "Как использовать useeffect",
    explanation:
      "`useEffect`\n— это хук, введённый в React 16.8, который позволяет выполнять побочные эффекты в функциональных компонентах. Побочные эффекты включают в себя операции, которые выходят за рамки возвращаемого результатом рендеринга, такие как работа с сетью (запросы к API), подписки, изменение документа и так далее. Он заменяет собой жизненные циклы классовых компонентов, такие как\n`componentDidMount`\n,\n`componentDidUpdate`\nи\n`componentWillUnmount`\n.\nСинтаксис:\nuseEffect(() => {\n  // Ваш код для побочного эффекта\n  return () => {\n    // Очистка (необязательно)\n  };\n}, [зависимости]);\nФункция побочного эффекта:\nЭто его основное тело, где вы помещаете код, который должен выполняться после каждого рендеринга (по умолчанию) или когда изменяются определённые зависимости.\nОчистка:\nФункция очистки выполняется перед тем, как компонент будет удалён, а также перед следующим выполнением эффекта. Это идеальное место для отмены подписок, таймеров и других ресурсов, чтобы избежать утечек памяти.\nМассив зависимостей:\nОпределяет, при изменении каких значений должен повторно выполняться эффект. Если массив пуст (`[]`), эффект выполнится один раз после первого рендеринга. Если массив не указан, эффект будет выполняться после каждого рендеринга.\nПримеры использования:\nЗапуск эффекта один раз\nЧтобы выполнить эффект один раз после первого рендеринга (аналог\n`componentDidMount`\nв классовых компонентах), используйте пустой массив зависимостей:\nuseEffect(() => {\n  // Код здесь будет выполнен один раз после инициализации компонента\n}, []);\nВыполнение при изменении зависимостей\nЧтобы выполнить эффект при изменении определённых значений:\nconst [count, setCount] = useState(0);\nuseEffect(() => {\n  // Код здесь будет выполнен каждый раз, когда изменяется значение count\n  document.title = `Вы нажали ${count} раз`;\n}, [count]); // Зависимости\nОчистка эффектаПример использования функции очистки:\nuseEffect(() => {\n  const timerID = setInterval(() => {\n    // Ваша логика здесь\n  }, 1000);\n  return () => {\n    clearInterval(timerID); // Очистка при размонтировании компонента\n  };\n}, []); // Эффект выполнится один раз\n`useEffect`\nпозволяет вам выполнять побочные эффекты в функциональных компонентах. Он может заменить собой несколько методов жизненного цикла классовых компонентов, предоставляя более унифицированный и удобный способ работы с побочными эффектами. Через массив зависимостей вы контролируете, как часто эффект должен выполняться, что делает ваш компонент более оптимизированным и предсказуемым.",
    videos: [
      {
        url: "https://youtu.be/U3-TSl4cRn0?t=2877",
        title: "Из питониста во фронтендеры: собесед…",
        time: 2877,
      },
      {
        url: "https://youtu.be/gV6eobXisYU?t=1398",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 1398,
      },
      {
        url: "https://youtu.be/BsIcbU4LB0k?t=4484",
        title: "ИНТЕРЕСНОЕ СОБЕСЕДОВАНИЕ JUNIOR Fron…",
        time: 4484,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=3090",
        title: "Собеседование cтажера Frontend разра…",
        time: 3090,
      },
    ],
    rating: 13,
    image: null,
  },
  {
    id: 1676,
    question: "Что такое семантика",
    explanation:
      "Семантика в контексте веб-разработки относится к использованию HTML-тегов в соответствии с их предназначением и значением. Это означает выбор подходящих тегов для разметки различных частей контента на веб-странице таким образом, чтобы они отражали его смысл и структуру. Такая разметка помогает не только людям, но и поисковым системам и другим машинным агентам понимать структуру и содержание веб-страницы, что влияет на доступность сайта и его поисковую оптимизацию (SEO).\nПримеры в HTML:\n`<article>`:\nДля независимого контента, который имеет смысл сам по себе (например, статья в блоге).\n`<aside>`:\nДля контента, слабо связанного с основным содержимым страницы (например, боковая панель).\n`<details>`:\nДля контента, который можно скрыть или показать по запросу пользователя.\n`<figcaption>`:\nДля подписи к изображению в элементе\n`<figure>`\n.\n`\n<figure>`:\nДля самостоятельных элементов, таких как изображения, диаграммы, коды, которые сопровождаются подписью.\n`<footer>`:\nДля нижнего колонтитула документа или раздела.\n`<header>`:\nДля верхнего колонтитула документа или раздела.\n`<main>`:\nДля основного содержимого документа.\n`<mark>`:\nДля выделения частей текста.\n`<nav>`:\nДля навигационных ссылок.\n`<section>`:\nДля разделов содержимого, которые связаны с определенной темой.\n`<summary>`:\nДля заголовка элемента\n`<details>`\n.\nЗначение семантики:\n1.\nДоступность:\nДелает веб-контент более доступным для людей с ограниченными возможностями, использующих вспомогательные технологии, такие как экранные читалки, поскольку эти технологии могут интерпретировать структуру и предоставлять контент в более понятной форме.\n2.\nSEO:\nПоисковые системы используют ее для лучшего понимания структуры и содержания веб-страницы, что может улучшить индексацию и ранжирование сайта.\n3.\nУлучшенная поддержка и разработка:\nДелает код более читаемым и легким для понимания, что облегчает сопровождение и дальнейшую разработку сайта.\nСемантика в веб-разметке означает использование элементов HTML в соответствии с их смыслом и назначением. Это способствует созданию более доступного, SEO-оптимизированного и легкого для поддержки веб-контента. Включение семантических элементов в разметку веб-страницы является лучшей практикой.",
    videos: [
      {
        url: "https://youtu.be/5gplqEVgajc?t=1484",
        title: "Cобеседование Junior Frontend разраб…",
        time: 1484,
      },
      {
        url: "https://youtu.be/PLwrvZahiO4?t=123",
        title: "Собеседование на JavaScript разработ…",
        time: 123,
      },
      {
        url: "https://youtu.be/hDl7w9U-Ly8?t=207",
        title: "Собеседование на Junior Frontend раз…",
        time: 207,
      },
      {
        url: "https://youtu.be/cebz6w8o-fU?t=569",
        title: "Public interview for Frontend/HTML/C…",
        time: 569,
      },
    ],
    rating: 13,
    image: null,
  },
  {
    id: 1677,
    question: "Что такое state manager и с какими приходилось работать",
    explanation:
      "State manager (менеджер состояний) — это инструмент или библиотека, который помогает управлять состоянием приложения. Состояние приложения может включать различные данные: от пользовательского ввода и временных данных до кэшированных страниц и аутентифицированного пользователя. Менеджер состояний помогает централизованно управлять этими данными, облегчая их передачу между компонентами, упрощая тестирование и повышая производительность приложения.\nЗачем нужен менеджер состояний?\n1.\nУпрощение доступа к данным:\nПредоставляют унифицированный интерфейс для доступа к данным из любого места в приложении.\n2.\nПовышение производительности:\nЭффективное управление состоянием может помочь избежать ненужных обновлений интерфейса и повысить производительность приложения.\n3.\nУлучшение масштабируемости:\nУпрощает масштабирование приложения и добавление новых функций.\n4.\nУпрощение отладки и тестирования:\nДелает приложение более предсказуемым, что упрощает отладку и тестирование.\nПримеры:\n1.\nRedux:\nОдна из самых популярных библиотек для управления состоянием в React-приложениях. Она предлагает однонаправленный поток данных, что делает изменения состояния предсказуемыми.\n2.\nVuex:\nБиблиотека для управления состоянием в Vue.js. Подобно Redux, она предлагает централизованное хранилище для всех компонентов приложения.\n3.\nMobX:\nАльтернатива Redux, которая использует наблюдаемые объекты для управления состоянием. Она предлагает более гибкий подход к управлению состоянием, автоматически отслеживая изменения.\n4.\nContext API и Hooks в React:\nНачиная с версии 16.8, React предоставляет встроенный механизм для управления состоянием без необходимости добавления внешних библиотек. Хотя для небольших или средних проектов это может быть достаточно, в больших приложениях может потребоваться более мощное решение вроде Redux.\nМенеджер состояний — это инструмент, который помогает управлять состоянием веб-приложения, обеспечивая эффективную передачу данных между компонентами, улучшая производительность и упрощая отладку и тестирование. В зависимости от технологического стека и требований проекта, разработчики могут выбирать из различных решений, таких как Redux, Vuex, MobX или использовать встроенные средства фреймворков, например, Context API.",
    videos: [
      {
        url: "https://youtu.be/P2x_lmvVOfE?t=2063",
        title: "Собеседование JUNIOR FRONTEND REACT …",
        time: 2063,
      },
      {
        url: "https://youtu.be/xGyI3uOXRjY?t=3271",
        title: "Tech Interview Fest | Пробное собесе…",
        time: 3271,
      },
      {
        url: "https://youtu.be/gV6eobXisYU?t=1495",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 1495,
      },
      {
        url: "https://youtu.be/hDl7w9U-Ly8?t=1518",
        title: "Собеседование на Junior Frontend раз…",
        time: 1518,
      },
    ],
    rating: 13,
    image: null,
  },
  {
    id: 1678,
    question: "Какие бывают значения у свойства position",
    explanation:
      'Свойство\n`position`\nопределяет, как элемент будет позиционироваться в документе. Есть несколько ключевых значений, которые можно присвоить этому свойству:\n1.\n`static`:\nЭто значение по умолчанию. Элементы с\n`position: static`\nрасполагаются в обычном потоке документа, и свойства\n`top`\n,\n`right`\n,\n`bottom`\n,\n`left`\nи\n`z-index`\nна них не влияют.\n2.\n`relative`:\nЭлемент позиционируется относительно его обычного положения в потоке документа. Указание\n`top`\n,\n`right`\n,\n`bottom`\nи\n`left`\nприведет к смещению элемента относительно того места, где он находился бы, если бы был\n`static`\n.  Элемент с\n`position: relative`\nостается в нормальном потоке документа и может смещаться от своей обычной позиции.\n3.\n`absolute`:\nЭлемент удаляется из обычного потока документа, и его позиция определяется относительно его ближайшего позиционированного (не\n`static`\n) предка, если таковой имеется; в противном случае относительно начальной контейнерной области. Свойства\n`top`\n,\n`right`\n,\n`bottom`\nи\n`left`\nопределяют его точное положение.\n4.\n`fixed`:\nЭлемент удаляется из обычного потока документа и позиционируется относительно окна браузера. Он остается на том же месте даже при прокрутке страницы. Свойства\n`top`\n,\n`right`\n,\n`bottom`\nи\n`left`\nтакже определяют его позицию.\n5.\n`sticky`:\nЭлемент является гибридом между\n`relative`\nи\n`fixed`\n. Он ведет себя как\n`relative`\nдо тех пор, пока элемент не достигнет определенной точки при прокрутке страницы, после чего он становится "застрявшим" и ведет себя как\n`fixed`\n, пока не будет достигнута противоположная граница его контейнера.\nКаждое из этих значений позволяет разработчику точно управлять расположением элементов на странице, делая возможным создание сложных макетов и интерактивных интерфейсов. Выбор конкретного значения `position` зависит от задачи, которую нужно решить, и желаемого визуального эффекта.',
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=161",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 161,
      },
      {
        url: "https://youtu.be/gV6eobXisYU?t=876",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 876,
      },
      {
        url: "https://youtu.be/ZEKcJgVI-YM?t=2423",
        title: "Талант в 18 лет? Собеседование #2 fr…",
        time: 2423,
      },
      {
        url: "https://youtu.be/IvJIuPkzEns?t=281",
        title: "Реальное Собеседование JavaScript Ра…",
        time: 281,
      },
    ],
    rating: 13,
    image: null,
  },
  {
    id: 1680,
    question: "Какой стек использовал",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/NRufVTyELC4?t=418",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 418,
      },
      {
        url: "https://youtu.be/2zVAkqcUI4o?t=44",
        title: "СОБЕСЕДОВАНИЕ Middle FRONTEND разраб…",
        time: 44,
      },
      {
        url: "https://youtu.be/BsIcbU4LB0k?t=57",
        title: "ИНТЕРЕСНОЕ СОБЕСЕДОВАНИЕ JUNIOR Fron…",
        time: 57,
      },
      {
        url: "https://youtu.be/9sZCii1DHOM?t=37",
        title: "Публичное собеседование #4: JavaScri…",
        time: 37,
      },
    ],
    rating: 13,
    image: null,
  },
  {
    id: 1682,
    question: "Расскажите про свой опыт работы в команде",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/AWaL_1V9dEY?t=1148",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 1148,
      },
      {
        url: "https://www.youtube.com/watch?v=EaTZXKlpsj0&t=500s",
        title: "#11 Фронтендер в 17 лет? Собеседован…",
        time: 500,
      },
      {
        url: "https://youtu.be/BOCkaqdbdCg?t=365",
        title: "Собеседование на Junior Frontend раз…",
        time: 365,
      },
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=303",
        title: "Первое интервью фронтендера самоучки…",
        time: 303,
      },
    ],
    rating: 13,
    image: null,
  },
  {
    id: 1684,
    question: "Что такое двустороннее связывание",
    explanation:
      'Двустороннее связывание данных (Two-way data binding) — это паттерн проектирования, используемый в разработке пользовательских интерфейсов, при котором пользовательский интерфейс автоматически обновляется при изменении данных, и наоборот, данные автоматически изменяются при модификации пользовательским интерфейсом. Это означает, что модель и представление (view) синхронизированы в реальном времени: изменение в модели немедленно отражается в представлении, и любое изменение в представлении немедленно обновляет модель.\nКак это работает\nУ вас есть текстовое поле в форме (представление) и переменная (модель), которая хранит значение этого текстового поля. С двусторонним связыванием, если пользователь изменяет значение в текстовом поле, переменная в модели будет автоматически обновлена соответствующим образом. Аналогично, если переменная изменяется программно (например, в результате какой-то логики приложения), изменение отразится в текстовом поле.\nПримеры использования\nОно широко используется в фреймворках и платформах для разработки одностраничных приложений (SPA), таких как Angular. В Angular, например, это достигается с помощью директивы\n`[(ngModel)]`\n, которая связывает значение HTML элемента формы (например,\n`<input>`\n) с свойством компонента.\n<input [(ngModel)]="user.name">\nВ этом примере,\n`user.name`\n— это свойство компонента, которое связано с текстовым полем. Любое изменение в поле ввода немедленно обновит\n`user.name`\n, и любое изменение `user.name` будет немедленно отражено в поле ввода.\nПреимущества и недостатки\nПреимущества:\nУпрощение разработки, поскольку не нужно вручную обновлять представление или модель при изменении другой части.\nУлучшение пользовательского опыта, обеспечивая немедленное отображение изменений без дополнительных действий пользователя или дополнительного кода.\nНедостатки:\nСложность отладки, поскольку автоматическое обновление значений в обе стороны может привести к неожиданным эффектам и затруднить трассировку потока данных.\nПроизводительность, особенно в больших и сложных приложениях, где непрерывная синхронизация данных между моделью и представлением может повлиять на быстродействие.\nДвустороннее связывание данных — это мощный инструмент в руках разработчика, позволяющий создавать интерактивные и реактивные пользовательские интерфейсы, но его использование требует понимания возможных компромиссов между удобством разработки и производительностью приложения.',
    videos: [
      {
        url: "https://youtu.be/umHjpWydn8I?t=14",
        title: "50 вопросов на Vue JS собеседование",
        time: 14,
      },
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=5130s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 5130,
      },
      {
        url: "https://www.youtube.com/watch?v=qGdV5YOmtrs&t=6278s",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 6278,
      },
      {
        url: "https://www.youtube.com/watch?v=qika0TkDFz4&t=770s",
        title: "#7 Первое собеседование Junior Front…",
        time: 770,
      },
    ],
    rating: 13,
    image: null,
  },
  {
    id: 1687,
    question: "В чём разница между let и const",
    explanation:
      "`let`\nи\n`const`\nявляются двумя ключевыми словами, используемыми для объявления переменных, но с важными различиями в их использовании и поведении.\nОсновные различия:\n1.\nОбласть видимости:\nИ\n`let`\n, и\n`const`\nимеют блочную область видимости, что означает, что переменная, объявленная внутри блока\n`{}`\n, будет доступна только внутри этого блока. Это отличает их от\n`var`\n, который имеет функциональную область видимости.\n2.\nПереназначение:\nПеременные, объявленные с помощью\n`let\n`, могут быть переназначены, т.е. им можно присвоить новое значение после их объявления. В отличие от этого, переменные, объявленные с помощью\n`const`\n, должны быть инициализированы при объявлении, и их значение не может быть изменено позже, то есть они константы.\nПример использования\n`let`\n:\nlet a = 10;\nconsole.log(a); // Вывод: 10\na = 20;\nconsole.log(a); // Вывод: 20\nВ этом примере переменная\n`a`\n, объявленная с помощью\n`let`\n, сначала инициализируется значением 10, а затем ей присваивается новое значение 20.\nПример использования\n`const`\n:\nconst b = 10;\nconsole.log(b); // Вывод: 10\n// b = 20; // Это вызовет ошибку, потому что b объявлена с помощью const и не может быть переназначена.\nВ этом примере переменная\n`b`\n, объявленная с помощью\n`const`\n, инициализируется значением 10, и попытка изменить это значение приведет к ошибке.\nПочему это важно?\nИспользование\n`let`\nи\n`const`\nвместо\n`var`\nпредоставляет более строгий и понятный контроль над областями видимости переменных, что уменьшает вероятность ошибок из-за непреднамеренного доступа или изменения данных.\n`const`\nособенно полезен для объявления значений, которые не должны изменяться после инициализации, что делает код более безопасным и предсказуемым.\n`let`\nпозволяет объявлять переменные, которые могут быть переназначены, а\n`const`\nиспользуется для объявления констант, значения которых не могут быть изменены после инициализации. Оба они имеют блочную область видимости и предлагают более строгий контроль над переменными по сравнению с\n`var`\n.\nДругими словами, используйте\n`let`\nдля переменных, значение которых может измениться, и\n`const`\nдля переменных, значение которых останется неизменным.",
    videos: [
      {
        url: "https://youtu.be/PLwrvZahiO4?t=587",
        title: "Собеседование на JavaScript разработ…",
        time: 587,
      },
      {
        url: "https://youtu.be/d5weK2w1V4A?t=384",
        title: "Собеседование Junior Frontend разраб…",
        time: 384,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=574",
        title: "Собеседование cтажера Frontend разра…",
        time: 574,
      },
      {
        url: "https://youtu.be/OzLjBPjsGgg?t=1195",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 1195,
      },
    ],
    rating: 13,
    image: null,
  },
  {
    id: 1689,
    question: "Какие методы массивов знаешь",
    explanation:
      "Массивы являются одними из наиболее важных и часто используемых типов данных, и они имеют множество методов для выполнения различных операций, таких как итерация, преобразование, сортировка, поиск и т.д. Вот некоторые из наиболее часто используемых методов массивов:\nИтерация\nforEach():\nВыполняет заданную функцию один раз для каждого элемента в массиве.\nПреобразование\nmap():\nСоздаёт новый массив с результатом вызова указанной функции для каждого элемента массива.\nfilter():\nСоздаёт новый массив со всеми элементами, прошедшими проверку, заданной в передаваемой функции.\nreduce():\nПрименяет функцию к аккумулятору и каждому значению массива (слева-направо), сводя его к одному значению.\nreduceRight():\nАналогично методу\n`reduce`\n, но проходит по массиву справа налево.\nПоиск\nfind():\nВозвращает значение первого элемента в массиве, который удовлетворяет предоставленной функции проверки.\nfindIndex():\nВозвращает индекс первого элемента в массиве, который удовлетворяет предоставленной функции проверки.\nindexOf():\nВозвращает первый индекс, по которому данный элемент может быть найден в массиве, или -1, если такого индекса нет.\nlastIndexOf():\nВозвращает последний индекс, по которому данный элемент может быть найден в массиве, или -1, если такого индекса нет.\nДобавление/Удаление элементов\npush():\nДобавляет один или более элементов в конец массива и возвращает новую длину массива\npop():\nУдаляет последний элемент из массива и возвращает его значение..\nshif\nt():\nУдаляет первый элемент из массива и возвращает его значение.\nunshift():\nДобавляет один или более элементов в начало массива и возвращает новую длину массива.\nСортировка\nsort():\nСортирует элементы массива на месте и возвращает отсортированный массив.\nreverse():\nИнвертирует порядок элементов в массиве на месте.\nСрез и соединение\nslice():\nВозвращает поверхностную копию части массива в новый массив.\nconcat():\nОбъединяет два или более массивов/значений и возвращает новый массив.\nПреобразование массива\njoin():\nОбъединяет все элементы массива (или массивоподобного объекта) в строку.\nЭто лишь основные методы, доступные для работы с массивами. Каждый из них имеет свои особенности и случаи использования. Например,\n`map`\nможет использоваться для преобразования элементов массива,\n`filter`\nдля выборки подмножества элементов по определённому критерию, а\n`reduce`\nдля свёртки массива в одно значение.\nИспользование этих методов облегчает манипуляцию данными и делает код более читаемым и эффективным.\nМетоды массивов предоставляют мощные инструменты для обработки и манипуляции массивами данных, включая итерацию, поиск, сортировку, преобразование и многое другое. Знание и понимание этих методов является ключевым для эффективной работы с массивами.",
    videos: [
      {
        url: "https://youtu.be/PLwrvZahiO4?t=720",
        title: "Собеседование на JavaScript разработ…",
        time: 720,
      },
      {
        url: "https://youtu.be/BsIcbU4LB0k?t=2685",
        title: "ИНТЕРЕСНОЕ СОБЕСЕДОВАНИЕ JUNIOR Fron…",
        time: 2685,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=1661",
        title: "Собеседование cтажера Frontend разра…",
        time: 1661,
      },
      {
        url: "https://youtu.be/e2r3JAuMSSg?t=5541",
        title: "#1. Публичное собеседование JUNIOR F…",
        time: 5541,
      },
    ],
    rating: 13,
    image: null,
  },
  {
    id: 1692,
    question: "Сколько лет опыта у вас",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/MHrKcnyN46M?t=24",
        title: "СОБЕСЕДОВАНИЕ НА FRONTEND РАЗРАБОТЧИ…",
        time: 24,
      },
      {
        url: "https://youtu.be/ScRTey_dvhI?t=325",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 325,
      },
      {
        url: "https://youtu.be/A09lkkNMtTg?t=752",
        title: "[HR] Яна Гузнаева. Tripster на позиц…",
        time: 752,
      },
      {
        url: "https://youtu.be/0fI5sTI5uck?t=321",
        title: "Собеседование в Яндексе - Разработчи…",
        time: 321,
      },
    ],
    rating: 13,
    image: null,
  },
  {
    id: 1694,
    question: "Расскажи про свои пет-проекты",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/gt-Glqr-1DM?t=16",
        title: "Собеседование frontend junior+ разра…",
        time: 16,
      },
      {
        url: "https://youtu.be/cRqBsepPgoI?t=42",
        title: "Собеседование frontend junior+ разра…",
        time: 42,
      },
      {
        url: "https://www.youtube.com/watch?v=lrdaRbJctaA&t=4992s",
        title: "Frontend интервью. Ильнура, первая р…",
        time: 4992,
      },
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=5197",
        title: "Первое интервью фронтендера самоучки…",
        time: 5197,
      },
    ],
    rating: 13,
    image: null,
  },
  {
    id: 1696,
    question: "Что такое прототипы",
    explanation:
      "Прототипы — это механизм, с помощью которого объекты наследуют свойства и методы от другого объекта. Это основной способ реализации наследования и повторного использования кода. Они являются частью прототипного наследования, которое отличается от классического наследования.\nКаждый объект имеет внутреннее и неизменяемое свойство, известное как\n`[[Prototype]]`\n, которое может быть ссылкой на другой объект. Этот объект, на который он ссылается, называется \"прототипом\". Когда вы пытаетесь получить доступ к свойству или методу объекта, и это свойство или метод не найдены в самом объекте, JavaScript автоматически ищет это свойство или метод в его прототипе. Этот процесс продолжается рекурсивно вверх по цепочке прототипов, пока свойство или метод не будут найдены или не будет достигнут конец цепочки прототипов.\nСоздание и использование прототипов\nМожно задать или изменить с помощью\n`Object.create()`\n,\n`Object.setPrototypeOf()`\n, или просто установив свойство\n`__proto__`\n(хотя последний способ не рекомендуется к использованию из-за вопросов производительности и совместимости).\nПример:\nconst animal = {\n  type: 'Animal',\n  describe() {\n    return `Это ${this.type}`;\n  }\n};\nconst dog = Object.create(animal);\ndog.type = 'Собака';\nconsole.log(dog.describe()); // Это Собака\nВ этом примере объект\n`dog`\nнаследует метод\n`describe`\nот объекта\n`animal`\nчерез прототипную цепочку.\nЗначение `this`\nВажно отметить, что когда метод наследуется и вызывается на объекте-потомке, ключевое слово\n`this`\nвнутри метода ссылается на объект-потомок, а не на объект-прототип, в котором метод был определен.\nПрототипы — это механизм, который позволяет объектам наследовать свойства и методы от других объектов. Это основа для реализации наследования и повторного использования кода в языке. Прототипы играют ключевую роль в структуре и поведении объектов, позволяя создавать более модульный и поддерживаемый код.\nДругими словами, прототипы позволяют объектам \"наследовать\" свойства и методы от других объектов, облегчая повторное использование кода и организацию структуры программ.",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=ozvUaikP6cs&t=3820s",
        title: "#6 Как волноваться и не облажаться? …",
        time: 3820,
      },
      {
        url: "https://youtu.be/BonLyarPpqE?t=2978",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 2978,
      },
      {
        url: "https://youtu.be/qGdV5YOmtrs?t=616",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 616,
      },
      {
        url: "https://youtu.be/0fI5sTI5uck?t=1435",
        title: "Собеседование в Яндексе - Разработчи…",
        time: 1435,
      },
    ],
    rating: 13,
    image: null,
  },
  {
    id: 1699,
    question: "Что такое контекст в функции",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/d5weK2w1V4A?t=1807",
        title: "Собеседование Junior Frontend разраб…",
        time: 1807,
      },
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=1161",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 1161,
      },
      {
        url: "https://youtu.be/1Ej0Wx2TkSs?t=4946",
        title: "#16 Собеседование Senior Frontend ра…",
        time: 4946,
      },
      {
        url: "https://www.youtube.com/watch?v=3D0IVhYzXJM&t=580s",
        title: "#2 Собеседование смелого Frontend Mi…",
        time: 580,
      },
    ],
    rating: 13,
    image: null,
  },
  {
    id: 1701,
    question: "Почему пришёл в it",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/N1gKaF6BhDc?t=185",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 185,
      },
      {
        url: "https://youtu.be/NpQFVZoy4T8?t=6125",
        title: "FRONTEND СОБЕСЕДОВАНИЕ С БЫВШИМ РУКО…",
        time: 6125,
      },
      {
        url: "https://youtu.be/gt-Glqr-1DM?t=19",
        title: "Собеседование frontend junior+ разра…",
        time: 19,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1702,
    question: "Что такое контекст в javasript",
    explanation:
      "Контекст выполнения (Execution Context) относится к окружению, в котором выполняется текущий код. Он содержит информацию о том, где и как выполняется код, включая значения переменных и\n`this`\n. Однако, когда говорят о нем в более узком смысле, чаще всего имеют в виду контекст\n`this`\n.\n`this`\nКлючевое слово ссылается на объект, в контексте которого выполняется текущий код. Значение его зависит от того, как вызывается функция:\n1.\nВ глобальном контексте выполнения\n(вне любых функций), он ссылается на глобальный объект. В браузере глобальным объектом является\n`window`\n.\n2.\nВнутри функции\n, вызванной как обычная функция (например,\n`myFunction()`\n), он ссылается на глобальный объект в нестрогом режиме и на\n`undefined`\nв строгом режиме (\n`'use strict';`\n).\n3.\nВ методе объекта\nОн ссылается на объект, к которому принадлежит метод.\n4.\nВ конструкторе\n(функции, вызванной с ключевым словом\n`new`\n), он ссылается на вновь созданный объект.\n5.\nЧерез методы `call`, `apply` и `bind`\nможно явно задать данное значение для вызова функции.\nПримеры:\nfunction show() {\n  console.log(this);\n}\nconst obj = {\n  show: function() {\n    console.log(this);\n  }\n};\nshow(); // В глобальном контексте, this будет глобальным объектом или undefined в строгом режиме\nobj.show(); // В контексте объекта, this будет ссылаться на obj\nfunction Person(name) {\n  this.name = name;\n}\nconst person = new Person('Alice'); // Здесь this внутри Person будет ссылаться на новый объект person\nconst externalShow = show.bind(obj);\nexternalShow(); // this будет ссылаться на obj благодаря bind\nЗачем нужен контекст `this`\nПозволяет функциям иметь доступ к текущему объекту и взаимодействовать с его свойствами и методами, делая код более гибким и повторно используемым. Например, одна и та же функция может работать с данными разных объектов, в зависимости от того, в контексте какого объекта она была вызвана.\nПонимание работы контекста `this` является ключевым для глубокого понимания языка и эффективной разработки, особенно при работе с объектно-ориентированным кодом и функциями обратного вызова.",
    videos: [
      {
        url: "https://youtu.be/N1gKaF6BhDc?t=1175",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 1175,
      },
      {
        url: "https://youtu.be/B1IbTKdgCeE?t=474",
        title: "Крушитель алгоритмов? Собеседование …",
        time: 474,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=916",
        title: "Собеседование cтажера Frontend разра…",
        time: 916,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1703,
    question: "Для чего замыкание нужно",
    explanation:
      "Замыкание — это мощная концепция, которая позволяет функции запоминать и доступ к переменным из своей области видимости в момент создания, даже после того как исполнение функции, создавшей эти переменные, было завершено. Это одно из ключевых понятий, обеспечивающее множество возможностей для эффективной работы с данными и создания функций.\nДля чего нужны замыкания:\n1.\nИнкапсуляция данных:\nПозволяют скрыть переменные внутри функции, делая их недоступными снаружи, кроме как через определённые предоставленные функции. Это форма инкапсуляции данных, которая помогает избежать загрязнения глобальной области видимости и случайного изменения данных.\n2.\nСоздание приватных переменных:\nДо введения классов с модификаторами доступа (private поля в классах, предложенные в ES2020) замыкания были основным способом создания приватных переменных для объектов и функций.\n3.\nФабрики функций:\nПозволяют создавать функции, которые могут генерировать другие функции, уже с предустановленными параметрами или конфигурациями. Это полезно для настройки поведения функций в зависимости от контекста.\n4.\nМодульность и управление состоянием:\nОбеспечивают механизм для создания модулей и библиотек, позволяя определить приватные переменные и функции, которые недоступны извне, и предоставить публичное API через возвращаемые функции.\n5.\nКаррирование и частичное применение функций:\nИспользуются для реализации каррирования и частичного применения функций, когда функция принимает несколько аргументов, один или несколько из которых уже предустановлены.\nПример:\nfunction createCounter() {\n  let count = 0; // Приватная переменная, доступная только внутри createCounter\n  return function() {\n    count += 1;\n    return count;\n  };\n}\nconst counter = createCounter(); // counter — это функция, замыкающая в себе переменную count\nconsole.log(counter()); // 1\nconsole.log(counter()); // 2\n// Переменная count остается доступной для counter(), но недоступна напрямую извне\nВ этом примере\n`createCounter`\nсоздает и возвращает функцию, которая увеличивает и возвращает переменную `count` при каждом вызове. Переменная `count` инкапсулирована внутри замыкания и не доступна для прямого доступа или изменения извне, что демонстрирует как инкапсуляцию, так и управление состоянием через замыкание.\nЗамыкания предоставляют мощный инструмент для инкапсуляции данных, создания приватных переменных, управления состоянием и реализации различных программных паттернов, что делает их неотъемлемой частью разработки.",
    videos: [
      {
        url: "https://youtu.be/N1gKaF6BhDc?t=1481",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 1481,
      },
      {
        url: "https://www.youtube.com/live/t52BuzKzqWw?feature=share&t=959",
        title: "Публичное собеседование: junior-fron…",
        time: 959,
      },
      {
        url: "https://www.youtube.com/live/fk_eTY2IZQE?feature=share&t=519",
        title: "Публичное собеседование: фронтендер …",
        time: 519,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1704,
    question: "Расскажи про async await",
    explanation:
      "`async`\n/\n`await`\n— это синтаксический сахар для работы с асинхронными операциями, делающий код, работающий с асинхронными действиями, такими как запросы к серверу или чтение файлов, более читаемым и легким для понимания. Этот синтаксис был введен в ES2017 (ES8) и строится на промисах (Promises).\nКлючевое слово `async`\nИспользуется перед объявлением функции. Это позволяет функции автоматически возвращать промис. Если эта функция возвращает не промис, то возвращаемое значение будет автоматически обернуто в промис.\nasync function fetchData() {\n  return 'данные';\n}\nfetchData().then(data => console.log(data)); // выводит \"данные\"\nКлючевое слово `await`\nИспользуется для ожидания результата промиса внутри асинхронной функции\n`async`\n. Оно приостанавливает выполнение асинхронной функции до тех пор, пока промис не выполнится (т.е. не будет разрешен или отклонен). ЕЕ можно использовать только внутри асинхронных функций.\nasync function fetchData() {\n  let data = await fetch('https://api.example.com/data');\n  let json = await data.json();\n  return json;\n}\nВ этом примере функция\n`fetchData`\nсначала ожидает завершения HTTP-запроса к серверу, а затем ожидает завершения преобразования ответа в формат JSON. Весь этот процесс асинхронный, но благодаря\n`await`\nкод выглядит как синхронный.\nПреимущества использования:\nУлучшение читаемости кода:\nАсинхронный код, написанный с использованием\n`async`\n/\n`await`\n, выглядит более структурированным и похожим на синхронный код, что упрощает его понимание.\nУпрощение обработки ошибок:\nВ асинхронных функциях с `await` можно использовать стандартный синтаксис\n`try`\n/\n`catch`\nдля обработки ошибок, что делает код единообразнее.\nИзбегание \"callback hell\":\nИспользование\n`async`\n/\n`await`\nпозволяет избежать сложностей с вложенными коллбэками, которые могут возникнуть при использовании промисов или старого стиля асинхронного кода с коллбэками.\nВажно помнить\n`await`\nприостанавливает выполнение только текущей асинхронной функции, не блокируя выполнение другого кода.\n`await`\nможет использоваться только внутри функций, объявленных с\n`async`\n.\nВнутри асинхронных функций\n`async`\nможно использовать множество операторов\n`await`\nдля последовательного выполнения зависимых друг от друга асинхронных операций.\n`async`\n/\n`await`\nсделал написание асинхронного кода более интуитивно понятным и удобным, существенно улучшив разработку асинхронных приложений.",
    videos: [
      {
        url: "https://youtu.be/xGyI3uOXRjY?t=2222",
        title: "Tech Interview Fest | Пробное собесе…",
        time: 2222,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=2334",
        title: "Собеседование cтажера Frontend разра…",
        time: 2334,
      },
      {
        url: "https://youtu.be/KvPUlwkSs_E?t=948",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 948,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1707,
    question: "Зачем используют vuex",
    explanation:
      "Vuex — это библиотека управления состоянием для приложений, предназначенная для централизованного хранения всех данных, используемых в приложении. В больших и сложных приложениях, где множество компонентов нуждаются в доступе к общим данным и должны реагировать на их изменения в реальном времени, простого пропс-дренажа (props drilling) и событийного взаимодействия недостаточно для эффективного управления состоянием. Вот основные причины использования Vuex в таких случаях:\nЦентрализованное управление состоянием\nПредоставляет единое глобальное хранилище для всех компонентов приложения, что облегчает отслеживание и управление состоянием приложения, делая данные доступными для всех компонентов независимо от их места в иерархии.\nРеактивность\nСостояние, хранящееся в нем, реактивно. Это означает, что он автоматически отслеживает его изменения и обновляет представление, когда состояние изменяется. Это делает разработку интерактивных интерфейсов более интуитивно понятной и менее подверженной ошибкам.\nУдобство отладки и разработки\nПоддерживает инструменты, такие как [Vue Devtools](\nhttps://devtools.vuejs.org/\n), позволяя отслеживать, как и когда изменяется состояние приложения. Это значительно упрощает отладку и позволяет лучше понять поток данных в приложении.\nПоддержка масштабируемости\nПриложения, разработанные с его использованием, легче масштабировать благодаря структурированной и предсказуемой организации кода. Разделение логики управления состоянием на действия, мутации и геттеры делает код более организованным и понятным.\nУпрощение управления сложными взаимодействиями\nУпрощает управление сложными взаимодействиями и потоками данных между компонентами, например, при выполнении асинхронных операций, таких как запросы к серверу, и последующем обновлении состояния в зависимости от ответа.\nПример:\n// Создание хранилища Vuex\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment(state) {\n      state.count++;\n    }\n  }\n});\n// Использование хранилища в компоненте Vue\nnew Vue({\n  el: '#app',\n  computed: {\n    count() {\n      return store.state.count;\n    }\n  },\n  methods: {\n    increment() {\n      store.commit('increment');\n    }\n  }\n});\nЭтот простой пример демонстрирует, как Vuex может быть использован для централизованного управления состоянием и его изменениями.\nИспользование Vuex целесообразно в сложных приложениях, где требуется эффективное управление и обмен данными между компонентами. Оно обеспечивает реактивность, удобство отладки, масштабируемость и структурированность, делая управление состоянием приложения более организованным и удобным.",
    videos: [
      {
        url: "https://youtu.be/PgQ4Bn8g4Fg?t=2398",
        title: "Публичное собеседование: Frontend-ра…",
        time: 2398,
      },
      {
        url: "https://youtu.be/umHjpWydn8I?t=2268",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 2268,
      },
      {
        url: "https://youtu.be/umHjpWydn8I?t=2268",
        title: "50 вопросов на Vue JS собеседование",
        time: 2268,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1708,
    question: "Какой опыт с другими фреймворками был",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/Jmpft3r3E2E?t=702",
        title: "Публичное собеседование: frontend-ра…",
        time: 702,
      },
      {
        url: "https://youtu.be/NRufVTyELC4?t=846",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 846,
      },
      {
        url: "https://youtu.be/hDl7w9U-Ly8?t=67",
        title: "Собеседование на Junior Frontend раз…",
        time: 67,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1709,
    question: "Какие проблемы решает react",
    explanation:
      "React — это популярная библиотека для разработки пользовательских интерфейсов. Она предлагает разработчикам эффективный и гибкий способ создавать интерактивные веб-приложения. React решает множество задач и проблем, с которыми разработчики сталкиваются при построении современных веб-приложений:\n1.\nСоздание динамических интерфейсов\nПозволяет легко создавать динамические веб-интерфейсы с использованием компонентов. Благодаря декларативному подходу и использованию JSX (синтаксис, похожий на HTML внутри JavaScript), разработка становится более интуитивно понятной и менее подверженной ошибкам.\n2.\nУправление состоянием компонентов\nПредоставляет механизмы для управления состоянием (state) внутри компонентов, что позволяет разработчикам легко отслеживать и управлять изменениями данных в приложении. Это упрощает создание интерактивных интерфейсов, таких как формы, фильтры, навигация и т.д.\n3.\nОптимизация производительности\nИспользует виртуальный DOM (Virtual DOM), что позволяет оптимизировать обновления в реальном DOM. Это снижает затраты производительности при обновлении пользовательского интерфейса, особенно при работе с большими объемами данных и сложными интерфейсами.\n4.\nКомпонентный подход\nПоощряет использование компонентного подхода к разработке, что позволяет разбивать интерфейс на мелкие, повторно используемые части. Это улучшает организацию кода, облегчает его поддержку и тестирование.\n5.\nУниверсальность и изоморфизм\nКод может выполняться как на клиенте, так и на сервере, что позволяет создавать изоморфные (универсальные) приложения. Это улучшает SEO, скорость загрузки и обеспечивает лучший пользовательский опыт.\n6.\nМощный экосистема и сообщество\nОбладает большим и активным сообществом разработчиков, а также мощной экосистемой инструментов и библиотек, таких как Redux для управления состоянием приложения, React Router для навигации, Next.js для серверного рендеринга и многих других.\n7.\nГибкость и интеграция\nМожет быть интегрирован в существующие приложения постепенно, что делает его удобным выбором для поэтапной модернизации проектов. Также он хорошо сочетается с другими библиотеками и фреймворками.\nReact предлагает разработчикам удобные инструменты для создания эффективных, масштабируемых и поддерживаемых веб-приложений, решая множество проблем современной веб-разработки, начиная от управления состоянием и заканчивая производительностью интерфейсов.",
    videos: [
      {
        url: "https://www.youtube.com/live/Awnog8KYub4?feature=share&t=480",
        title: "Публичное собеседование: Ведущий fro…",
        time: 480,
      },
      {
        url: "https://youtu.be/AWaL_1V9dEY?t=838",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 838,
      },
      {
        url: "https://youtu.be/BsIcbU4LB0k?t=4263",
        title: "ИНТЕРЕСНОЕ СОБЕСЕДОВАНИЕ JUNIOR Fron…",
        time: 4263,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1710,
    question: "Какой самый интересный проект делал",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/Awnog8KYub4?feature=share&t=857",
        title: "Публичное собеседование: Ведущий fro…",
        time: 857,
      },
      {
        url: "https://youtu.be/ZEKcJgVI-YM?t=63",
        title: "Талант в 18 лет? Собеседование #2 fr…",
        time: 63,
      },
      {
        url: "https://youtu.be/8SNNm2kuNk8?t=488",
        title: "[180k] Первичное скайп-СОБЕСЕДОВАНИЕ…",
        time: 488,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1711,
    question: "Как работает settimeout",
    explanation:
      "Функция\n`setTimeout`\nиспользуется для выполнения кода или функции спустя заданный интервал времени, однократно. Она является частью Web API в браузерах и глобального объекта `global` в Node.js, что делает её доступной для использования в любом окружении.\nСинтаксис\nlet timeoutID = setTimeout(function[, delay, arg1, arg2, ...]);\nlet timeoutID = setTimeout(functionCode[, delay]);\nfunction:\nБудет вызвана после задержки.\nfunctionCode:\nСтрока кода для выполнения (использование этой формы не рекомендуется по соображениям безопасности).\ndelay:\nЗадержка в миллисекундах, после которой будет выполнена функция. Если не указать, по умолчанию будет использовано значение\n`0`\n.\narg1, arg2, ...:\nАргументы, которые будут переданы в функцию при её вызове.\nПример:\nfunction sayHello() {\n  console.log('Привет!');\n}\n// Вызывает функцию sayHello после задержки в 2000 миллисекунд (2 секунды)\nsetTimeout(sayHello, 2000);\nОтмена выполнения\n`setTimeout`\nВызов ее возвращает идентификатор таймера, который можно использовать для отмены выполнения с помощью функции\n`clearTimeout`\n.\nlet timerId = setTimeout(sayHello, 2000);\n// Отменяет выполнение\nclearTimeout(timerId);\nОсобенности поведения\nМинимальная задержка:\nВ HTML5 спецификация предусматривает минимальную задержку в\n`4ms`\nдля вложенных таймеров и в некоторых других случаях, что может повлиять на ожидаемое время выполнения.\nЗадержка в неактивных вкладках:\nБраузеры могут изменять поведение таймеров для неактивных вкладок для оптимизации производительности и энергопотребления. Это может привести к значительно большей задержке, чем указано.\nАсинхронность:\n`setTimeout`\nне блокирует выполнение кода, который следует за ним. Он лишь запланирует выполнение функции на будущее, позволяя остальному коду продолжать выполняться без ожидания.\n`setTimeout`\nшироко используется для создания задержек, анимаций, отложенного выполнения кода (например, для дебаунсинга ввода пользователя) и решения других задач, где необходимо управление временем выполнения.",
    videos: [
      {
        url: "https://www.youtube.com/live/t52BuzKzqWw?feature=share&t=299",
        title: "Публичное собеседование: junior-fron…",
        time: 299,
      },
      {
        url: "https://youtu.be/PLwrvZahiO4?t=864",
        title: "Собеседование на JavaScript разработ…",
        time: 864,
      },
      {
        url: "https://youtu.be/OzLjBPjsGgg?t=1516",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 1516,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1712,
    question: "Расскажи про работу с тестами",
    explanation:
      "Работа с тестами — это процесс проверки того, что ваш код работает корректно и делает именно то, что от него ожидается. Оно помогает обнаружить ошибки и недочеты в программе до того, как она будет запущена в производство или передана пользователям. Существует несколько типов тестирования, каждый из которых ориентирован на проверку различных аспектов приложения.\nТипы:\n1.\nМодульное тестирование (Unit Testing):\nПроверка отдельных модулей или компонентов программы на корректность выполнения их функций. Каждый тест оценивает работу отдельной части кода в изоляции от остальной программы.\n2.\nИнтеграционное тестирование (Integration Testing):\nПроверка взаимодействия между различными модулями или внешними системами и сервисами. Цель — убедиться, что компоненты системы корректно работают вместе.\n3.\nФункциональное тестирование (Functional Testing):\nПроверка того, что функциональные требования, предъявляемые к программе, выполняются. Эти тесты фокусируются на пользовательских сценариях и возможностях программы.\n4.\nТестирование производительности (Performance Testing):\nОценка скорости, стабильности и масштабируемости приложения под нагрузкой.\n5.\nТестирование безопасности (Security Testing):\nПроверка на наличие уязвимостей, которые могут быть использованы для несанкционированного доступа или повреждения данных.\nИнструменты\nДля автоматизации процесса тестирования существует множество инструментов и библиотек. Выбор инструмента зависит от языка программирования, среды разработки и конкретных требований проекта. Например:\nMocha\nJest\nCypress\nПроцесс\n1.\nПланирование:\nОпределение целей тестирования, выбор инструментов и методик.\n2.\nНаписание тестов:\nСоздание тестовых сценариев, которые проверяют различные аспекты работы кода.\n3.\nВыполнение тестов:\nЗапуск тестов и сбор результатов.\n4.\nАнализ результатов:\nИнтерпретация результатов тестирования, выявление и исправление ошибок.\n5.\nРефакторинг:\nУлучшение структуры и качества кода без изменения его функциональности на основе результатов тестирования.\n6.\nРегрессионное тестирование:\nПовторное тестирование после изменений, чтобы убедиться, что исправления не привели к новым ошибкам.\nПреимущества\nУлучшение качества кода: Помогают обнаружить и исправить ошибки на ранних этапах разработки.\nДокументация: Могут служить формой документации, показывая, как предполагается использовать код.\nУверенность в коде: Позволяют разработчикам вносить изменения в код, не боясь случайно нарушить его работу.\nУпрощение рефакторинга: Наличие их облегчает рефакторинг кода, поскольку они могут быстро показать, сломалось ли что-то после внесения изменений.\nТестирование — это неотъемлемая часть процесса разработки ПО, позволяющая повысить его качество, надежность и безопасность.",
    videos: [
      {
        url: "https://www.youtube.com/live/t52BuzKzqWw?feature=share&t=1027",
        title: "Публичное собеседование: junior-fron…",
        time: 1027,
      },
      {
        url: "https://youtu.be/g5LdFoV6iUg?t=4802",
        title: "#12 Фронтенд-разработчик нейросети н…",
        time: 4802,
      },
      {
        url: "https://www.youtube.com/watch?v=3D0IVhYzXJM&t=5005s",
        title: "#2 Собеседование смелого Frontend Mi…",
        time: 5005,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1713,
    question: "С какими процессорами работал",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/t52BuzKzqWw?feature=share&t=2483",
        title: "Публичное собеседование: junior-fron…",
        time: 2483,
      },
      {
        url: "https://youtu.be/ktdN2upYX1I?t=465",
        title: "Стать фронтендером после 30: из рабо…",
        time: 465,
      },
      {
        url: "https://youtu.be/0fI5sTI5uck?t=475",
        title: "Собеседование в Яндексе - Разработчи…",
        time: 475,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1714,
    question: "Как было организовано код ревью",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/MdRE18dGmNU?feature=share&t=1048",
        title: "Публичное собеседование: Junior Fron…",
        time: 1048,
      },
      {
        url: "https://youtu.be/VzorPrTjUII?t=1741",
        title: "Middle за год? Собеседование #3 fron…",
        time: 1741,
      },
      {
        url: "https://www.youtube.com/watch?v=NnN4jq2lfGI&t=1386s",
        title: "#14 Собеседование Senior Frontend ра…",
        time: 1386,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1715,
    question: "Как взаимодействуешь с командой",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/MdRE18dGmNU?feature=share&t=1076",
        title: "Публичное собеседование: Junior Fron…",
        time: 1076,
      },
      {
        url: "https://www.youtube.com/live/wGVdU1Jje2M?feature=share&t=884",
        title: "Frontend-разработчик: публичное собе…",
        time: 884,
      },
      {
        url: "https://youtu.be/5GkMyQAGLXg?t=1295",
        title: "Собеседование frontend-разработчика …",
        time: 1295,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1716,
    question: "Как оцениваешь свой уровень программирования",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/JERUf-xKU1o?feature=share&t=2215",
        title: "Публичное собеседование #6: Дмитрий …",
        time: 2215,
      },
      {
        url: "https://youtu.be/MHrKcnyN46M?t=27",
        title: "СОБЕСЕДОВАНИЕ НА FRONTEND РАЗРАБОТЧИ…",
        time: 27,
      },
      {
        url: "https://youtu.be/qika0TkDFz4?t=295",
        title: "#7 Первое собеседование Junior Front…",
        time: 295,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1717,
    question: "Где работаешь сейчас",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/wGVdU1Jje2M?feature=share&t=344",
        title: "Frontend-разработчик: публичное собе…",
        time: 344,
      },
      {
        url: "https://youtu.be/ElCvv0iFWq4?t=26",
        title: "СОБЕСЕДОВАНИЕ Middle Frontend разраб…",
        time: 26,
      },
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=326",
        title: "Первое интервью фронтендера самоучки…",
        time: 326,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1718,
    question: "Что ты знаешь про специфичность селекторов",
    explanation:
      'Специфичность селекторов — это механизм, по которому браузер определяет, какие CSS-правила применять к элементу, в случае конфликта между несколькими правилами. Специфичность определяется на основе вида селектора и его вложенности. Это ключевой аспект для понимания того, как CSS применяется к HTML-документу и как разрешаются конфликты стилей.\nКак рассчитывается специфичность:\nСпецифичность рассчитывается по четырём компонентам (A, B, C, D), которые можно представить в виде чисел в четырёхколоночном значении:\nA:\nЕсли стиль прописан в атрибуте `style` у элемента, то A = 1 (инлайновые стили).\nB:\nКоличество ID селекторов в правиле.\nC:\nКоличество классов, селекторов атрибутов и псевдоклассов в правиле.\nD:\nКоличество типов элементов и псевдоэлементов в правиле.\nПри этом важно понимать, что селектор с более высоким уровнем специфичности переопределит селектор с более низким уровнем специфичности, независимо от порядка их объявления.\nПримеры:\n1.\nИнлайновый стиль\n(A=1, B=0, C=0, D=0): Наивысшая специфичность.\n<div style="color: red;"></div>\n2.\nID селектор\n(A=0, B=1, C=0, D=0): Высокая специфичность.\n#header { color: blue; }\n3.\nКлассы, селекторы атрибутов, псевдоклассы\n(A=0, B=0, C=1, D=0):\n.button.active { color: green; }\n4.\nТипы элементов и псевдоэлементы\n(A=0, B=0, C=0, D=1):\ndiv::before { content: ">>"; }\nИсключения и особые случаи:\nУниверсальный селектор\n(\n`*`\n), комбинаторы (например,\n`+`\n,\n`>`\n,\n`~`\n) и отрицание (\n`:not()`\n) не влияют на специфичность.\nВажность (`!important`):\nЕсли к правилу применён\n`!important`\n, это правило переопределяет другие правила, независимо от специфичности (использовать с осторожностью).\nПонимание специфичности селекторов помогает избежать конфликтов стилей и делает код более предсказуемым и управляемым. Это основа для эффективной разработки стилей и помогает избежать излишнего использования\n`!important`\n, что может усложнить дальнейшую поддержку кода.\nСпецифичность — это важный инструмент для управления каскадом стилей и обеспечения того, чтобы правильные стили применялись к правильным элементам.',
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=2734",
        title: "Public interview for Frontend/HTML/C…",
        time: 2734,
      },
      {
        url: "https://youtu.be/9nBbRK-Gfjg?t=4243",
        title: "Мок-интервью для джуна-фронтендера: …",
        time: 4243,
      },
      {
        url: "https://youtu.be/PLwrvZahiO4?t=194",
        title: "Собеседование на JavaScript разработ…",
        time: 194,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1719,
    question: "Как отцентровать блок по горизонтали и по вертикали",
    explanation:
      'Центрирование блока по горизонтали и вертикали можно выполнить несколькими способами, в зависимости от контекста и требований к верстке. Вот несколько популярных методов:\nИспользование Flexbox\nЭто мощный инструмент для управления макетом, который позволяет легко центрировать элементы.\n.parent {\n  display: flex;\n  justify-content: center; /* Центрирование по горизонтали */\n  align-items: center; /* Центрирование по вертикали */\n  height: 100vh; /* Высота родительского блока */\n}\n<div class="parent">\n  <div class="child">Центрированный блок</div>\n</div>\nИспользование Grid\nТакже позволяет легко центрировать элементы как по горизонтали, так и по вертикали.\n.parent {\n  display: grid;\n  place-items: center; /* Центрирование по горизонтали и вертикали */\n  height: 100vh;\n}\n<div class="parent">\n  <div class="child">Центрированный блок</div>\n</div>\nИспользование абсолютного позиционирования\nЭтот метод подходит для центрирования элемента внутри родительского блока с относительным позиционированием.\n.parent {\n  position: relative;\n  height: 100vh;\n}\n.child {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n<div class="parent">\n  <div class="child">Центрированный блок</div>\n</div>\nИспользование свойства `margin`\nДля горизонтального центрирования блочного элемента его можно использовать с автоматическим расчетом слева и справа.\n.child {\n  width: 50%; /* Желаемая ширина блока */\n  margin: 0 auto; /* Автоматический отступ слева и справа */\n}\nОднако, для вертикального центрирования этот метод работает только при фиксированной высоте родителя и требует дополнительных расчетов.\nВыбор метода зависит от конкретных требований к макету и поддержки браузерами. Flexbox и Grid являются современными и предпочтительными способами для создания адаптивных макетов, в то время как абсолютное позиционирование и использование `margin` могут пригодиться в более специфических ситуациях.',
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=378",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 378,
      },
      {
        url: "https://youtu.be/gV6eobXisYU?t=942",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 942,
      },
      {
        url: "https://youtu.be/ZEKcJgVI-YM?t=2517",
        title: "Талант в 18 лет? Собеседование #2 fr…",
        time: 2517,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1720,
    question: "Что такое inline стили, и какой они имеют приоритет",
    explanation:
      'Inline стили — это способ применения CSS-правил непосредственно к HTML-элементу через атрибут\n`style`\n. Этот метод позволяет задать стили индивидуально для конкретного элемента, напрямую внутри его тега, без использования внешних или внутренних стилевых листов.\nПример:\n<p style="color: red; font-size: 20px;">Этот текст будет красного цвета и с размером шрифта 20px.</p>\nПриоритетность inline стилей\nОни имеют более высокий приоритет, чем стили, заданные через внешние или внутренние стилевые листы. Это означает, что если для одного и того же элемента заданы стили через CSS-классы или идентификаторы и через inline атрибут\n`style`\n, то они будут применены.\nПорядок приоритетов CSS:\n1.\nInline стили\n(наивысший приоритет)\n2.\nID селекторы\n3.\nКлассы, псевдоклассы и атрибуты\n4.\nЭлементы и псевдоэлементы\n(наименьший приоритет)\nСтоит отметить, что существует способ переопределить даже их с помощью правила\n`!important`\nв CSS, однако его использование следует минимизировать, поскольку это может усложнить дальнейшее управление и обслуживание стилей.\nПреимущества:\nПозволяют быстро протестировать и применить стили к конкретному элементу без необходимости редактирования стилевых листов.\nПолезны для стилей, которые должны быть применены к одному элементу и не повторяются в других частях веб-страницы.\nНедостатки:\nУсложняют HTML-разметку и делают её менее читаемой.\nЗатрудняют поддержку и обновление стилей, особенно при большом количестве inline стилей.\nСнижают возможность повторного использования CSS-правил и нарушают принцип разделения структуры и оформления.\nИспользование inline стилей может быть оправдано в определённых ситуациях, например, при динамическом изменении стилей или для уникальных стилей, специфичных для одного элемента. Однако для обеспечения лучшей организации кода и его поддержки рекомендуется использовать внешние или внутренние стилевые листы.',
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=467",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 467,
      },
      {
        url: "https://youtu.be/gV6eobXisYU?t=979",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 979,
      },
      {
        url: "https://youtu.be/PLwrvZahiO4?t=251",
        title: "Собеседование на JavaScript разработ…",
        time: 251,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1721,
    question: "Разница между margin и padding",
    explanation:
      '`margin`\nи\n`padding`\nявляются свойствами, используемыми для создания пространства вокруг элементов, но они служат разным целям и применяются к различным частям элемента:\nMargin (внешний отступ)\nОпределение:\nОбозначает внешнее пространство вокруг элемента, то есть пространство между границей элемента и соседними элементами.\nОсобенности:\n- Может быть отрицательным, позволяя элементам перекрываться.\n- Внешние отступы элементов могут "сливаться" (margin collapsing), когда вертикальные отступы двух соседних элементов объединяются в один, равный максимальному из этих двух отступов.\nИспользование:\nИспользуется для создания пространства между элементами и их контейнерами или между самими элементами. Не влияет на размер самого элемента.\nPadding (внутренний отступ)\nОпределение:\nОбозначает внутреннее пространство элемента, то есть пространство между содержимым элемента и его границей.\nОсобенности:\n- Увеличивает общий размер элемента, если размер задан явно. Например, если у элемента есть ширина 100px и padding 10px с каждой стороны, общая ширина элемента будет 120px.\n- Внутренний отступ всегда положителен и не может "сливаться" как внешние отступы.\nИспользование:\nИспользуется для создания пространства вокруг содержимого внутри элемента, влияя на восприятие и читаемость содержимого.\nВизуальное различие\nЕсли представить элемент как коробку, то\n`padding`\nбудет располагаться внутри коробки, увеличивая её внутреннее пространство, но не изменяя размер самой коробки.\n`Margin`\nрасполагается снаружи коробки, увеличивая пространство между этой коробкой и другими объектами вокруг неё, но не влияя на размеры самой коробки.\nПример:\n.box {\n  width: 100px;\n  height: 100px;\n  margin: 20px;\n  padding: 20px;\n  border: 5px solid black; /* Для наглядности границы */\n}\nВ этом примере элемент с классом } будет иметь внутреннее пространство (padding) в 20px вокруг содержимого внутри границы и внешнее пространство (margin) в 20px вокруг границы, отделяющее его от других элементов.\n`Margin`\nи `\npadding`\nявляются фундаментальными CSS-свойствами для стилизации веб-страниц, позволяя контролировать пространство вокруг и внутри элементов. Их правильное использование важно для создания желаемого макета и влияет на внешний вид и пользовательский опыт веб-проекта.',
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=614",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 614,
      },
      {
        url: "https://youtu.be/gV6eobXisYU?t=1007",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 1007,
      },
      {
        url: "https://youtu.be/PLwrvZahiO4?t=320",
        title: "Собеседование на JavaScript разработ…",
        time: 320,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1722,
    question: "Что такое псевдоклассы",
    explanation:
      "Псевдоклассы — это ключевые слова, добавляемые к селекторам, которые указывают на специальное состояние выбранного элемента. Псевдоклассы позволяют стилизовать элементы на основе их состояния в документе, без необходимости добавления дополнительных классов или ID напрямую в HTML-код. С их помощью можно, например, изменить внешний вид ссылок при наведении курсора, стилизовать четные и нечетные элементы списка, изменять стиль элементов при получении фокуса и многое другое.\nПримеры:\n`:hover`\n— применяется к элементу, когда на него наводят курсор мыши.\na:hover {\n  color: red; /* Ссылка станет красной при наведении */\n}\n`:focus`\n— применяется к элементу, когда он получает фокус (например, при переходе на элемент с помощью клавиатуры или при клике мыши).\ninput:focus {\n  border-color: blue; /* Граница инпута станет синей при фокусе */\n}\n`:active`\n— применяется к элементу в момент его активации пользователем (например, во время клика по кнопке).\nbutton:active {\n  transform: scale(0.98); /* Кнопка немного уменьшится при клике */\n}\n`:nth-child()`\n— позволяет стилизовать элементы в зависимости от их порядка среди детей родительского элемента.\nli:nth-child(odd) {\n  background-color: gray; /* Заливка каждого нечетного элемента списка */\n}\n`:not()`\n— исключает из выборки элементы, соответствующие указанному селектору.\ndiv:not(.special) {\n  color: green; /* Применяется к каждому div, который не имеет класса special */\n}\nЗачем нужны псевдоклассы:\nОни делают CSS более мощным и гибким, позволяя разработчикам применять стили к элементам на основе их состояния или положения в документе, без изменения HTML-структуры. Это особенно полезно для создания интерактивных и реактивных пользовательских интерфейсов, где визуальное состояние элемента должно меняться в ответ на действия пользователя.\nПсевдоклассы улучшают пользовательский опыт, делая интерфейс более отзывчивым и интуитивно понятным, а также облегчают поддержку и обновление стилей, минимизируя необходимость в добавлении и управлении классами и идентификаторами.",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=853",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 853,
      },
      {
        url: "https://youtu.be/gV6eobXisYU?t=1094",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 1094,
      },
      {
        url: "https://youtu.be/hDl7w9U-Ly8?t=644",
        title: "Собеседование на Junior Frontend раз…",
        time: 644,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1723,
    question: "Свойство display - основное значение и как оно работает",
    explanation:
      "Свойство\n`display`\nявляется одним из ключевых свойств для управления макетом страницы. Оно определяет, как должен отображаться элемент и его потомки в документе. Оно может принимать различные значения, каждое из которых меняет поведение элемента в потоке документа, его видимость или способ взаимодействия с другими элементами.\nОсновные значения свойства `display`:\n`block`:\nЭлемент отображается как блочный. Блочные элементы занимают всю доступную ширину контейнера, независимо от своего содержимого, и начинаются с новой строки.\n`inline`:\nЭлемент отображается на той же строке, что и соседние элементы, и занимает только столько места, сколько необходимо для содержимого. Высота и ширина не применяются.\n`inline-block`:\nЭлемент отображается как\n`inline`\n, но позволяет задавать ширину и высоту, как у\n`block`\nэлементов.\n`none`:\nЭлемент полностью убирается из потока документа, и его не видно на странице. Важно отличать от\n`visibility: hidden`\n, где элемент не виден, но занимает место в макете.\n`flex`:\nЭлемент становится flex-контейнером, и его непосредственные потомки становятся flex-элементами, что позволяет использовать гибкую систему выравнивания и распределения пространства между элементами внутри контейнера.\n`grid`.\nЭлемент становится grid-контейнером, и его непосредственные потомки становятся grid-элементами, что позволяет создавать сложные макеты с помощью двумерной сетки размещения элементов.\nКак работает свойство `display`:\nВлияет на то, как элемент взаимодействует с потоком документа (то есть, как он размещается среди других элементов) и какие CSS-свойства к нему применимы (например, ширина, высота, отступы).\nИзменение его значения может изменить поведение элемента от блочного к инлайновому и наоборот, что влияет на расположение соседних элементов и на возможность применения определённых свойств к элементу.\nНапример, блочный элемент (\n`display: block;`\n) будет пытаться занять всю доступную ширину контейнера и вытолкнет другие элементы на новую строку, в то время как инлайновый элемент (\n`display: inline;`\n) расположится на той же строке с другими инлайновыми или текстовыми элементами.\nЗначение\n`flex`\nили\n`grid`\nпревращает элемент в контейнер, который использует гибкую или сеточную модель для расположения своих потомков, соответственно, предоставляя мощные инструменты для создания адаптивных макетов.\nСвойство\n`display`\nопределяет, как элемент будет отображаться в документе, влияя на его расположение и взаимодействие с другими элементами. Изменяя значение этого свойства, можно управлять макетом страницы, использовать различные модели макета (блочную, инлайновую, flex, grid и др.), а также скрывать элементы без удаления их из DOM. Это делает `display` одним из самых мощных и важных инструментов.",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=1537",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 1537,
      },
      {
        url: "https://youtu.be/gV6eobXisYU?t=821",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 821,
      },
      {
        url: "https://youtu.be/ktdN2upYX1I?t=599",
        title: "Стать фронтендером после 30: из рабо…",
        time: 599,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1724,
    question: "Как поменять контекст функции",
    explanation:
      "Контекст выполнения функции (значение\n`this`\nвнутри функции) может быть изменён несколькими способами. Это позволяет более гибко управлять тем, как функции вызываются, особенно в объектно-ориентированном программировании. Вот основные способы изменения контекста функции:\n1.\n`call()`\nи\n`apply()`\nПозволяют вызывать функцию с явным указанием объекта, который должен быть использован в качестве\n`this`\n, и с передачей аргументов в эту функцию.\n`call(thisArg, arg1, arg2, ...)`:\nВызывает функцию с указанным контекстом\n`thisArg`\nи аргументами\n`arg1`\n,\n`arg2`\n, ...\n`apply(thisArg, [argsArray])`:\nАналогичен\n`call`\n, но принимает аргументы в виде массива.\nfunction greet() {\n  console.log(`Привет, ${this.name}`);\n}\nconst person = { name: 'Алексей' };\ngreet.call(person);  // Привет, Алексей\ngreet.apply(person); // Привет, Алексей\n2.\n`bind()`(thisArg[, arg1[, arg2[, ...]]])`\nсоздаёт новую функцию с привязанным контекстом\n`thisArg`\nи начальными аргументами\n`arg1`\n,\n`arg2`\n, ...\nfunction greet() {\n  console.log(`Привет, ${this.name}`);\n}\nconst person = { name: 'Мария' };\nconst greetPerson = greet.bind(person);\ngreetPerson(); // Привет, Мария\n3. Стрелочные функции(\n`() => {}`\n) не имеют собственного контекста\n`this`\n. Вместо этого они заимствуют\n`this`\nиз окружающего лексического контекста. Это значит, что\n`this`\nвнутри стрелочной функции будет таким же, как и в её родительском контексте, что упрощает работу с контекстом, особенно в колбэках и обработчиках событий.\nconst person = {\n  name: 'Иван',\n  greet: function() {\n    // Стрелочная функция заимствует `this` из метода `greet`\n    window.setTimeout(() => console.log(`Привет, ${this.name}`), 1000);\n  }\n};\nperson.greet(); // Привет, Иван (после задержки в 1 секунду)\nИспользование контекста в классах\nES6 для методов, которые вы хотите передать в качестве колбэков и при этом сохранить контекст класса, часто используется\n`.bind(this)`\nв конструкторе или определение метода через стрелочную функцию в свойстве класса.\nИзменение контекста функции  — мощный механизм, позволяющий более гибко управлять выполнением кода.\n`call()`\n,\n`apply()`\n, и\n`bind()`\nдают возможность явно указать контекст\n`this`\nдля функций, в то время как стрелочные функции позволяют наследовать контекст из родительского лексического окружения, делая код более чистым и понятным.",
    videos: [
      {
        url: "https://youtu.be/gV6eobXisYU?t=547",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 547,
      },
      {
        url: "https://youtu.be/YwRgLQ0SoKk?t=589",
        title: "Собеседование frontend разработчика",
        time: 589,
      },
      {
        url: "https://youtu.be/0fI5sTI5uck?t=1237",
        title: "Собеседование в Яндексе - Разработчи…",
        time: 1237,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1725,
    question: "Что такое тернарный оператор",
    explanation:
      "Тернарный оператор  — это упрощённая форма условного оператора, который позволяет выполнять выбор между двумя выражениями в зависимости от истинности или ложности заданного условия.  Обычно записывается как\n`условие ? выражение1 : выражение2`\n.\nСтруктура тернарного оператора:\nУсловие:\nЛюбое выражение, которое оценивается как\n`true`\n(истина) или\n`false`\n(ложь).\nВыражение1:\nВыполняется, если условие истинно (\n`true`\n).\nВыражение2:\nВыполняется, если условие ложно (\n`false`\n).\nПример:\nlet age = 18;\nlet status = age >= 18 ? 'взрослый' : 'несовершеннолетний';\nconsole.log(status); // Выведет: взрослый\nВ этом примере условие\n`age >= 18`\nпроверяет, является ли возраст человека 18 лет или более. Если условие истинно, переменной\n`status`\nприсваивается значение\n`'взрослый'`\n. В противном случае —\n`'несовершеннолетний'`\n.\nПреимущества:\nКраткость и удобство записи для простых условных конструкций.\nУменьшает количество кода по сравнению с использованием стандартных условных операторов (\n`if...else`\n).\nНедостатки:\nМожет ухудшить читаемость кода при использовании сложных условий или вложенных тернарных операторов.\nИспользование более одного тернарного оператора в одном выражении может сделать код трудным для понимания.\nЛучшие практики:\nДля простых условных выражений.\nИзбегайте вложенности тернарных операторов, так как это может сделать код менее читаемым.\nРассмотрите возможность использования стандартного условного оператора\n`if...else`\nдля более сложных условий или когда требуется выполнение блоков кода, а не просто выбор между двумя выражениями.\nТернарный оператор является полезным инструментом в арсенале программиста, позволяя писать более краткий и иногда более элегантный код, но его следует использовать с умом, чтобы не ухудшить читаемость программы.",
    videos: [
      {
        url: "https://youtu.be/gV6eobXisYU?t=581",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 581,
      },
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=1373",
        title: "Первое интервью фронтендера самоучки…",
        time: 1373,
      },
      {
        url: "https://youtu.be/KvPUlwkSs_E?t=1495",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 1495,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1726,
    question: "Что такое деструктуризация",
    explanation:
      "Деструктуризация — это выразительный и компактный синтаксис для извлечения значений из массивов или свойств из объектов в отдельные переменные. Этот синтаксис упрощает работу с данными, позволяя писать менее многословный и более читаемый код.\nДеструктуризация объектов\nИмена переменных соответствуют ключам свойств объекта. Если свойство с таким именем существует, его значение присваивается переменной.\nconst person = {\n  name: 'Алексей',\n  age: 30,\n  job: 'Инженер'\n};\n// Деструктуризация объекта\nconst { name, age, job } = person;\nconsole.log(name); // Алексей\nconsole.log(age);  // 30\nconsole.log(job);  // Инженер\nТакже можно задать переменным другие имена, отличные от ключей объекта:\nconst { name: personName, age: personAge } = person;\nconsole.log(personName); // Алексей\nconsole.log(personAge);  // 30\nДеструктуризация массивов\nИспользуется порядок элементов. Значения из массива присваиваются переменным в соответствии с их позицией.\nconst rgb = [255, 200, 0];\n// Деструктуризация массива\nconst [red, green, blue] = rgb;\nconsole.log(red);   // 255\nconsole.log(green); // 200\nconsole.log(blue);  // 0\nПараметры функции\nДеструктуризация также может использоваться в них для более удобной работы со свойствами передаваемых объектов или элементами массивов.\nfunction introduce({ name, age }) {\n  console.log(`Меня зовут ${name}, мне ${age} лет.`);\n}\nintroduce(person); // Меня зовут Алексей, мне 30 лет.\nЗначения по умолчанию\nМожно задать его для переменных, на случай, если такого свойства нет в объекте или элемента нет в массиве.\nconst { name, hobby = 'Чтение' } = person;\nconsole.log(hobby); // Чтение\nДеструктуризация предоставляет удобный способ доступа к элементам массивов и свойствам объектов, позволяя писать более чистый и понятный код. Это особенно полезно при работе с функциями, которые принимают объекты с множеством параметров или при необходимости извлечения нескольких значений из массивов и объектов.",
    videos: [
      {
        url: "https://youtu.be/gV6eobXisYU?t=604",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 604,
      },
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=2827",
        title: "Собеседование на JavaScript разработ…",
        time: 2827,
      },
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=2827",
        title: "Первое интервью фронтендера самоучки…",
        time: 2827,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1728,
    question: "E.Preventdefault() и e.Stopprepagination(), для чего нужны",
    explanation:
      "`e.preventDefault()`\nи\n`e.stopPropagation()`\n— это методы объекта события (\n`Event`\n), используемые для управления поведением событий в веб-приложениях. Они позволяют контролировать стандартное поведение браузера и распространение событий в DOM-дереве.\n`e.preventDefault()`\nПредотвращает выполнение стандартного действия, ассоциированного с событием. Это может быть полезно во многих случаях, например, когда нужно остановить отправку формы по умолчанию при нажатии на кнопку submit, чтобы вместо этого обработать данные формы.\nПример:\ndocument.querySelector('form').addEventListener('submit', function(e) {\n  e.preventDefault(); // Предотвращает отправку формы\n  // Здесь может быть код для обработки данных формы\n});\n`e.stopPropagation()`\nОстанавливает дальнейшее распространение события по DOM-дереву. В DOM события распространяются тремя фазами: захват (capturing), достижение целевого элемента (target), и всплытие (bubbling).\n`e.stopPropagation()`\nпредотвращает переход события к следующим обработчикам на текущей фазе и на других фазах.\nПример:\ndocument.querySelector('#child').addEventListener('click', function(e) {\n  e.stopPropagation(); // Останавливает распространение события клика дальше по DOM-дереву\n  console.log('Клик по дочернему элементу');\n});\ndocument.querySelector('#parent').addEventListener('click', function() {\n  console.log('Клик по родительскому элементу');\n});\nВ этом примере, несмотря на то что клик происходит и на дочернем, и на родительском элементе, благодаря `e.stopPropagation()` в консоль будет выведено только сообщение от дочернего элемента.\nЗачем они нужны\n`e.preventDefault()`\nиспользуется для контроля над поведением браузера, чтобы предотвратить выполнение действий по умолчанию, что позволяет разработчикам реализовывать собственную логику обработки событий.\n`e.stopPropagation()`\nпозволяет избежать нежелательного взаимодействия с другими обработчиками событий, расположенными выше или ниже по DOM-дереву, предотвращая таким образом возможные побочные эффекты от всплытия или захвата событий.\nОба эти метода играют важную роль в создании интерактивных веб-приложений, давая точный контроль над поведением событий.",
    videos: [
      {
        url: "https://youtu.be/gV6eobXisYU?t=646",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 646,
      },
      {
        url: "https://youtu.be/YwRgLQ0SoKk?t=905",
        title: "Собеседование frontend разработчика",
        time: 905,
      },
      {
        url: "https://youtu.be/YwRgLQ0SoKk?t=905",
        title: "Собеседование frontend разработчика",
        time: 905,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1731,
    question: "Что такое прототипное наследование",
    explanation:
      'Прототипное наследование — это механизм, с помощью которого объекты могут наследовать свойства и методы от других объектов. Это одна из основных особенностей языка JavaScript, отличающая его от классических моделей наследования, используемых во многих других языках программирования.\nКак это работает\nКаждый объект имеет специальное скрытое свойство\n`[[Prototype]]`\n(как правило, доступное как\n`__proto__`\nили через\n`Object.getPrototypeOf()`\n), которое ссылается на другой объект — его прототип. Когда вы пытаетесь получить доступ к свойству или методу объекта, и это свойство/метод не найдено в самом объекте, поиск продолжается по цепочке прототипов, пока свойство/метод не будет найден или не будет достигнут конец цепочки прототипов (прототип\n`null`\n).\nПример:\nlet animal = {\n  eats: true,\n  walk() {\n    console.log("Animal walk");\n  }\n};\nlet rabbit = {\n  jumps: true,\n  __proto__: animal\n};\nrabbit.walk(); // Animal walk\nconsole.log(rabbit.eats); // true\nВ этом примере объект\n`rabbit`\nнаследует свойство\n`eats`\nи метод\n`walk`\nот объекта\n`animal`\nчерез прототипную цепочку.\nОсновные принципы\nПрототипная цепочка:\nКогда вы обращаетесь к свойству объекта, автоматически ищет это свойство в объекте, а затем — в его прототипах, пока не достигнет конца цепочки прототипов.\n`Object.prototype`:\nВ вершине прототипной цепочки находится\n`Object.prototype`\n. Он не имеет прототипа и содержит методы, доступные всем объектам, такие как\n`toString()`\n,\n`hasOwnProperty()`\nи другие.\nСоздание объектов с определённым прототипом:\nДля создания объектов с указанием прототипа можно использовать\n`Object.create(proto)`\n, где\n`proto`\n— объект, который должен стать прототипом для нового объекта.\nОтличия от классического наследования\nВ отличие от него, прототипное наследование не использует классы как таковые (до введения\n`class`\nв ES6, которые являются "синтаксическим сахаром" над прототипным наследованием). Вместо этого объекты напрямую наследуют свойства и методы от других объектов.\nПрототипное наследование является мощной особенностью, позволяющей объектам наследовать поведение от других объектов. Это обеспечивает гибкость и возможности для повторного использования кода без строгой иерархии классов, характерной для классических моделей наследования.',
    videos: [
      {
        url: "https://youtu.be/gV6eobXisYU?t=783",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 783,
      },
      {
        url: "https://youtu.be/BonLyarPpqE?t=2978",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 2978,
      },
      {
        url: "https://youtu.be/qGdV5YOmtrs?t=616",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 616,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1732,
    question: "Что такое jsx",
    explanation:
      "JSX (JavaScript XML) — это расширение синтаксиса. Оно позволяет писать структуру компонентов React с использованием синтаксиса, похожего на HTML, непосредственно файлах. Этот синтаксический сахар делает код более читабельным и удобным для разработки пользовательских интерфейсов.\nОсновные особенности JSX:\nСочетание HTML и JavaScript:\nПозволяет использовать HTML-теги и компоненты React внутри JavaScript-кода.\nВыражения JavaScript:\nМожно вставлять JavaScript-выражения в фигурные скобки\n`{}`\n. Это позволяет динамически управлять содержимым компонентов.\nКомпонентный подход:\nЛегко создавать и использовать повторно компоненты UI, что упрощает разработку сложных пользовательских интерфейсов.\nПреобразование:\nНе может быть выполнен напрямую браузерами и требует преобразования в обычный JavaScript. Это обычно делается с помощью транспиляторов, таких как Babel.\nПример:\nconst element = <h1>Привет, мир!</h1>;\nЭтот пример демонстрирует JSX-элемент, который представляет собой заголовок первого уровня с текстом \"Привет, мир!\". В реальном JavaScript этот код будет преобразован в вызов\n`React.createElement()`\n, который создаёт React-элемент.\nВставка выражений:\nВы можете вставлять любые допустимые JavaScript-выражения в него, обернув их в фигурные скобки. Например:\nconst name = 'Иван Иванов';\nconst element = <h1>Привет, {name}</h1>;\nПреимущества использования JSX:\nНаглядность:\nКод с ним легче читать и писать, поскольку он напоминает HTML.\nМощность:\nСочетает в себе преимущества JavaScript, позволяя использовать всю его выразительную мощь при описании UI.\nИнтеграция:\nПлотно интегрирован с React, облегчая создание интерактивных компонентов.\nJSX — это расширение синтаксиса, которое делает разработку интерфейсов на React более интуитивной и выразительной за счёт смешивания HTML-подобного кода с JavaScript. Хотя использование JSX необязательно для работы с React, оно значительно упрощает процесс разработки и повышает читабельность кода.",
    videos: [
      {
        url: "https://youtu.be/gV6eobXisYU?t=1607",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 1607,
      },
      {
        url: "https://youtu.be/BsIcbU4LB0k?t=3946",
        title: "ИНТЕРЕСНОЕ СОБЕСЕДОВАНИЕ JUNIOR Fron…",
        time: 3946,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=2990",
        title: "Собеседование cтажера Frontend разра…",
        time: 2990,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1734,
    question: "Что такое props",
    explanation:
      '`props`\n— это сокращение от "properties" (свойства). Это концепция, используемая для передачи данных от родительского компонента к дочернему компоненту. Они являются неизменяемыми, что означает, что дочерний компонент не может напрямую изменять полученные его; вместо этого, любые изменения в данных должны происходить на уровне родительского компонента, который затем повторно передает его дочерним компонентам.\nКак они работают\nКогда вы создаете компонент, вы можете передать ему `props` следующим образом:\nconst ParentComponent = () => {\n  return <ChildComponent name="Иван" age={30} />;\n};\nВ этом примере,\n`ChildComponent`\nполучает два\n`props`\n:\n`name`\nи\n`age`\n. Доступ к этим\n`props`\nвнутри\n`ChildComponent`\nпроисходит так:\nconst ChildComponent = (props) => {\n  return <h1>Привет, мое имя {props.name}, мне {props.age} лет.</h1>;\n};\nОсобенности `props`\nНеизменяемость:\nПредназначены только для чтения. Это означает, что компонент не может изменить свои\n`props`\n, но может либо использовать их "как есть", либо использовать их для вычисления новых значений внутри компонента.\nПередача данных:\nПозволяют компонентам получать данные от родителя, что делает компоненты более гибкими и повторно используемыми.\nПередача функций:\nЧерез него можно передавать не только данные, но и функции, что позволяет родительскому компоненту предоставлять обработчики событий дочерним компонентам.\nПример передачи функции\nconst ParentComponent = () => {\n  const showAlert = () => {\n    alert("Приветствие от родителя!");\n  };\n  return <ChildComponent showAlert={showAlert} />;\n};\nconst ChildComponent = (props) => {\n  return <button onClick={props.showAlert}>Показать приветствие</button>;\n};\nВ этом примере, функция\n`showAlert`\nопределена в\n`ParentComponent`\nи передается как\n`props`\nв\n`ChildComponent`\n, который затем использует ее как обработчик события клика для кнопки.\n`props`\n— это механизм для передачи данных и функций от родительских компонентов к дочерним, делая компоненты гибкими и повторно используемыми. С помощью\n`props`\n, компоненты могут динамически отображать данные и взаимодействовать с другими компонентами в приложении.',
    videos: [
      {
        url: "https://youtu.be/gV6eobXisYU?t=1657",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 1657,
      },
      {
        url: "https://youtu.be/umHjpWydn8I?t=109",
        title: "50 вопросов на Vue JS собеседование",
        time: 109,
      },
      {
        url: "https://youtu.be/jf5TkGzWqiM?t=2106",
        title: "Собеседование JUNIOR FRONTEND REACT …",
        time: 2106,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1737,
    question: "Что такое react",
    explanation:
      'React — это декларативная, эффективная и гибкая библиотека для создания пользовательских интерфейсов. Она позволяет строить сложные интерактивные UI из небольших и изолированных частей кода, называемых "компонентами". Он был создан инженерами Facebook и впервые представлен в 2013 году.\nОсновные особенности React:\nКомпонентный подход:\nПриложения строятся из компонентов, которые содержат свой собственный стейт (состояние) и логику отображения. Компоненты могут быть повторно использованы в разных частях приложения, что повышает удобство поддержки и разработки кода.\nДекларативность:\nПозволяет описывать, как компоненты интерфейса выглядят в разных состояниях, автоматически обновляя их при изменении данных. Это делает код более читаемым и упрощает процесс разработки.\nВиртуальный DOM (VDOM):\nИспользует концепцию виртуального DOM для повышения производительности приложения. Виртуальный DOM — это легковесная копия реального DOM-дерева в памяти, позволяющая оптимизировать обновления интерфейса за счет минимизации взаимодействия с реальным DOM.\nОднонаправленный поток данных:\nВ нем данные передаются от родительских компонентов к дочерним через свойства (props), что обеспечивает предсказуемость и упрощает отладку приложений.\nИспользование React\nОн широко используется для разработки как небольших, так и крупных веб-приложений, предоставляя разработчикам мощные инструменты для создания интерактивных пользовательских интерфейсов. Он может быть использован как в одностраничных приложениях (SPA), так и в многостраничных сайтах.\nТакже лежит в основе таких проектов, как Gatsby (статический сайт-генератор) и Next.js (фреймворк для серверного и статического рендеринга), расширяя его возможности для разработки веб-приложений.\nЭкосистема\nВключает в себя не только саму библиотеку, но и множество связанных инструментов и библиотек, таких как:\nRedux/React Context\nдля управления глобальным состоянием приложения.\nReact Router\nдля навигации между страницами без перезагрузки.\nReact Native\nдля разработки кросс-платформенных мобильных приложений с использованием JavaScript и React.\nReact представляет собой мощный инструмент для разработки современных веб-и мобильных приложений, обладая большим сообществом и широким спектром инструментов для решения различных задач разработки пользовательских интерфейсов.',
    videos: [
      {
        url: "https://youtu.be/Y1SekvuZ3M4?t=1320",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 1320,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=2707",
        title: "Собеседование cтажера Frontend разра…",
        time: 2707,
      },
      {
        url: "https://youtu.be/OzLjBPjsGgg?t=2641",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 2641,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1739,
    question: "Что такое хук",
    explanation:
      'Хуки — это функции, которые позволяют "подключаться" к состоянию и жизненному циклу компонентов React из функциональных компонентов. Введение их предоставило мощный инструментарий для работы со состоянием, эффектами и другими возможностями React без необходимости преобразования функциональных компонентов в классы.\nОсновные хуки:\nuseState:\nПозволяет функциональным компонентам иметь состояние.\nconst [count, setCount] = useState(0);\nuseEffect:\nПозволяет выполнять побочные эффекты в компоненте, такие как обращения к API, подписки и т.д. Это аналог методов жизненного цикла\n`componentDidMount`\n,\n`componentDidUpdate`\n, и\n`componentWillUnmount`\nв классовых компонентах.\nuseEffect(() => {\n    document.title = `Вы нажали ${count} раз`;\n  }, [count]); // Эффект использует переменную состояния count\nuseContext:\nПозволяет получить доступ к данным из контекста. Это упрощает передачу данных через дерево компонентов без необходимости передавать props на каждом уровне.\nconst value = useContext(MyContext);\nuseReducer:\nПредоставляет альтернативный способ управления состоянием, основанный на паттерне редьюсер. Это особенно полезно для управления сложным состоянием.\nconst [state, dispatch] = useReducer(reducer, initialState);\nuseCallback:\nВозвращает мемоизированный колбэк, который изменяется только если изменяются зависимости. Это помогает предотвратить ненужные ререндеры.\nconst memoizedCallback = useCallback(() => {\n    doSomething(a, b);\n  }, [a, b]);\nuseMemo:\nМемоизирует вычисляемое значение. Это помогает избежать ненужных вычислений при каждом рендере.\nconst memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\nuseRef:\nВозвращает изменяемый ref объект, который может быть использован для хранения значения на протяжении всего жизненного цикла компонента.\nconst myRef = useRef(initialValue);\nЗачем они нужны:\nХуки были введены для решения нескольких проблем:\nУпрощение переиспользования логики состояния между компонентами без необходимости создавать высшие порядковые компоненты или рендер-пропсы.\nИспользование состояния и других возможностей React без написания классов.\nОрганизация логики внутри компонента по принципу использования, а не жизненного цикла.\nХуки предлагают более простой и мощный способ создания компонентов, делая код более читабельным и легко поддерживаемым.',
    videos: [
      {
        url: "https://youtu.be/Y1SekvuZ3M4?t=1712",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 1712,
      },
      {
        url: "https://youtu.be/cRqBsepPgoI?t=4392",
        title: "Собеседование frontend junior+ разра…",
        time: 4392,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=3406",
        title: "Собеседование cтажера Frontend разра…",
        time: 3406,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1742,
    question: "В чём отличие хранения данных в local storage от сессий",
    explanation:
      "Хранение данных в\n`localStorage`\nи\n`sessionStorage`\nявляется частью Web Storage API, предоставляемого современными веб-браузерами для сохранения данных на стороне клиента. Хотя оба механизма предназначены для хранения информации в формате ключ-значение и имеют похожий API, между ними есть ключевые отличия в поведении и области применения.\nlocalStorage\nДолгосрочное хранение:\nДанные, сохранённые в нем, остаются в браузере пользователя до тех пор, пока явно не будут удалены программно с помощью JavaScript или пользователем вручную. Это означает, что информация не исчезает после закрытия браузера или перезагрузки компьютера.\nОбъём данных:\nВ нем можно сохранять до 5-10 МБ данных (в зависимости от браузера), что делает его подходящим для хранения небольших объёмов информации.\nОграничения:\nДанные доступны только в пределах того же домена, что предотвращает доступ к данным для других сайтов.\nsessionStorage\nСеансовое хранение:\nон сохраняет данные только в течение сессии страницы — данные исчезают после закрытия вкладки или окна браузера. Это делает\n`sessionStorage`\nидеальным для хранения данных, актуальных в рамках одной сессии работы с веб-приложением, например, информации о состоянии интерфейса или введённых пользователями данных форм.\nОбъём данных:\nКак и\n`localStorage`\n, он обычно позволяет сохранять до 5-10 МБ данных.\nОграничения:\nДанные в нем доступны только в рамках одной вкладки браузера, и другие вкладки с тем же сайтом не будут иметь к ним доступ.\nОсновное отличие между\n`localStorage`\nи\n`sessionStorage`\nзаключается в продолжительности хранения данных и области их видимости.\n`localStorage`\nпредназначен для долгосрочного хранения данных, доступных между сессиями браузера и вкладками, тогда как\n`sessionStorage`\nпредоставляет механизм для хранения данных в течение одной сессии вкладки, что делает его более подходящим для временной информации, специфичной для конкретной сессии пользователя. Выбор между ними зависит от потребностей приложения в хранении данных на стороне клиента.",
    videos: [
      {
        url: "https://youtu.be/jf5TkGzWqiM?t=228",
        title: "Собеседование JUNIOR FRONTEND REACT …",
        time: 228,
      },
      {
        url: "https://youtu.be/gt-Glqr-1DM?t=1095",
        title: "Собеседование frontend junior+ разра…",
        time: 1095,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=2536",
        title: "Собеседование cтажера Frontend разра…",
        time: 2536,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1743,
    question: "Что такое css",
    explanation:
      "CSS (Cascading Style Sheets — каскадные таблицы стилей) — это язык, используемый для описания внешнего вида и форматирования документа, написанного на языке разметки (как правило, HTML или XML, включая такие разновидности, как SVG или XHTML). Он позволяет контролировать цвет, шрифт, расстояние между элементами, размер блоков, расположение элементов и многое другое для веб-страниц и приложений.\nОсновные принципы CSS:\nРазделение содержания и оформления:\nПозволяет отделить структуру документа от его внешнего вида. Это означает, что можно изменить внешний вид веб-сайта, не затрагивая его содержимое.\nКаскадность:\nСтили применяются в определённом порядке. Если одному и тому же элементу заданы стили через разные селекторы, браузер определяет приоритет правил согласно специфичности селекторов и порядку их определения.\nНаследование:\nНекоторые стили, заданные для родительского элемента, наследуются дочерними элементами, если только для дочерних элементов не заданы собственные стили.\nКак работает CSS:\nСелекторы:\nИспользует селекторы для определения, к каким элементам HTML применять стили. Селектор может указывать на тег, класс, идентификатор или даже на комбинацию этих и других атрибутов.\nДекларации:\nПосле выбора селектора указываются декларации стилей, которые состоят из свойств и их значений. Эти декларации обычно заключаются в фигурные скобки.\nПример:\np {\n  color: red;\n  font-size: 16px;\n}\nВ этом примере выбираются все параграфы (\n`p`\n), текст в которых будет окрашен в красный цвет (\n`color: red;`\n) и иметь размер шрифта 16 пикселей (\n`font-size: 16px;`\n).\nИспользование CSS:\nМожет быть подключен к HTML-документу тремя способами:\n1.\nВнешний стилевой файл:\nПравила хранятся в отдельном файле, который подключается к HTML-документу с помощью тега\n`<link>`\n.\n2.\nВнутренний стиль:\nПравила находятся непосредственно в HTML-документе внутри тега\n`<style>`\n.\n3.\nИнлайновые стили:\nСтили применяются непосредственно к HTML-элементу через атрибут\n`style`\n.\nCSS — это мощный инструмент для стилизации веб-страниц, который предоставляет разработчикам гибкие возможности для создания визуально привлекательных, адаптивных и доступных интерфейсов. Понимание и умение применять CSS является ключевым навыком для веб-разработчиков.",
    videos: [
      {
        url: "https://youtu.be/PLwrvZahiO4?t=164",
        title: "Собеседование на JavaScript разработ…",
        time: 164,
      },
      {
        url: "https://youtu.be/gt-Glqr-1DM?t=1276",
        title: "Собеседование frontend junior+ разра…",
        time: 1276,
      },
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=190s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 190,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1744,
    question: "Какие селекторы знаешь",
    explanation:
      'Существует множество типов селекторов, каждый из которых предназначен для выбора элементов на странице по определённому признаку. Вот основные виды:\nУниверсальный селектор\n`*`\n— выбирает все элементы на странице.\nСелекторы типов (тегов)\n`tagName`\n— выбирает все элементы данного типа (например,\n`div`\n,\n`p`\n).\nСелекторы классов\n`.className`\n— выбирает все элементы с указанным классом.\nСелекторы идентификаторов\n`#idName`\n— выбирает элемент с указанным идентификатором.\nСелекторы атрибутов\n`[attribute]`\n— выбирает все элементы с указанным атрибутом.\n`[attribute="value"]`\n— выбирает все элементы с указанным атрибутом и значением.\n`[attribute^="value"]`\n— выбирает все элементы, значение атрибута которых начинается с указанной строки.\n`[attribute$="value"]`\n— выбирает все элементы, значение атрибута которых заканчивается указанной строкой.\n`[attribute*="value"]`\n— выбирает все элементы, значение атрибута которых содержит указанную строку.\nСелекторы потомков и дочерних элементов\n`parent > child`\n— выбирает все дочерние элементы\n`child`,\nнепосредственно находящиеся внутри\n`parent`\n.\n`ancestor descendant`\n— выбирает все элементы\n`descendant`\n, находящиеся внутри\n`ancestor`\n(включая вложенные).\nСелекторы соседей и братьев\n`prev + next`\n— выбирает элемент\n`next`\n, непосредственно следующий за `prev`.\n`prev ~ siblings`\n— выбирает всех соседей\n`siblings`\n, которые следуют за\n`prev`\nна том же уровне вложенности.\nПсевдоклассы\n`:hover`\n— выбирает элемент при наведении курсора мыши.\n`:focus`\n— выбирает элемент, когда он находится в фокусе.\n`:nth-child(n)`\n— выбирает n-ый дочерний элемент.\n`:first-child`\nи\n`:last-child`\n— выбирают первый и последний дочерние элементы соответственно.\n`:not(selector)`\n— выбирает элементы, которые не соответствуют указанному селектору.\nПсевдоэлементы\n`::before`\nи\n`::after`\n— позволяют вставлять содержимое до или после содержимого элемента.\n`::first-letter`\nи\n`::first-line`\n— выбирают первую букву или первую строку текста элемента.\nЭти селекторы можно комбинировать для создания более сложных правил выбора элементов. Овладение различными типами селекторов позволяет гибко управлять стилизацией веб-страниц.',
    videos: [
      {
        url: "https://youtu.be/PLwrvZahiO4?t=192",
        title: "Собеседование на JavaScript разработ…",
        time: 192,
      },
      {
        url: "https://youtu.be/gt-Glqr-1DM?t=1470",
        title: "Собеседование frontend junior+ разра…",
        time: 1470,
      },
      {
        url: "https://youtu.be/cebz6w8o-fU?t=2705",
        title: "Public interview for Frontend/HTML/C…",
        time: 2705,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1745,
    question: "В чём разница между макро и микро задачами",
    explanation:
      "Существует понятие Event Loop (цикл событий), который отвечает за выполнение кода, сбор событий и обработку сообщений. В его контексте важную роль играют понятия макро- и микрозадач. Эти типы задач помогают понять, как обрабатываются асинхронные операции.\nМакрозадачи (Macro-tasks):\nЭто задачи, которые управляются циклом событий и выполняются одна за другой. Каждая такая задача выполняется в отдельном цикле, после чего выполняются все доступные микрозадачи.\nПримеры:\n`setTimeout`\n`setInterval`\n`setImmediate`\n(Node.js)\nЗапросы к серверу через\n`XMLHttpRequest`\nили\n`fetch`\n(не сам запрос, а обработка результата)\n`I/O`\nоперации (в Node.js)\nМикрозадачи (Micro-tasks):\nТакже управляются циклом событий, но они имеют более высокий приоритет, чем макрозадачи. Они выполняются сразу после завершения текущей исполняемой задачи и перед тем, как Event Loop перейдет к следующей макрозадаче. Это означает, что все они в очереди будут выполнены до начала выполнения следующей макрозадачи.\nПримеры:\n`Promise.then/catch/finally`\n`queueMicrotask`\n`MutationObserver`\nРазличия между макро и микрозадачами:\n1.\nПриоритет:\nМикрозадачи имеют более высокий приоритет по сравнению с макрозадачами. Все микрозадачи в очереди будут выполнены до начала следующего цикла Event Loop и до того, как будет взята новая макрозадача.\n2.\nВремя выполнения:\nМикрозадачи выполняются непосредственно после текущей задачи и перед тем, как браузер получит возможность перерисовать страницу или обработать другие события, такие как ввод пользователя. Макрозадачи же разделяются циклами Event Loop.\n3.\nИсточники:\nМакро- и микрозадачи поступают из разных источников. Например, таймеры (\n`setTimeout`\n,\n`setInterval`\n) и\n`I/O`\nоперации генерируют  макрозадачи, в то время как обработчики промисов (\n`then`\n,\n`catch`\n,\n`finally`\n) создают микрозадачи.\nПонимание разницы между макро- и микрозадачами критически важно для понимания того, как обрабатываются асинхронные операции, что позволяет разработчикам более эффективно управлять асинхронным кодом, избегать блокировок и создавать более отзывчивые приложения.",
    videos: [
      {
        url: "https://youtu.be/PLwrvZahiO4?t=1612",
        title: "Собеседование на JavaScript разработ…",
        time: 1612,
      },
      {
        url: "https://youtu.be/2zVAkqcUI4o?t=277",
        title: "СОБЕСЕДОВАНИЕ Middle FRONTEND разраб…",
        time: 277,
      },
      {
        url: "https://youtu.be/LcAQMKXpcqg?t=2234",
        title: "СОБЕСЕДОВАНИЕ JUNIOR FRONTEND РАЗРАБ…",
        time: 2234,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1746,
    question: "Что такое псевдоэлемент",
    explanation:
      'Псевдоэлементы — это специальный синтаксис, позволяющий стилизовать определенные части элемента или добавлять специальные элементы (как бы "элементы-призраки"), не создавая для этого дополнительные теги в HTML. Псевдоэлементы предоставляют удобный способ внесения изменений в структуру документа, не затрагивая HTML.\nСинтаксис:\nНачинается с двойного двоеточия (\n`::`\n), за которым следует название псевдоэлемента. Например,\n`::before`\nили\n`::after`\n.\nРаспространенные псевдоэлементы:\n`::before` и `::after`:\nПозволяют вставлять содержимое до или после содержимого выбранного элемента соответственно. Очень часто используются для добавления декоративных элементов.\np::before {\n    content: "«";\n    color: blue;\n  }\n  \n  p::after {\n    content: "»";\n    color: blue;\n  }\n`::first-line`:\nПрименяет стили к первой строке текста в блочном элементе.\np::first-line {\n    font-weight: bold;\n  }\n`::first-letter`:\nПрименяет стили к первой букве текста в блочном элементе.\np::first-letter {\n    font-size: 200%;\n  }\n`::selection`:\nПрименяет стили к части текста, которую пользователь выделил.\np::selection {\n    background: yellow;\n  }\nОсобенности работы:\nРаботают как часть документа, но на самом деле не существуют в DOM-дереве, а создаются стилями.\nЧтобы псевдоэлементы\n`::before`\nи\n`::after`\nотображались, необходимо задать свойство\n`content`\n, даже если оно пустое (\n`content: "";`\n).\nМогут быть стилизованы почти так же, как обычные элементы, но есть некоторые ограничения, например, связанные с взаимодействием с JavaScript.\nУдобны для добавления декоративных элементов, создания специальных эффектов при взаимодействии с текстом и элементами страницы, а также для улучшения пользовательского интерфейса без изменения HTML-кода. Они позволяют сделать дизайн более гибким и интересным, облегчая поддержку и обновление стилей.',
    videos: [
      {
        url: "https://youtu.be/hDl7w9U-Ly8?t=644",
        title: "Собеседование на Junior Frontend раз…",
        time: 644,
      },
      {
        url: "https://www.youtube.com/watch?v=qika0TkDFz4&t=3350s",
        title: "#7 Первое собеседование Junior Front…",
        time: 3350,
      },
      {
        url: "https://youtu.be/IvJIuPkzEns?t=264",
        title: "Реальное Собеседование JavaScript Ра…",
        time: 264,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1747,
    question: "Что приоритетнее использовать ts или js",
    explanation:
      "Выбор между TypeScript (TS) и JavaScript (JS) зависит от конкретных требований, предпочтений и специфики задачи. Оба языка имеют свои преимущества и недостатки, и решение о том, какой из них использовать, следует принимать, исходя из нескольких ключевых факторов.\nTypeScript\nПреимущества:\nСтатическая типизация:\nПредоставляет строгую типизацию, что помогает обнаруживать ошибки на этапе компиляции, ещё до выполнения кода. Это может значительно уменьшить количество ошибок в продакшене.\nПоддержка последних возможностей JavaScript:\nКомпилируется в чистый JS, что позволяет использовать последние возможности языка, не беспокоясь о совместимости с браузерами.\nИнструменты разработки:\nУлучшенная поддержка в IDE для автодополнения кода, рефакторинга и навигации по проекту.\nМасштабируемость:\nЛучше подходит для больших проектов благодаря возможности определения интерфейсов, типов и обобщений.\nНедостатки:\nКривая обучения:\nНеобходимо время на изучение синтаксиса и особенностейt.\nВремя на настройку:\nНастройка проекта на нем может потребовать дополнительного времени и усилий, особенно в существующих больших проектах.\nСкорость сборки:\nПроекты на нем могут компилироваться дольше, чем чистый JS, из-за процесса типизации.\nJavaScript\nПреимущества:\nГибкость:\nОчень гибкий язык, позволяющий разработчикам быстро прототипировать и реализовывать решения.\nШирокая поддержка:\nПоддерживается всеми современными браузерами без необходимости компиляции.\nБольшое сообщество:\nОгромное количество ресурсов, библиотек и фреймворков доступно для него.\nПростота использования:\nДля начала работы с ним не требуется сложная настройка среды разработки.\nНедостатки:\nДинамическая типизация:\nМожет привести к ошибкам во время выполнения, которые сложно обнаружить на этапе разработки.\nМасштабируемость:\nУправление большими проектами может стать сложнее без строгой системы типов.\nИспользуйте TypeScript\n, если вы работаете над крупным проектом с большой командой разработчиков, где масштабируемость и поддерживаемость кода являются ключевыми. Он также предпочтительнее, если вам нужна строгая типизация для улучшения качества кода и уменьшения количества ошибок.\nИспользуйте JavaScript\n, если вы работаете над меньшим проектом, прототипом или когда скорость разработки критична. JavaScript может быть также предпочтительным выбором для новичков, которые только начинают изучать разработку веб-приложений, благодаря его непосредственной поддержке в браузерах и большому количеству обучающих материалов.",
    videos: [
      {
        url: "https://youtu.be/hDl7w9U-Ly8?t=698",
        title: "Собеседование на Junior Frontend раз…",
        time: 698,
      },
      {
        url: "https://youtu.be/ZEKcJgVI-YM?t=2612",
        title: "Талант в 18 лет? Собеседование #2 fr…",
        time: 2612,
      },
      {
        url: "https://youtu.be/cRqBsepPgoI?t=2709",
        title: "Собеседование frontend junior+ разра…",
        time: 2709,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1748,
    question: "Какие задачи решал на работе",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/VzorPrTjUII?t=78",
        title: "Middle за год? Собеседование #3 fron…",
        time: 78,
      },
      {
        url: "https://youtu.be/B1IbTKdgCeE?t=186",
        title: "Крушитель алгоритмов? Собеседование …",
        time: 186,
      },
      {
        url: "https://youtu.be/JOdMvE8S_ds?t=1144",
        title: "Успешное Собеседование Javascript Mi…",
        time: 1144,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1749,
    question: "Что такое iife",
    explanation:
      "IIFE (Immediately Invoked Function Expression) — это шаблон проектирования, который представляет собой функцию, немедленно вызываемую после её определения. Это позволяет создавать новую область видимости и изолировать переменные внутри функции от глобального объекта, тем самым предотвращая загрязнение глобального пространства имен.\nСтруктура:\n(function() {\n  // Тело функции\n})();\nИли с использованием стрелочной функции:\n(() => {\n  // Тело функции\n})();\nПример:\n(function() {\n  var localVar = 'Я локальная переменная';\n  console.log(localVar); // Вывод: Я локальная переменная\n})();\nconsole.log(typeof localVar); // Вывод: undefined\nВ этом примере переменная\n`localVar`\nопределена внутри него и не доступна за её пределами, что демонстрирует изоляцию переменных от глобального пространства имен.\nПочему это полезно:\n1.\nИзоляция:\nПеременные, объявленные внутри этого шаблона, не засоряют глобальное пространство имен и не конфликтуют с другими переменными с тем же именем.\n2.\nПриватность:\nСоздаёт приватную область видимости для переменных и функций, что позволяет скрыть реализацию деталей и сохранить данные и функции недоступными извне.\n3.\nНемедленное выполнение:\nКод внутри него выполняется немедленно, что удобно для инициализации функциональности или создания модулей.\n4.\nУправление глобальным объектом:\nМожет использоваться для передачи глобального объекта (например,\n`window`\nв браузерах) в качестве параметра, что обеспечивает удобный доступ к глобальным переменным и функциям без прямого обращения к глобальному объекту.\nIIFE — это полезный инструмент для обеспечения приватности, изоляции переменных и немедленного выполнения кода. Этот паттерн особенно актуален в условиях, когда необходимо избежать конфликтов имен и защитить переменные и функции от внешнего доступа.",
    videos: [
      {
        url: "https://youtu.be/VzorPrTjUII?t=561",
        title: "Middle за год? Собеседование #3 fron…",
        time: 561,
      },
      {
        url: "https://youtu.be/ZEKcJgVI-YM?t=374",
        title: "Талант в 18 лет? Собеседование #2 fr…",
        time: 374,
      },
      {
        url: "https://www.youtube.com/watch?v=BOCkaqdbdCg&t=2413s",
        title: "Собеседование на Junior Frontend раз…",
        time: 2413,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1750,
    question: "Что такое git-flow",
    explanation:
      'ACID — это акроним, обозначающий четыре ключевых свойства, которые гарантируют надежную обработку транзакций в базах данных. Эти свойства включают:\n1.\nАтомарность (Atomicity):\nЭто свойство гарантирует, что каждая транзакция в базе данных рассматривается как единое целое, где либо все операции в транзакции выполняются полностью, либо не выполняются вовсе. Если какая-либо часть транзакции не удается выполнить, вся транзакция откатывается (отменяется), и состояние данных остается таким, как если бы транзакция не выполнялась вовсе.\nПример: Если вы переводите деньги с одного счета на другой, атомарность гарантирует, что оба шага (списание с одного счета и зачисление на другой) будут выполнены вместе. Если один из шагов не может быть выполнен, ни один из них не будет выполнен.\n2.\nСогласованность (Consistency):\nЭто свойство обеспечивает, что транзакция переводит базу данных из одного согласованного состояния в другое. Она гарантирует, что выполнение транзакции не нарушает никаких ограничений базы данных и что все данные остаются валидными после выполнения транзакции.\nПример: Если в вашей банковской системе существует правило, что баланс счета не может быть отрицательным, транзакция, которая пытается увести счет в отрицательный баланс, будет отклонена, чтобы сохранить согласованность данных.\n3.\nИзолированность (Isolation):\nЭто свойство обеспечивает, что транзакции выполняются независимо друг от друга и изменения, вносимые одной транзакцией, не видны другим транзакциям до их завершения. Она предотвращает проблемы, такие как "грязное чтение" или "потерянные обновления", которые могут возникнуть при одновременном выполнении нескольких транзакций.\nПример: Если два пользователя одновременно пытаются обновить один и тот же банковский счет, изолированность гарантирует, что каждая транзакция будет видеть счет таким, каким он был до начала любых обновлений, предотвращая перезапись изменений друг друга.\n4.\nДолговечность (Durability):\nЭто свойство гарантирует, что однажды успешно завершенная транзакция будет сохранена постоянно, даже в случае сбоя системы. Данные не теряются после подтверждения транзакции.\nПример: После того как операция по переводу денег между счетами подтверждена и завершена, эти изменения не будут потеряны, даже если система внезапно выйдет из строя.\nACID — это набор свойств, которые обеспечивают надежность и стабильность работы с транзакциями в базах данных. Атомарность гарантирует выполнение всех шагов транзакции целиком или их полный отказ, Согласованность поддерживает целостность данных, Изолированность обеспечивает независимость параллельных транзакций, а Долговечность гарантирует сохранение результатов транзакции после ее завершения. Эти свойства важны для обеспечения того, чтобы базы данных были надежными и безопасными для выполнения транзакций.',
    videos: [
      {
        url: "https://youtu.be/VzorPrTjUII?t=1564",
        title: "Middle за год? Собеседование #3 fron…",
        time: 1564,
      },
      {
        url: "https://youtu.be/YwRgLQ0SoKk?t=4617",
        title: "Собеседование frontend разработчика",
        time: 4617,
      },
      {
        url: "https://www.youtube.com/watch?v=qGdV5YOmtrs&t=2185s",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 2185,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1751,
    question: "Расскажи о map и set",
    explanation:
      "`Map`\nи\n`Set`\n— это структуры данных, введённые в ES6 (ECMAScript 2015), которые расширяют возможности стандартных объектов и массивов, предоставляя более специализированные и гибкие способы хранения данных.\nMap\nЭто коллекция ключ/значение, где ключи могут быть любого типа, в отличие от объектов, где ключи могут быть только строками или символами. Он сохраняет порядок вставки элементов, что означает, что данные итерируются в том порядке, в котором они были добавлены.\nОсновные методы:\n`new Map()`\n— создаёт новую коллекцию.\n`map.set(key, value)`\n— устанавливает значение\n`value`\nдля ключа\n`key`\n.\n`map.get(key)`\n— возвращает значение, ассоциированное с ключом\n`key`\n.\n`map.has(key)`\n— возвращает\n`true`\n, если\n`key`\nсуществует в коллекции.\n`map.delete(key)`\n— удаляет элемент по ключу\n`key`\n.\n`map.clear()`\n— удаляет все элементы из коллекции.\n`map.size`\n— возвращает количество элементов в коллекции.\nlet map = new Map();\nmap.set('1', 'str1');    // строка в качестве ключа\nmap.set(1, 'num1');      // цифра как ключ\nmap.set(true, 'bool1');  // булево значение как ключ\nconsole.log(map.get(1)); // num1\nconsole.log(map.get('1')); // str1\nconsole.log(map.size); // 3\nSet\nЭто коллекция, которая хранит только уникальные значения без ключей (или, можно сказать, где значение одновременно и есть ключ). Как и\n`Map`\n, он сохраняет порядок вставки элементов.\nОсновные методы:\n`new Set()`\n— создаёт новую коллекцию.\n`set.add(value)`\n— добавляет значение\n`value`\nв коллекцию, если его там ещё нет.\n`set.delete(value)`\n— удаляет значение\n`value`\nиз коллекции.\n`set.has(value)`\n— возвращает\n`true`\n, если значение\n`value`\nприсутствует в коллекции.\n`set.clear()`\n— удаляет все элементы из коллекции.\n`set.size`\n— возвращает количество элементов в коллекции.\nlet set = new Set();\nlet john = { name: \"John\" };\nlet pete = { name: \"Pete\" };\nlet mary = { name: \"Mary\" };\n// посещения, некоторые пользователи заходят многократно\nset.add(john);\nset.add(pete);\nset.add(mary);\nset.add(john);\nset.add(mary);\nconsole.log(set.size); // 3\nfor (let user of set) {\n  console.log(user.name); // John, Pete, Mary\n}\n`Map`\nи\n`Set`\nпредставляют собой мощные структуры данных, которые делают код более чистым и читаемым, а также предоставляют удобные методы для работы с данными.\n`Map`\nидеально подходит для хранения пар ключ/значение с уникальными ключами, в то время как\n`Set`\nиспользуется для хранения уникальных значений.",
    videos: [
      {
        url: "https://youtu.be/ZEKcJgVI-YM?t=1097",
        title: "Талант в 18 лет? Собеседование #2 fr…",
        time: 1097,
      },
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=2149",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 2149,
      },
      {
        url: "https://www.youtube.com/watch?v=k0dAETyBPvU&t=1605s",
        title: "#8 Маркетолог ушел на фронт. Собесед…",
        time: 1605,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1752,
    question: "Что означает слово каскад в css",
    explanation:
      'Слово "каскад" относится к системе приоритетов, которая определяет, какие стили будут применены к HTML-элементам в случае конфликта. Эта система позволяет управлять стилем документа на нескольких уровнях, начиная от браузерных стилей по умолчанию до пользовательских стилей.\nОсновные аспекты каскадности в CSS:\n1.\nПриоритеты источников стилей:\nПозволяет стилизовать элементы с помощью различных источников стилей (браузерные стили по умолчанию, стили пользователя, стили автора веб-страницы). Каскад определяет порядок, в котором эти стили объединяются и применяются, придавая приоритет одним стилям над другими.\n2.\nСпецифичность селекторов:\nВ случае, если на один и тот же элемент применяются различные стили от разных селекторов, специфичность селектора определяет, какие стили будут применены. Специфичность измеряется на основе типа селектора (например, селекторы тегов, классов, идентификаторов имеют разный "вес").\n3.\nВажность (Importance):\nСвойство, объявленное как\n`!important`\n, имеет наивысший приоритет независимо от специфичности селектора. Использование\n`!important`\nследует минимизировать, поскольку это может затруднить дальнейшее управление стилями.\n4.\nПорядок объявления:\nЕсли два стиля имеют одинаковую специфичность, то применяется стиль, который объявлен последним в коде. Это означает, что порядок, в котором стили объявлены в CSS-файле или в документе, также влияет на итоговый вид элемента.\nПример:\n/* Браузерный стиль по умолчанию */\np {\n  color: black;\n}\n/* Стиль пользователя */\np {\n  color: blue;\n}\n/* Стиль автора */\np {\n  color: green;\n}\n/* Специфичный селектор имеет больший приоритет */\n.special-p {\n  color: red;\n}\n/* Использование !important */\np {\n  color: purple !important;\n}\nВ этом примере, несмотря на то что для параграфов (\n`p`\n) заданы разные цвета, применится цвет\n`purple`\n, так как он объявлен с использованием\n`!important`\n. Однако для параграфа с классом\n`.special-p`\nцвет будет\n`red`\n, поскольку специфичность селектора\n`.special-p`\nвыше, чем у простого тегового селектора\n`p`\n, и\n`!important`\nне влияет на селекторы с более высокой специфичностью, если они объявлены после.\nКаскад в CSS позволяет разработчикам эффективно управлять стилями, определяя, какие правила будут применены к элементам в случае конфликтов. Понимание механизма каскадности помогает создавать предсказуемые и управляемые стили для веб-страниц.',
    videos: [
      {
        url: "https://youtu.be/gt-Glqr-1DM?t=1278",
        title: "Собеседование frontend junior+ разра…",
        time: 1278,
      },
      {
        url: "https://youtu.be/cRqBsepPgoI?t=1289",
        title: "Собеседование frontend junior+ разра…",
        time: 1289,
      },
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=840s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 840,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1753,
    question: "Как работает наследование в css",
    explanation:
      'Наследование — это механизм, с помощью которого элементы веб-страницы могут наследовать стилевые свойства от своих родительских элементов. Не все свойства наследуются, но многие из тех, которые влияют на текст, такие как\n`color`\n,\n`font-family`\n,\n`font-size`\n, являются такими. Это значит, что если вы установите одно из этих свойств для элемента, то оно автоматически применится ко всем его дочерним элементам, если только для них явно не заданы свои значения этих свойств.\nКак это работает\nКогда браузер рендерит страницу и применяет стили, он проверяет, задано ли для конкретного элемента свойство. Если свойство не задано, браузер проверяет, является ли это свойство наследуемым. Если да, то элемент наследует значение этого свойства от своего родителя. Процесс продолжается вверх по дереву элементов до тех пор, пока не будет найдено заданное значение свойства или не будет достигнут корневой элемент документа (\n`html`\n). Если и у корневого элемента свойство не задано, используется значение по умолчанию, определенное в спецификации.\nПример:\n<!DOCTYPE html>\n<html>\n<head>\n    <style>\n        body {\n            color: blue; /* Все текстовые элементы внутри body будут синими, если только не задано иное */\n            font-family: Arial, sans-serif; /* Все текстовые элементы наследуют этот шрифт */\n        }\n    </style>\n</head>\n<body>\n<p>Этот текст будет синим и Arial, потому что он наследует стили от body.</p>\n<div style="color: green;">\n    <p>Этот текст будет зеленым и Arial, потому что цвет переопределен на зеленый, а шрифт наследуется от body.</p>\n</div>\n</body>\n</html>\nСпособы контроля\nЯвное задание свойств:\nВы можете явно задать свойства для элемента, переопределив наследуемые значения.\nИспользование `inherit`:\nЗначение\n`inherit`\nможно присвоить любому CSS-свойству, чтобы указать элементу наследовать значение этого свойства от своего родителя, даже если это свойство обычно не наследуется.\nИспользование `initial`:\nСбрасывает свойство к его значению по умолчанию, игнорируя наследование.\nИспользование `unset`:\nДействует как\n`inherit`\n, если свойство наследуемое, и как\n`initial`\nв противном случае.\nНаследование позволяет упростить стилизацию веб-страниц, автоматически применяя набор стилевых свойств к дочерним элементам от их родителей. Понимание механизма наследования помогает создавать более чистый и эффективный код, избегая необходимости повторения стилей для каждого элемента.',
    videos: [
      {
        url: "https://youtu.be/gt-Glqr-1DM?t=1382",
        title: "Собеседование frontend junior+ разра…",
        time: 1382,
      },
      {
        url: "https://youtu.be/cRqBsepPgoI?t=1313",
        title: "Собеседование frontend junior+ разра…",
        time: 1313,
      },
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=882s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 882,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1754,
    question: "Какие основные используемые теги в html знаешь",
    explanation:
      "HTML (HyperText Markup Language) использует множество тегов для структурирования веб-страниц. Вот некоторые из наиболее часто используемых тегов и их назначение:\nСтруктурные и семантические:\n`<!DOCTYPE>`:\nОпределяет тип документа и версию HTML.\n`<html>`:\nКорневой элемент веб-страницы.\n`<head>`:\nСодержит метаинформацию о документе, такую как заголовок, ссылки на стили и скрипты.\n`<title>`:\nЗадаёт заголовок веб-страницы, отображаемый в заголовке вкладки браузера.\n`<body>`:\nСодержит всё содержимое веб-страницы, видимое пользователю.\n`<header>`:\nОпределяет заголовок веб-страницы или раздела.\n`<footer>`:\nОпределяет подвал веб-страницы или раздела.\n`<nav>`:\nОпределяет навигационные ссылки.\n`<article>`:\nОпределяет независимый контент.\n`<section>`:\nОпределяет раздел в документе.\n`<aside>`:\nОпределяет контент, отделённый от основного содержимого (как правило, боковые панели).\nТекстовые и форматирующие:\n`<h1>` - `<h6>`:\nЗаголовки разного уровня, где\n`<h1>`\n— самый важный заголовок.\n`<p>`:\nОпределяет абзац.\n`<br>`:\nПеренос строки.\n`<strong>`:\nВыделяет текст жирным шрифтом.\n`<em>`:\nВыделяет текст курсивом.\n`<blockquote>`:\nЦитата.\n`<ol>`:\nНумерованный список.\n`<ul>`:\nМаркированный список.\n`<li>`:\nЭлемент списка.\n`<a>`:\nГиперссылка.\n`<img>`:\nИзображение.\n`<figure>` и `<figcaption>`:\nИспользуются для вставки изображений или иллюстраций с подписями.\nДля работы с формами:\n`<form>`:\nОпределяет форму для сбора пользовательского ввода.\n`<input>`:\nПоле ввода.\n`<textarea>`:\nМногострочное поле ввода текста.\n`<button>`:\nКнопка.\n`<select>` и `<option>`:\nВыпадающий список и его элементы.\n`\n<label>`:\nМетка для элемента формы.\nДля работы с таблицами:\n`<table>`:\nТаблица.\n`<tr>`:\nСтрока таблицы.\n`<td>`:\nЯчейка таблицы.\n`<th>`:\nЗаголовочная ячейка таблицы.\n`<thead>`, `<tbody>`, `<tfoot>`:\nГруппируют заголовки, основное тело и подвал таблицы соответственно.\nСпециальные и мультимедийные:\n`<video>` и `<audio>`:\nДля встраивания видео и аудио контента.\n`<canvas>`:\nИспользуется для рисования графики с помощью JavaScript.\n`<svg>`:\nДля встраивания векторной графики.\nЭто лишь основные теги. Существует много других тегов и атрибутов, которые предоставляют дополнительные возможности для разработки веб-страниц.",
    videos: [
      {
        url: "https://youtu.be/cRqBsepPgoI?t=997",
        title: "Собеседование frontend junior+ разра…",
        time: 997,
      },
      {
        url: "https://youtu.be/BonLyarPpqE?t=1386",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 1386,
      },
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=324s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 324,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1755,
    question: "Что такое чистая функция",
    explanation:
      "Чистая функция — это концепция, особенно популярная в функциональном программировании, которая описывает функцию, обладающую следующими характеристиками:\n1.\nДетерминированность:\nВозвращаемое значение зависит только от её входных параметров и не изменяется при повторных вызовах с теми же параметрами. Это означает, что функция всегда возвращает один и тот же результат при одинаковых входных данных, не обращаясь при этом к внешним состояниям или данным.\n2.\nОтсутствие побочных эффектов:\nНе вызывает побочных эффектов в приложении, то есть не изменяет состояние программы или внешнего окружения (например, не изменяет глобальные переменные, не записывает данные на диск, не выводит информацию на экран и т.д.). Все, что делает чистая функция — это обрабатывает входные данные и возвращает результат.\nПример:\nfunction add(a, b) {\n  return a + b;\n}\nФункция\n`add`\nявляется чистой, потому что она всегда возвращает одно и то же значение для одних и тех же аргументов и не имеет побочных эффектов.\nПример нечистой функции:\nlet counter = 0;\nfunction incrementCounter(value) {\n  counter += value;\n}\nФункция\n`incrementCounter`\nне является чистой, так как она изменяет глобальную переменную\n`counter`\n, что является побочным эффектом. Также результат выполнения функции зависит от внешнего состояния (значения\n`counter`\n), что нарушает принцип детерминированности.\nПреимущества чистых функций:\nПростота тестирования:\nЛегко тестировать, так как их поведение зависит только от входных данных.\nПредсказуемость:\nОтсутствие побочных эффектов и зависимость только от входных параметров делает поведение их предсказуемым.\nПовторное использование:\nМогут быть легко переиспользованы в различных частях программы.\nМодульность:\nПрограммы, построенные с использованием их, обычно обладают высокой модульностью и легкостью в поддержке и расширении.\nЧистые функции являются основой функционального программирования и способствуют написанию более чистого, понятного и управляемого кода.",
    videos: [
      {
        url: "https://youtu.be/cRqBsepPgoI?t=5281",
        title: "Собеседование frontend junior+ разра…",
        time: 5281,
      },
      {
        url: "https://youtu.be/EaTZXKlpsj0?t=5912",
        title: "#11 Фронтендер в 17 лет? Собеседован…",
        time: 5912,
      },
      {
        url: "https://www.youtube.com/watch?v=3D0IVhYzXJM&t=515s",
        title: "#2 Собеседование смелого Frontend Mi…",
        time: 515,
      },
    ],
    rating: 10,
    image: null,
  },
  {
    id: 1767,
    question: "Что знаешь о примитивных типах данных в javascript",
    explanation:
      'Примитивные типы данных — это данные, которые не являются объектами и не имеют методов. Всего существует семь типов:\n1.\nString (Строка):\nПредставляет собой последовательность символов, используется для работы с текстом. Пример:\n`"Привет, мир!"`\n.\n2.\nNumber (Число):\nПредставляет собой числовое значение. Числа могут быть как целыми, так и с плавающей точкой. Примеры:\n`42`\n,\n`3.14`\n. Включает в себя специальные числовые значения, такие как\n`Infinity`\n,\n`-Infinity`\nи\n`NaN`\n(Not-a-Number — результат некорректной математической операции).\n3.\nBigInt:\nПредставляет целые числа произвольной длины. Был введен для работы с числами, размер которых превышает пределы\n`Number`\n. Пример:\n`9007199254740991n`\n.\n4.\nBoolean (Логический тип):\nИмеет два значения:\n`true`\n(истина) и\n`false`\n(ложь), используется для логических операций.\n5.\nundefined:\nОбозначает отсутствие значения. Переменная, которой не было присвоено значение, автоматически получает значение\n`undefined`\n.\n6.\nnull:\nТакже обозначает отсутствие значения. В отличие от\n`undefined`\n,\n`null`\nобычно присваивается переменной явно в качестве индикатора того, что значение отсутствует.\n7.\nSymbol:\nПредставляет уникальный и неизменяемый идентификатор, часто используется для создания уникальных ключей объектов. Каждый созданный `\nSymbol`\nгарантированно уникален.\nОсобенности примитивных типов\nНеизменяемость: Значения не могут быть изменены. Операции над примитивными значениями возвращают новые значения, но не изменяют исходные.\nСравнение по значению: Сравниваются по значению. Два значения считаются равными, если они имеют одинаковый тип и значение.\nПреобразование типов: Автоматически преобразует примитивные типы данных при необходимости (например, при арифметических операциях или конкатенации строк).\nРабота с примитивными типами\nХотя они и не имеют методов, позволяет временно оборачивать их в объекты-обертки (например,\n`new String()`\n,\n`new Number()`\n,\n`new Boolean()`\n), чтобы предоставить доступ к различным методам и свойствам, таким как\n`.length`\nдля строк или\n`.toFixed()`\nдля чисел. Однако это редко используется на практике, поскольку примитивные значения и так автоматически преобразуются в объекты при доступе к их свойствам или методам.\nПримитивные типы данных являются основой для создания более сложных структур данных и логики.',
    videos: [
      {
        url: "https://youtu.be/N1gKaF6BhDc?t=684",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 684,
      },
      {
        url: "https://youtu.be/xGyI3uOXRjY?t=571",
        title: "Tech Interview Fest | Пробное собесе…",
        time: 571,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1768,
    question: "Расскажи про замыкание",
    explanation:
      "Замыкание — это мощная концепция, которая позволяет функции доступ к переменным из области видимости, в которой она была создана, даже после того, как эта область видимости становится недоступной. Это один из ключевых механизмов языка, и понимание замыканий необходимо для эффективной работы, особенно при работе с асинхронным кодом, обработчиками событий и функциями высшего порядка.\nКак они работают\nКогда функция объявляется, она замыкает в себе переменные из своей лексической области видимости. Это означает, что функция сохраняет доступ к переменным из области, в которой она была создана, даже если эта область выполнения уже завершила свою работу.\nfunction создатьФункциюПриветствия(имя) {\n  var приветствие = 'Привет';\n  return function() {\n    console.log(приветствие + ', ' + имя);\n  };\n}\nvar приветАлиса = создатьФункциюПриветствия('Алиса');\nприветАлиса(); // Выводит: \"Привет, Алиса\"\nВ этом примере\n`приветАлиса`\nявляется функцией, замыкающей в себе переменные\n`приветствие`\nи\n`имя`\nиз области видимости функции\n`создатьФункциюПриветствия`\n, даже после того, как выполнение функции\n`создатьФункциюПриветствия`\nзавершено.\nЗачем нужны замыкания\n1.\nИнкапсуляция данных:\nПозволяют скрывать переменные внутри функции, делая их недоступными извне, что способствует созданию приватных переменных и методов.\n2.\nСоздание функций с привязанными параметрами:\nМогут использоваться для создания новых функций на основе существующих, но с заранее заданными или \"зафиксированными\" аргументами.\n3.\nРабота с асинхронным кодом:\nЧасто используются в обработчиках событий и колбэках для доступа к переменным из внешней области видимости.\n4.\nМодульность и управление состоянием:\nПозволяют создавать модули и фабрики функций, которые могут иметь собственное внутреннее состояние, недоступное напрямую извне.\nВажные моменты\nЗамыкания могут привести к утечкам памяти, если они неправильно используются, особенно в старых браузерах. Современные движки обладают сборщиками мусора, которые минимизируют эту проблему.\nПонимание замыканий необходимо для глубокого освоения, поскольку они используются во многих шаблонах и библиотеках.\nЗамыкания являются одной из фундаментальных концепций, обеспечивающей гибкость и мощь при работе с функциями и асинхронным кодом.",
    videos: [
      {
        url: "https://youtu.be/xGyI3uOXRjY?t=1827",
        title: "Tech Interview Fest | Пробное собесе…",
        time: 1827,
      },
      {
        url: "https://youtu.be/ScRTey_dvhI?t=1966",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 1966,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1769,
    question: "Зачем используется директива usestate",
    explanation:
      "Директива\n`useState`\nявляется одним из хуков, который позволяет добавлять состояние к функциональным компонентам. В предыдущих версиях React для управления состоянием можно было использовать только классовые компоненты. Однако с введением хуков в React 16.8, функциональные компоненты получили возможность использовать состояние и другие возможности React, аналогичные классовым компонентам.\nКак работает `useState`\nПринимает начальное значение состояния как аргумент и возвращает массив из двух элементов: текущее значение состояния и функцию для его обновления. Это позволяет компоненту реагировать на изменения данных и перерисовываться с новыми значениями.\nimport React, { useState } from 'react';\nfunction Counter() {\n  // Объявляем новую переменную состояния \"count\"\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>Вы кликнули {count} раз</p>\n      <button onClick={() => setCount(count + 1)}>\n        Кликни меня\n      </button>\n    </div>\n  );\n}\nВ этом примере он используется для отслеживания количества кликов по кнопке. Компонент `Counter` хранит значение счетчика в\n`count`\nи обновляет его при помощи функции\n`setCount`\n, когда пользователь нажимает на кнопку.\nЗачем использовать `useState`\n1.\nУпрощение кода:\nФункциональные компоненты с хуками часто более лаконичны и проще для понимания, чем классовые компоненты.\n2.\nПереиспользование логики состояния:\nХуки позволяют легко переиспользовать логику управления состоянием между компонентами без необходимости создавать высшие компоненты (HOC) или использовать рендер-пропы.\n3.\nРазделение ответственности:\nОн и другие хуки позволяют разделять различные аспекты логики компонента (например, управление состоянием, эффекты, контекст) на мелкие, независимые блоки кода.\n4.\nУлучшение производительности:\nФункциональные компоненты могут быть меньше и быстрее, чем классовые, особенно когда используется правильное разделение логики на хуки.\nИспользование\n`useState`\nделает компоненты React более модульными и удобными, а также облегчает управление состоянием в приложениях.",
    videos: [
      {
        url: "https://youtu.be/xGyI3uOXRjY?t=1967",
        title: "Tech Interview Fest | Пробное собесе…",
        time: 1967,
      },
      {
        url: "https://youtu.be/gV6eobXisYU?t=1358",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 1358,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1770,
    question: "Расскажи про компоненты в react",
    explanation:
      'Компоненты являются основными строительными блоками для построения пользовательских интерфейсов. Они позволяют разбивать интерфейс на независимые, переиспользуемые части, которые можно разрабатывать, тестировать и поддерживать отдельно друг от друга. Компоненты в React могут быть как простыми и представлять собой один элемент интерфейса (например, кнопку или поле ввода), так и сложными и включать в себя другие компоненты, формируя иерархию.\nТипы:\n1.\nФункциональные компоненты:\nСамый простой способ определить компонент.\nЭто JavaScript-функции, которые принимают пропсы (свойства) в качестве аргумента и возвращают элемент, описывающий, что должно отображаться на экране.\nС появлением хуков, функциональные компоненты получили возможность использовать состояние и другие возможности React, аналогичные классовым компонентам.\nfunction Welcome(props) {\n     return <h1>Привет, {props.name}</h1>;\n   }\n2.\nКлассовые компоненты:\nПеред введением хуков классовые компоненты были единственным способом использования состояния и жизненного цикла компонентов .\nОни определяются путем расширения\n`React.Component`\nи требуют метода\n`render()`\n, который возвращает элемент React.\nclass Welcome extends React.Component {\n     render() {\n       return <h1>Привет, {this.props.name}</h1>;\n     }\n   }\nПропсы и состояние\nПропсы (Props):\nКоротко для "свойств", пропсы передаются от родительских компонентов к дочерним. Они неизменяемы в пределах компонента, что означает, что дочерний компонент не может изменять пропсы, полученные от родителя.\nСостояние (State):\nСостояние позволяет компонентам реагировать на ввод пользователя, серверные запросы и любые другие действия, сохраняя и изменяя данные во времени. В отличие от пропсов, состояние управляется и изменяется внутри самого компонента.\nЖизненный цикл компонента\nКлассовые компоненты имеют несколько "жизненных циклов" — методов, которые автоматически вызываются в разные моменты жизни компонента, такие как монтирование (компонент вставляется в DOM), обновление (компонент реагирует на изменения пропсов или состояния) и размонтирование (компонент удаляется из DOM). Хуки позволяют использовать аналогичные возможности в функциональных компонентах.\nКомпоненты обеспечивают эффективный способ организации пользовательского интерфейса, делая код более читабельным, легким для тестирования и поддержки. Они позволяют разработчикам строить сложные приложения из простых частей, облегчая разработку и обеспечивая лучший пользовательский опыт.',
    videos: [
      {
        url: "https://youtu.be/YwRgLQ0SoKk?t=3905",
        title: "Собеседование frontend разработчика",
        time: 3905,
      },
      {
        url: "https://youtu.be/xGyI3uOXRjY?t=2343",
        title: "Tech Interview Fest | Пробное собесе…",
        time: 2343,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1771,
    question: "Перечисли методы life cycle",
    explanation:
      "Жизненный цикл компонента описывает серию событий, которые происходят с момента его создания до момента его удаления из DOM. Эти методы предоставляют хуки, которые позволяют выполнять код в определенные моменты жизни компонента. Важно отметить, что методы жизненного цикла доступны только в классовых компонентах. В функциональных компонентах для работы с ним используются хуки, например,\n`useEffect`\n.\nОсновные методы:\nМонтирование\nВызываются в следующем порядке при создании компонента и его добавлении в DOM:\n1.\nconstructor(props)\nКонструктор компонента, где можно инициализировать состояние и привязывать методы.\n2.\nstatic getDerivedStateFromProps(props, state)\nВызывается непосредственно перед рендерингом как при первом монтировании, так и при последующих обновлениях. Используется для обновления состояния в ответ на изменение пропсов.\n3.\nrender()\nЕдинственный обязательный метод в классовом компоненте. Описывает, что отображается на экране.\n4.\ncomponentDidMount()\nВызывается сразу после монтирования (вставки компонента в DOM). Идеальное место для инициализации запросов к удаленным данным.\nОбновление\nВызываются при обновлении компонента из-за изменений в пропсах или состоянии:\n1.\nstatic getDerivedStateFromProps(props, state)\nТак же, как и при монтировании.\n2.\nshouldComponentUpdate(nextProps, nextState)\nПозволяет оптимизировать приложение, предотвращая ненужные обновления.\n3.\nrender()\nВызывается для повторного рендеринга в ответ на изменения.\n4.\ngetSnapshotBeforeUpdate(prevProps, prevState)\nВызывается перед тем, как измененный компонент будет отрисован в DOM. Используется для сохранения информации о DOM (например, позиции скролла).\n5.\ncomponentDidUpdate(prevProps, prevState, snapshot)\nВызывается сразу после обновления. Не вызывается при первом рендере. Используется для выполнения сетевых запросов в ответ на изменения состояния или пропсов.\nРазмонтирование\n1.\ncomponentWillUnmount()\nВызывается перед удалением компонента из DOM. Используется для выполнения любой необходимой очистки, такой как отмена таймеров, отмена запросов к сети или удаление подписок.\nОшибки\n1.\nstatic getDerivedStateFromError(error)\nИспользуется для отлавливания ошибок во время рендеринга дочерних компонентов.\n2.\ncomponentDidCatch(error, info)\nИспользуется для регистрации ошибок, произошедших во время рендеринга, в методах жизненного цикла или в конструкторах дочерних компонентов.\nЭти методы позволяют контролировать поведение компонентов на различных этапах их жизни, оптимизировать производительность и обрабатывать ошибки.",
    videos: [
      {
        url: "https://youtu.be/xGyI3uOXRjY?t=2726",
        title: "Tech Interview Fest | Пробное собесе…",
        time: 2726,
      },
      {
        url: "https://youtu.be/gV6eobXisYU?t=1292",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 1292,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1772,
    question: "Приведи пример микрозадач",
    explanation:
      "Микрозадачи — это задачи, которые планируются для выполнения после завершения текущего выполнения скрипта, но до того, как браузер продолжит другие задачи, такие как рендеринг или обработка событий. Они имеют более высокий приоритет по сравнению с макрозадачами и выполняются немедленно после текущего стека вызовов, но перед любыми другими событиями или рендерингом.\nПримеры включают обработку промисов и выполнение функций, отложенных с помощью\n`queueMicrotask`\n.\nС промисами\nИспользуют механизм таких задач для своих колбэков\n`then`\n,\n`catch`\n, и\n`finally`\n. Когда промис переходит в состояние выполнено (\n`fulfilled`\n) или отклонено (\n`rejected`\n), соответствующие колбэки планируются как микрозадачи. Это означает, что они будут выполнены сразу после текущего стека вызовов, но до того, как движок возьмется за выполнение следующей макрозадачи, например, обработку событий или таймеров.\nconsole.log('Начало');\nPromise.resolve().then(() => {\n    console.log('Обработан промис');\n});\nconsole.log('Конец');\nВывод будет следующим:\nНачало\nКонец\nОбработан промис\nСначала выполняется синхронный код (\n`Начало`\nи\n`Конец`\n), и только после его завершения, но до того как браузер перейдет к другим задачам, выполняются микрозадачи, связанные с промисами (\n`Обработан промис`\n).\nС `queueMicrotask`\nЭта функция позволяет явно добавить микрозадачу в очередь микрозадач. Это может быть полезно для разделения вычислений на более мелкие асинхронные операции, не блокируя поток выполнения и интерфейс.\nconsole.log('Перед queueMicrotask');\nqueueMicrotask(() => {\n    console.log('Выполнено в микрозадаче');\n});\nconsole.log('После queueMicrotask');\nВывод будет аналогичным:\nПеред queueMicrotask\nПосле queueMicrotask\nВыполнено в микрозадаче\nСначала выполняется основной поток кода, затем микрозадача, добавленная через\n`queueMicrotask`\n.\nМикрозадачи обеспечивают способ эффективного управления асинхронными операциями, позволяя избежать блокирования потока выполнения и улучшить отзывчивость приложений.",
    videos: [
      {
        url: "https://youtu.be/PgQ4Bn8g4Fg?t=1545",
        title: "Публичное собеседование: Frontend-ра…",
        time: 1545,
      },
      {
        url: "https://youtu.be/U3-TSl4cRn0?t=2326",
        title: "Из питониста во фронтендеры: собесед…",
        time: 2326,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1773,
    question: "Зачем появились promise",
    explanation:
      'Промисы (Promises) были введены как решение проблемы "callback hell" (также известного как "pyramid of doom"), когда асинхронный код становится сложным для понимания, поддержки и расширения из-за глубокой вложенности обратных вызовов (callbacks). Они предоставляют более удобный и гибкий способ организации асинхронного кода, делая его более читаемым и легким в управлении.\nОсновные причины появления промисов:\n1.\nУлучшение читаемости асинхронного кода:\nПозволяют писать асинхронный код, который выглядит более последовательным и легко читается, по сравнению с вложенными обратными вызовами.\n2.\nУпрощение обработки ошибок:\nВместо того, чтобы обрабатывать ошибки в каждом обратном вызове, они позволяют использовать единую конструкцию\n`catch`\nдля перехвата ошибок в любом месте цепочки промисов.\n3.\nСинхронизация асинхронных операций:\nУпрощают выполнение нескольких асинхронных операций параллельно и обработку их результатов с помощью методов\n`Promise.all`\n,\n`Promise.race`\n,\n`Promise.allSettled`\nи\n`Promise.any`\n.\n4.\nСтандартизация асинхронного кода:\nСтандартизируют способ работы с асинхронностью, предоставляя универсальный интерфейс для различных асинхронных операций, таких как работа с сетевыми запросами, таймерами и т.д.\nКак работают промисы\nМожет находиться в одном из трех состояний:\nОжидание (pending):\nначальное состояние, не выполнено и не отклонено.\nВыполнено (fulfilled):\nоперация завершена успешно.\nОтклонено (rejected):\nоперация завершена с ошибкой.\nКогда он переходит из состояния ожидания в состояние выполнено или отклонено, он вызывает соответствующие обработчики, добавленные с помощью методов\n`then`\n,\n`catch`\nи\n`finally`\n. Эти методы возвращают новый промис, позволяя строить цепочки промисов.\nПример\nlet promise = new Promise((resolve, reject) => {\n  setTimeout(() => resolve("данные получены"), 1000);\n});\npromise\n  .then(result => {\n    console.log(result); // "данные получены"\n    return result + " обработаны";\n  })\n  .then(result => {\n    console.log(result); // "данные получены обработаны"\n  })\n  .catch(error => {\n    console.error(error);\n  })\n  .finally(() => {\n    console.log("Промис завершил выполнение");\n  });\nПромисы существенно улучшили способ работы с асинхронностью, предоставив более мощный и гибкий инструмент для организации асинхронного кода по сравнению с традиционными обратными вызовами. Они сделали код более читабельным, упростили обработку ошибок и синхронизацию асинхронных операций.',
    videos: [
      {
        url: "https://youtu.be/PgQ4Bn8g4Fg?t=1605",
        title: "Публичное собеседование: Frontend-ра…",
        time: 1605,
      },
      {
        url: "https://youtu.be/gt-Glqr-1DM?t=2333",
        title: "Собеседование frontend junior+ разра…",
        time: 2333,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1774,
    question: "Расскажи про своё самообучение",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/Jmpft3r3E2E?feature=share&t=3547",
        title: "Публичное собеседование: frontend-ра…",
        time: 3547,
      },
      {
        url: "https://www.youtube.com/live/MdRE18dGmNU?feature=share&t=6961",
        title: "Публичное собеседование: Junior Fron…",
        time: 6961,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1775,
    question: "Зачем нужны разные хештеги",
    explanation:
      'Хештеги (#) в веб-разработке используются по-разному, в зависимости от контекста их применения. Во-первых, они могут использоваться в социальных сетях для группировки контента по определенным темам, что облегчает поиск информации. Во-вторых, в URL-адресах веб-страниц хештеги служат для навигации к определенной части страницы без перезагрузки (якорные ссылки).\n1.\nХештеги в социальных сетях:\n(#пример) помогают пользователям находить сообщения и контент по определенным темам или интересам в социальных сетях. Когда вы добавляете хештег к своему посту, он автоматически становится кликабельным, и любой может кликнуть по нему, чтобы увидеть другие посты с ним же. Это способствует объединению контента по схожим интересам и упрощает поиск нужной информации.\n#пример - делает ваш пост видимым для всех, кто ищет посты с этим хештегом.\n2.\nХештеги в URL (якорные ссылки):\nВ веб-разработке они используются в URL для навигации к определенному разделу или элементу на странице без перезагрузки страницы. Это называется якорная ссылка. Когда пользователь кликает по такой ссылке, браузер прокручивает страницу к элементу, который имеет соответствующий идентификатор (id).\n<a href="#section1">Перейти к разделу 1</a>\n   <div id="section1">Содержимое раздела 1</div>\nВ этом примере, когда пользователь кликает на ссылку "Перейти к разделу 1", страница прокручивается к\n`<div id="section1">`\n.\nРазные хештеги нужны для организации и упрощения поиска контента в социальных сетях, а также для навигации по веб-страницам без перезагрузки, направляя пользователя к определенному разделу или элементу страницы. Это делает информацию более доступной и интерактивной.\nХештеги помогают нам быстро находить интересующую информацию в интернете и перемещаться по веб-страницам, не перезагружая их целиком.',
    videos: [
      {
        url: "https://youtu.be/-HfKMcP_yt4?t=1004",
        title: "Публичное собеседование: frontend-ра…",
        time: 1004,
      },
      {
        url: "https://youtu.be/EaTZXKlpsj0?t=775",
        title: "#11 Фронтендер в 17 лет? Собеседован…",
        time: 775,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1776,
    question: "Как react работает",
    explanation:
      "React — это библиотека для создания пользовательских интерфейсов. Она позволяет строить сложные, интерактивные UI из маленьких, изолированных частей кода, называемых компонентами. Он основывается на нескольких ключевых концепциях, которые обеспечивают его эффективность и гибкость.\n1.\nКомпонентный подход:\nПриложения состоят из компонентов. Компонент — это кусочек пользовательского интерфейса, который можно использовать повторно. Каждый компонент имеет своё состояние и пропсы (параметры, которые передаются от родительского компонента), что делает его независимым и способным к самостоятельной работе.\n2.\nJSX:\nИспользует JSX — синтаксис, похожий на HTML, для описания структуры интерфейса. Он делает код компонентов более читабельным и упрощает процесс их создания.\nfunction App() {\n     return <div>Привет, мир!</div>;\n   }\n3.\nВиртуальный DOM:\nОдной из главных особенностей является использование виртуального DOM — лёгкой копии реального DOM. Это позволяет React оптимизировать обновления интерфейса, сначала применяя изменения к виртуальному DOM, а затем, после вычисления наиболее эффективных изменений, к реальному DOM. Это существенно повышает производительность, особенно при работе с большими объёмами данных.\n4.\nОднонаправленный поток данных:\nДанные течут строго от родителей к детям через пропсы, что упрощает отладку и понимание приложений, так как знаешь, откуда пришли данные и как они изменяются.\n5.\nХуки:\nС появлением хуков он стал ещё более мощным и гибким. Хуки позволяют использовать состояние и другие его возможности без написания классов. Например, хук `useState` позволяет добавить состояние к функциональному компоненту.\nimport { useState } from 'react';\n   function Counter() {\n     const [count, setCount] = useState(0);\n     return (\n       <div>\n         <p>Вы кликнули {count} раз</p>\n         <button onClick={() => setCount(count + 1)}>\n           Нажми на меня\n         </button>\n       </div>\n     );\n   }\nReact предлагает мощный набор инструментов для быстрой и эффективной разработки интерактивных пользовательских интерфейсов. Он позволяет разрабатывать компоненты независимо, управлять их состоянием и пропсами, а также эффективно обновлять интерфейс, минимизируя взаимодействие с реальным DOM.\nReact помогает создавать веб-страницы, которые быстро реагируют на действия пользователя, делая взаимодействие с сайтом плавным и приятным, не перезагружая страницу при каждом действии.",
    videos: [
      {
        url: "https://www.youtube.com/live/Awnog8KYub4?feature=share&t=570",
        title: "Публичное собеседование: Ведущий fro…",
        time: 570,
      },
      {
        url: "https://youtu.be/P2x_lmvVOfE?t=720",
        title: "Собеседование JUNIOR FRONTEND REACT …",
        time: 720,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1777,
    question: "В какую сторону бы хотел развиваться как специалист",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/Awnog8KYub4?feature=share&t=5055",
        title: "Публичное собеседование: Ведущий fro…",
        time: 5055,
      },
      {
        url: "https://youtu.be/NRufVTyELC4?t=2604",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 2604,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1778,
    question: "Как работает new",
    explanation:
      "`new`\nиспользуется для создания экземпляра объекта на основе функции-конструктора или класса. Процесс его работы можно разделить на несколько шагов:\n1.\nСоздание нового объекта:\nКогда вы используете его, JavaScript создаёт новый пустой объект.\n2.\nПрисвоение прототипа:\nПрототип созданного объекта устанавливается в значение свойства `prototype` функции-конструктора. Это означает, что новый объект наследует свойства и методы, определённые в прототипе конструктора.\n3.\nВызов функции-конструктора:\nФункция-конструктор вызывается с аргументами, переданными в неи, и контекстом\n`this`\n, установленным в только что созданный объект. Это позволяет добавлять свойства и методы непосредственно к экземпляру.\n4.\nВозврат значения:\nЕсли функция-конструктор возвращает объект, то этот объект возвращается вместо только что созданного. Если возвращается не объект (например, примитивное значение) или функция-конструктор вообще ничего не возвращает, то возвращается созданный на шаге 1 объект.\nПример:\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\nPerson.prototype.greet = function() {\n  console.log(`Привет, меня зовут ${this.name}!`);\n};\n// Создаём новый объект с помощью new\nconst person1 = new Person('Алексей', 30);\nperson1.greet(); // Выводит: \"Привет, меня зовут Алексей!\"\nВ этом примере\n`new Person('Алексей', 30)`\nсоздаёт новый объект, прототипом которого является\n`Person.prototype`\n, и вызывает функцию\n`Person`\nс\n`this`\n, указывающим на новый объект, что позволяет добавить свойства\n`name`\nи\n`age`\nк этому объекту. После этого, с новым объектом можно взаимодействовать, как с экземпляром\n`Person`\n, включая вызов методов, определённых в\n`Person.prototype`\n.\n`new`\nпозволяет создавать новые объекты на основе функций-конструкторов или классов, автоматически устанавливая связь между созданным объектом и прототипом конструктора, что обеспечивает наследование свойств и методов.",
    videos: [
      {
        url: "https://www.youtube.com/live/t52BuzKzqWw?feature=share&t=578",
        title: "Публичное собеседование: junior-fron…",
        time: 578,
      },
      {
        url: "https://youtu.be/ozvUaikP6cs?t=3448",
        title: "#6 Как волноваться и не облажаться? …",
        time: 3448,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1779,
    question: "Как относишься к код ревью",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/t52BuzKzqWw?feature=share&t=2391",
        title: "Публичное собеседование: junior-fron…",
        time: 2391,
      },
      {
        url: "https://youtu.be/VzorPrTjUII?t=1724",
        title: "Middle за год? Собеседование #3 fron…",
        time: 1724,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1781,
    question: "Какое у тебя образование",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/JERUf-xKU1o?feature=share&t=661",
        title: "Публичное собеседование #6: Дмитрий …",
        time: 661,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=165",
        title: "Собеседование cтажера Frontend разра…",
        time: 165,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1785,
    question: "Как можно ускорить загрузку сайта",
    explanation:
      "Ускорение загрузки сайта — крайне важный аспект веб-разработки, поскольку это напрямую влияет на пользовательский опыт и SEO. Есть множество способов оптимизации, которые могут помочь в этом:\n1.\nМинимизация и объединение файлов:\nСокращение количества файлов, которые нужно загрузить браузеру, может значительно ускорить загрузку сайта. Использование инструментов для минимизации (сжатия) этих файлов уменьшает их размер.\n2.\nАсинхронная загрузка скриптов:\nСкрипты, загружаемые асинхронно, не блокируют отображение страницы. Это позволяет браузеру продолжать загрузку других элементов страницы, пока скрипт ещё загружается.\n3.\nИспользование кэширования браузера:\nНастройка сервера так, чтобы он указывал браузерам, как долго хранить файлы в кэше, может значительно ускорить повторные посещения сайта.\n4.\nОптимизация изображений:\nИзображения часто занимают большую часть размера страницы. Использование форматов, таких как WebP, которые обеспечивают меньший размер файла при сохранении качества, а также сжатие и масштабирование изображений под нужные размеры, могут значительно сократить время загрузки.\n5.\nИспользование сети доставки контента (CDN):\nПозволяет хранить копии вашего сайта на множестве серверов по всему миру, так что пользователи загружают контент с ближайшего к ним сервера.\n6.\nLazy loading (ленивая загрузка):\nТехника, при которой контент (особенно изображения и видео) на странице загружается только тогда, когда он попадает в область видимости пользователя. Это снижает начальную нагрузку на страницу.\n7.\nУскорение серверного ответа:\nВремя ответа сервера может быть уменьшено за счет оптимизации сервера, использования более быстрого хостинга или оптимизации базы данных.\n8.\nИспользование HTTP/2:\nПозволяет более эффективно загружать ресурсы, благодаря мультиплексированию, сжатию заголовков и приоритизации запросов.\n9.\nУдаление ненужных плагинов и скриптов:\nНенужные плагины и скрипты могут замедлять ваш сайт, поэтому стоит регулярно пересматривать их и удалять неиспользуемые.\n10.\nИспользование AMP (Accelerated Mobile Pages):\nЕсли большая часть вашей аудитории использует мобильные устройства, использование AMP может ускорить загрузку страниц на этих устройствах.\nОптимизация загрузки сайта — это процесс, который требует внимания к деталям и постоянного тестирования. Использование инструментов анализа производительности, таких как Google PageSpeed Insights, помогает выявлять проблемы и предлагает конкретные рекомендации по их решению.\nДля ускорения загрузки сайта нужно оптимизировать ресурсы, использовать кэширование и CDN, применять асинхронную загрузку скриптов и ленивую загрузку контента, а также рассмотреть возможность использования более быстрых технологий и протоколов. Это улучшит пользовательский опыт и повысит эффективность сайта.",
    videos: [
      {
        url: "https://www.youtube.com/live/JERUf-xKU1o?feature=share&t=1302",
        title: "Публичное собеседование #6: Дмитрий …",
        time: 1302,
      },
      {
        url: "https://youtu.be/wP7XVriACtA?t=3683",
        title: "Frontend Собеседование на Junior раз…",
        time: 3683,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1787,
    question: "Почему react лучше, чем jquerry",
    explanation:
      "Сравнивать React и jQuery не совсем корректно, поскольку они решают разные задачи в разработке веб-приложений. jQuery — это библиотека, которая упрощает манипуляции с DOM, обработку событий, анимации и Ajax-запросы, делая код более кратким и понятным. React — это библиотека для создания пользовательских интерфейсов, которая позволяет строить интерактивные UI с использованием компонентного подхода.\nТем не менее, можно выделить несколько причин, по которым можно предпочесть React jQuery для современных веб-приложений:\n1.\nКомпонентный подход:\nОснован на компонентах, что позволяет создавать переиспользуемые, независимые части интерфейса. Это делает код более организованным и упрощает его поддержку.\n2.\nВиртуальный DOM:\nИспользует виртуальный DOM, что позволяет оптимизировать обновление интерфейса и повысить производительность приложения, минимизируя количество манипуляций с реальным DOM.\n3.\nОднонаправленный поток данных:\nРеализует паттерн однонаправленного потока данных, который облегчает понимание того, как данные передаются через приложение и как состояние компонента влияет на его отображение.\n4.\nШирокие возможности для разработки сложных приложений:\nЛучше подходит для разработки больших и сложных веб-приложений, где требуется высокая степень интерактивности и динамичности интерфейса.\n5.\nЭкосистема и сообщество:\nИмеет огромное сообщество разработчиков и богатую экосистему, включая множество готовых решений, библиотек и инструментов, что облегчает разработку и внедрение новых функций.\n6.\nИнтеграция с современными архитектурами и инструментами разработки:\nЛегко интегрируется с современными архитектурами веб-разработки, такими как Redux для управления состоянием приложения, и с инструментами разработки, такими как Webpack, Babel и другие.\n7.\nПоддержка из коробки:\nСоздание интерактивных пользовательских интерфейсов с ним часто требует меньше кода и меньше усилий для поддержания его в актуальном состоянии по сравнению с использованием jQuery для тех же целей.\nХотя React предлагает множество преимуществ для разработки современных веб-приложений, выбор между React и jQuery зависит от конкретных требований проекта. Для простых веб-сайтов или задач, где необходимо быстро добавить интерактивность без переписывания существующего кода, jQuery может быть более подходящим выбором. Для создания сложных пользовательских интерфейсов с высокой степенью взаимодействия React предлагает более современный и мощный инструментарий.",
    videos: [
      {
        url: "https://www.youtube.com/live/JERUf-xKU1o?feature=share&t=1559",
        title: "Публичное собеседование #6: Дмитрий …",
        time: 1559,
      },
      {
        url: "https://youtu.be/Y1SekvuZ3M4?t=1447",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 1447,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1789,
    question: "Сколько людей в команде",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/JERUf-xKU1o?feature=share&t=2057",
        title: "Публичное собеседование #6: Дмитрий …",
        time: 2057,
      },
      {
        url: "https://youtu.be/VzorPrTjUII?t=126",
        title: "Middle за год? Собеседование #3 fron…",
        time: 126,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1792,
    question: "О каких уязвимостях слышал",
    explanation:
      'Существует множество различных уязвимостей, которые могут быть использованы злоумышленниками для нанесения вреда пользователям или системам.\n1.\nSQL-инъекции (SQL Injection):\nПроисходят, когда злоумышленник может внедрить или "инъецировать" вредоносный SQL-код в запрос, который изменяет стандартное выполнение запроса к базе данных. Это может привести к несанкционированному доступу к данным, их изменению или удалению.\n2.\nCross-Site Scripting (XSS):\nПозволяет злоумышленникам внедрять клиентский скрипт в веб-страницы, просматриваемые другими пользователями. Это может привести к краже cookie-файлов, сессий, персональных данных и других атак на клиентскую сторону.\n3.\nCross-Site Request Forgery (CSRF):\nЗаставляет пользователя выполнить нежелательные действия на веб-сайте, на котором он в настоящее время аутентифицирован, например, отправить запрос на смену пароля или выполнить платеж от имени пользователя.\n4.\nРазглашение информации:\nПроисходит, когда веб-приложение раскрывает чувствительную информацию, такую как технические детали своей работы, структуры баз данных или креденциалы, что может быть использовано злоумышленниками.\n5.\nНебезопасная десериализация:\nЭто уязвимость, при которой недостаточно проверенные или небезопасные данные могут быть десериализованы и выполнены как код, что может привести к удаленному выполнению кода, внедрению вредоносных скриптов или атакам отказа в обслуживании.\n6.\nИспользование компонентов с известными уязвимостями:\nВключает использование сторонних библиотек и зависимостей, которые содержат известные уязвимости. Это может подвергнуть приложение риску атак.\n7.\nНедостатки в управлении сессиями:\nУязвимости, связанные с управлением сессиями и аутентификацией, могут позволить злоумышленникам перехватывать или подделывать сессии пользователей, получать несанкционированный доступ к учетным записям.\n8.\nSecurity Misconfiguration (Неправильная настройка безопасности):\nЭто самый широкий класс уязвимостей, который включает в себя неправильно настроенные разрешения, стандартные учетные записи с известными паролями, открытые облачные хранилища и другие ошибки в конфигурации.\n9.\nНедостатки в контроле доступа:\nПроисходят, когда пользователи могут получить доступ к функциям или данным, к которым у них не должно быть доступа. Это может включать доступ к данным других пользователей, выполнение функций администратора и т.д.\n10.\nВнедрение вредоносного кода (Malware Upload):\nУязвимости, позволяющие злоумышленникам загружать и выполнять вредоносный код на сервере или у клиентов.\nДля защиты от этих и других уязвимостей нужно следовать лучшим практикам безопасности, регулярно обновлять используемое программное обеспечение, проводить аудиты безопасности и использовать инструменты для сканирования уязвимостей.',
    videos: [
      {
        url: "https://www.youtube.com/live/fk_eTY2IZQE?feature=share&t=1762",
        title: "Публичное собеседование: фронтендер …",
        time: 1762,
      },
      {
        url: "https://www.youtube.com/watch?v=BonLyarPpqE&t=3630s",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 3630,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1794,
    question: "Что такое solid",
    explanation:
      "SOLID — это акроним, представляющий пять основных принципов ООП и дизайна, призванных сделать ПО более понятным, гибким и поддерживаемым. Эти принципы помогают разработчикам предотвратить распространенные проблемы в дизайне, такие как жесткая зависимость компонентов друг от друга, сложность в внесении изменений и слабая масштабируемость.\n1.\nПринцип единственной ответственности (Single Responsibility Principle, SRP):\nКаждый класс должен иметь только одну причину для изменения. Этот принцип говорит о том, что класс должен выполнять только одну задачу или функцию. Если класс отвечает за несколько функциональностей, его изменение может повлечь за собой непредвиденные последствия в других частях программы.\n2.\nПринцип открытости/закрытости (Open/Closed Principle, OCP):\nПрограммные сущности (классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для модификации. Это означает, что можно добавлять новую функциональность, не изменяя существующий код, что уменьшает риск внесения ошибок в уже работающую систему.\n3.\nПринцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP):\nОбъекты в программе можно заменить их наследниками без изменения свойств программы. Наследуемый класс должен дополнять, а не заменять поведение базового класса. Это укрепляет корректность программы при подстановке экземпляров подкласса вместо экземпляров базового класса.\n4.\nПринцип разделения интерфейса (Interface Segregation Principle, ISP):\nКлиенты не должны зависеть от интерфейсов, которые они не используют. Этот принцип говорит о том, что лучше иметь много специализированных интерфейсов, чем один универсальный. Такой подход облегчает реализацию конкретного функционала без необходимости реализовывать неиспользуемые методы.\n5.\nПринцип инверсии зависимостей (Dependency Inversion Principle, DIP):\nМодули высокого уровня не должны зависеть от модулей низкого уровня. Оба типа модулей должны зависеть от абстракций. Кроме того, абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций. Это означает, что взаимодействие между разными частями программы должно осуществляться через абстрактные интерфейсы, что упрощает замену одних компонентов программы на другие и облегчает тестирование.\nПрименение принципов SOLID помогает создавать ПО, которое легче понимать, расширять и поддерживать. Эти принципы способствуют разработке модульного кода, уменьшают его зацепление и повышают гибкость системы, что особенно важно для крупных и сложных проектов.",
    videos: [
      {
        url: "https://www.youtube.com/live/fk_eTY2IZQE?feature=share&t=4310",
        title: "Публичное собеседование: фронтендер …",
        time: 4310,
      },
      {
        url: "https://www.youtube.com/watch?v=BonLyarPpqE&t=4530s",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 4530,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1796,
    question: "Как работает браузер",
    explanation:
      "Браузер — это ПО, предназначенное для просмотра веб-страниц. Его работавключает в себя несколько ключевых этапов, начиная от ввода адреса веб-сайта (URL) пользователем и заканчивая отображением страницы.\n1.\nВвод URL и запрос к сервер:\nПользователь вводит URL в адресную строку браузера, например,\n`https://example.com`\n.\nБраузер интерпретирует его и определяет, к какому серверу нужно обратиться. Если URL не содержит явного указания протокола (например, HTTP или HTTPS), браузер выбирает протокол по умолчанию.\nБраузер проверяет кэш DNS для получения IP-адреса сервера. Если информации в кэше нет, происходит запрос к DNS-серверу для разрешения имени домена в IP-адрес.\nС помощью полученного IP-адреса браузер устанавливает соединение с сервером (при использовании HTTPS происходит дополнительный процесс рукопожатия для установления защищенного соединения).\n2.\nПолучение данных от сервера:\nПосле установления соединения браузер отправляет HTTP-запрос к серверу для получения содержимого веб-страницы.\nСервер обрабатывает запрос и отправляет ответ, обычно в форме HTML-документа, сопровождаемого статусным кодом ответа (например, 200 OK).\n3.\nОбработка и отображение контента:\nБраузер начинает обработку полученного HTML-документа сверху вниз. В процессе разбора HTML браузер также может столкнуться с ссылками на внешние ресурсы, которые также нужно загрузить. Эти ресурсы могут загружаться асинхронно или откладываться до момента, когда они понадобятся.\nCSS-файлы обрабатываются для применения стилей к элементам HTML. JavaScript-файлы выполняются, что может изменять DOM (структуру документа) и CSSOM (объектную модель стилей), влияя на внешний вид и поведение страницы.\nПосле того как HTML-документ полностью разобран и все внешние ресурсы загружены и обработаны, браузер строит DOM-дерево и CSSOM-дерево, а затем объединяет их в дерево рендеринга.\nНа основе дерева рендеринга браузер вычисляет, как именно должны быть расположены и отображены элементы на странице (раскладка).\nНаконец, происходит рендеринг страницы на экране пользователя.\n4.\nДинамическое взаимодействие:\nПосле первоначальной загрузки страницы пользователь может взаимодействовать с ней: кликать по ссылкам, вводить данные в формы и так далее. JavaScript позволяет изменять содержимое страницы без необходимости её перезагрузки, обращаясь к серверу посредством AJAX-запросов и получая данные, которые могут быть динамически вставлены в страницу.\nЭтот процесс демонстрирует, как браузер превращает коды HTML в интерактивные веб-страницы, которые мы видим и с которыми взаимодействуем каждый день. Благодаря этим этапам работы браузер обеспечивает пользователю доступ к богатому и интерактивному контенту.",
    videos: [
      {
        url: "https://youtu.be/9nBbRK-Gfjg?t=1604",
        title: "Мок-интервью для джуна-фронтендера: …",
        time: 1604,
      },
      {
        url: "https://youtu.be/U3-TSl4cRn0?t=1457",
        title: "Из питониста во фронтендеры: собесед…",
        time: 1457,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1798,
    question: "Что такое селектор",
    explanation:
      'Селектор — это способ определения, к каким элементам страницы будут применяться стили или какие элементы будут выбраны ля выполнения определенных действий.\nСелекторы в CSS\nИспользуются для определения, к каким элементам HTML применять конкретные стилевые правила. Существует несколько типов селекторов:\n1.\nТиповые селекторы (Type selectors):\nСоответствуют имени тега и применяют стили ко всем элементам данного типа. Например,\n`p { color: blue; }`\nприменит синий цвет текста ко всем параграфам.\n2.\nКлассовые селекторы (Class selectors):\nПрименяют стили к элементам с определенным атрибутом class. Обозначаются точкой перед именем класса, например,\n`.menu { font-size: 14px; }`\n.\n3.\nИдентификаторы (ID selectors):\nПрименяют стили к элементу с конкретным идентификатором. Идентификатор в HTML должен быть уникален. Селектор идентификатора начинается с символа `\n#`\n, например,\n`#header { background-color: yellow; }`\n.\n4.\nСелекторы атрибутов (Attribute selectors):\nПозволяют выбирать элементы на основе наличия, значения или части значения атрибута. Например,\n`input[type="text"] { border-color: green; }`\nприменяет зеленую рамку к текстовым полям.\n5.\nПсевдоклассы (Pseudo-classes):\nПозволяют стилизовать элементы на основе их состояния или позиции, например,\n`a:hover { color: red; }`\nизменяет цвет ссылок при наведении курсора.\n6.\nПсевдоэлементы (Pseudo-elements):\nИспользуются для стилизации определенных частей элементов, например,\n`p::first-line { font-weight: bold; }`\nделает первую строку каждого параграфа жирной.\nСелекторы\nВ JS используются для выбора элементов DOM, чтобы можно было манипулировать ими с помощью скрипта. Существуют методы для выбора элементов:\ngetElementById():\nВозвращает элемент по его идентификатору.\ngetElementsByClassName():\nВозвращает список всех элементов с указанным именем класса.\ngetElementsByTagName():\nВозвращает список всех элементов заданного тега.\nquerySelector():\nВозвращает первый элемент, соответствующий указанному CSS-селектору.\nquerySelectorAll():\nВозвращает все элементы, соответствующие указанному CSS-селектору.\nИспользование селекторов позволяет точно указывать, к каким элементам нужно применить стили или какие элементы необходимо выбрать для выполнения операций, делая веб-разработку гибкой и мощной.',
    videos: [
      {
        url: "https://youtu.be/9nBbRK-Gfjg?t=4247",
        title: "Мок-интервью для джуна-фронтендера: …",
        time: 4247,
      },
      {
        url: "https://youtu.be/5gplqEVgajc?t=1841",
        title: "Cобеседование Junior Frontend разраб…",
        time: 1841,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1799,
    question: "Что делает box-sizing: border-box",
    explanation:
      "Свойство\n`box-sizing`\nопределяет, как будут рассчитываться размеры элемента: включая ли в эти размеры внутренние отступы (padding) и границы (border) или нет. Данное значение  изменяет традиционное поведение расчета ширины и высоты элемента.\nКак работает\nКогда вы устанавливаете для элемента `box-sizing: border-box;`, ширина и высота элемента начинают включать в себя внутренние отступы и толщину границ. Это означает, что фактический размер элемента (как он отображается на странице) будет соответствовать заданным ширине (`width`) и высоте (`height`), независимо от толщины границ и размеров внутренних отступов.\nПример без\n`border-box`\nПо умолчанию, если не указано значение, используется значение `content-box`. Это означает, что указанные ширина и высота применяются только к контентной области элемента. Внутренние отступы и границы добавляются к этим размерам, увеличивая общий размер элемента. Например:\n.box {\n  width: 300px;\n  height: 200px;\n  padding: 20px;\n  border: 5px solid black;\n  /* box-sizing: content-box; по умолчанию */\n}\nЗдесь фактический размер элемента будет 350px по ширине (300px контент + 40px отступы + 10px границы) и 250px по высоте.\nПример с\n`border-box`\nЕсли вы установите такое значение, размеры элемента будут включать в себя и внутренние отступы, и границы:\n.box {\n  box-sizing: border-box;\n  width: 300px;\n  height: 200px;\n  padding: 20px;\n  border: 5px solid black;\n}\nВ этом случае фактический размер элемента останется 300px по ширине и 200px по высоте, несмотря на наличие внутренних отступов и границ. Это делает расчет размеров более предсказуемым и упрощает верстку, особенно при работе с гибкими и адаптивными макетами.\nЗачем использовать\nИспользование\n`border-box`\nупрощает работу с макетами, так как разработчику не нужно постоянно пересчитывать размеры элементов при изменении внутренних отступов или толщины границ. Это делает код более чистым и понятным, а процесс разработки — более быстрым и эффективным.",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=399",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 399,
      },
      {
        url: "https://youtu.be/gV6eobXisYU?t=959",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 959,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1800,
    question: "Что такое адаптивная верстка",
    explanation:
      'Адаптивная вёрстка (Adaptive Web Design) — это подход, который позволяет создавать веб-сайты, корректно отображающиеся и удобно используемые на устройствах с различными размерами экранов и разрешениями. Это достигается за счёт использования различных технологий и приёмов дизайна, включая гибкие сетки (flexible grids), медиазапросы (media queries), адаптивные изображения и другие.\nОсновные компоненты:\n1.\nГибкие сетки (Fluid Grids):\nИспользование процентных значений для определения ширины элементов вместо фиксированных единиц. Это позволяет элементам масштабироваться в зависимости от размера экрана устройства.\n2.\nМедиазапросы (Media Queries):\nCSS-технология, которая позволяет применять различные стили в зависимости от характеристик устройства, таких как размер экрана, разрешение, ориентация (портретная или ландшафтная) и др. Медиазапросы позволяют создавать разные "точки останова" (breakpoints), при которых веб-сайт может изменять свой макет для оптимального отображения.\n3.\nАдаптивные изображения:\nИспользование техник и технологий, позволяющих изображениям адаптироваться под разные размеры экранов и разрешения. Это может включать изменение размеров изображений, выбор разного качества изображений в зависимости от скорости соединения или использование элемента\n`<picture>`\nдля определения разных источников изображений для разных условий.\n4.\nФлексибельные медиа:\nКроме изображений, это также касается видео и других медиа-элементов, которые должны быть способны изменять свои размеры в соответствии с размером экрана для обеспечения лучшего пользовательского опыта.\nПреимущества:\nУлучшение пользовательского опыта:\nАдаптивный сайт удобно просматривать на любом устройстве, будь то компьютер, планшет или смартфон.\nSEO-оптимизация:\nПоисковые системы, включая Google, предпочитают адаптивные сайты, что может положительно сказаться на ранжировании.\nЭкономия ресурсов:\nВместо разработки отдельных версий сайта под разные устройства достаточно создать одну адаптивную версию.\nУпрощение поддержки:\nУправление одной версией сайта значительно упрощает его обновление и поддержку.\nАдаптивная вёрстка обеспечивает создание веб-сайтов, которые не только выглядят хорошо на экранах любого размера, но и предоставляют пользователям удобный и эффективный интерфейс взаимодействия, независимо от их устройства.',
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=542",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 542,
      },
      {
        url: "https://youtu.be/cRqBsepPgoI?t=1468",
        title: "Собеседование frontend junior+ разра…",
        time: 1468,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1801,
    question: "Для чего служат vh, vw при указании размеров",
    explanation:
      "Единицы\n`vh`\n(viewport height) и\n`vw`\n(viewport width) являются относительными единицами измерения, которые используются для указания размеров элементов в зависимости от размера области просмотра (viewport) браузера. Это позволяет создавать дизайн, который адаптируется к различным размерам экранов устройств.\n1vh\nравен 1% от высоты области просмотра.\n1vw\nравен 1% от ширины области просмотра..\nДля чего они служат:\n1.\nАдаптивный дизайн:\nПозволяют элементам адаптироваться к размеру экрана пользователя. Это особенно полезно для создания адаптивных макетов, где элементы должны изменять свои размеры в зависимости от размеров экрана.\n2.\nУлучшение пользовательского опыта:\nИспользование этих единиц может улучшить пользовательский опыт на устройствах с разными размерами экранов, обеспечивая более гармоничное и целостное отображение контента.\n3.\nГибкость в дизайне:\nПредоставляют дизайнерам и разработчикам большую гибкость при создании веб-страниц, позволяя легко реализовать дизайн, который реагирует на изменения размеров окна браузера.\nПримеры:\nВысота секции равна высоте экрана:\n.section {\n  height: 100vh;\n}\nЭто гарантирует, что секция будет занимать полную высоту области просмотра, независимо от размера экрана.\nШирина элемента в процентном соотношении к ширине экрана:\n.container {\n  width: 50vw;\n}\nЭтот контейнер будет занимать 50% от ширины области просмотра.\n-\nМинимальная высота секции:\n.section {\n  min-height: 50vh;\n}\nСекция будет иметь минимальную высоту, равную 50% от высоты области просмотра, что позволяет ей адаптироваться к содержимому и размерам экрана.\nИспользование\n`vh`\nи\n`vw`\nможет быть особенно полезным при проектировании веб-сайтов и приложений с учетом мобильных устройств и различных размеров экранов, обеспечивая более гибкий и адаптивный дизайн.",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=666",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 666,
      },
      {
        url: "https://youtu.be/gV6eobXisYU?t=1015",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 1015,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1803,
    question: "Из чего строится размер элементы",
    explanation:
      'Размер элемента строится из нескольких составляющих, которые вместе определяют конечный размер элемента на странице.\n1.\nКонтент (Content):\nЗдесь располагается его содержимое, например, текст или изображения. Размеры контента определяются свойствами\n`width`\n(ширина) и\n`height`\n(высота).\n2.\nВнутренние отступы (Padding):\nОтступы между контентом и границей. Они добавляются к размеру контента, увеличивая общий размер элемента, но не влияют на размеры самих границ.\n3.\nГраницы (Border):\nОкружают внутренние отступы и контент. Толщина границ также добавляется к общему размеру элемента.\n4.\nВнешние отступы (Margin):\nОтступы снаружи границ элемента. Внешние отступы не добавляются к размеру элемента напрямую, но влияют на расстояние между элементами на странице.\nBox Model\nОн определяется согласно "блочной модели" (Box Model), которая включает все вышеупомянутые составляющие. Стандартная блочная модель CSS рассчитывает общий размер элемента как сумму его ширины/высоты (контент), внутренних отступов, границ и внешних отступов. Важно отметить, что внешние отступы (\n`margin`\n) не учитываются в размере элемента; они влияют на расстояние до соседних элементов.\nBox-Sizing\nЕго свойство позволяет изменить стандартное поведение блочной модели:\n`content-box`\n(значение по умолчанию) означает, что размеры\n`width`\nи\n`height`\nприменяются только к контентной области, исключая внутренние отступы и границы.\n`border-box`\nозначает, что размеры\n`width`\nи\n`height`\nвключают в себя контент, внутренние отступы и границы, что упрощает расчёт размеров элемента и часто делает макет более предсказуемым.\nЕсли элемент имеет следующие стили:\ndiv {\n  width: 100px;\n  height: 100px;\n  padding: 10px;\n  border: 5px solid black;\n  margin: 20px;\n  box-sizing: content-box;\n}\nТо общий размер элемента будет 130x130 пикселей (100px контент + 20px внутренние отступы + 10px границы с каждой стороны), не считая внешние отступы. Если же установить\n`box-sizing: border-box;`\n, размер элемента останется 100x100 пикселей, включая внутренние отступы и границы.\nПонимание того, как строится размер элемента, критически важно для эффективной верстки и создания адаптивных дизайнов.',
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=723",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 723,
      },
      {
        url: "https://youtu.be/gV6eobXisYU?t=1033",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 1033,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1804,
    question: "За что отвечает z-index",
    explanation:
      "Свойство\n`z-index`\nотвечает за управление порядком наложения элементов на веб-странице по оси Z (глубина). Ось Z можно представить как ось, перпендикулярную экрану пользователя, где элементы с более высоким данным значением будут располагаться поверх элементов с более низким таким значением.\nКак работает\n`z-index`\n:\nБез его указания:\nЭлементы на веб-странице по умолчанию следуют порядку их появления в HTML-документе. Элемент, который появляется позже в коде, будет располагаться поверх предыдущих элементов, если они перекрываются.\nС его указанием:\nКогда элементам заданы такого значения, они располагаются в соответствии с этими значениями. Элементы с более высоким данным значением будут располагаться выше тех, у кого значение\n`z-index`\nниже.\nВажные аспекты\n`z-index`\n:\nТолько для позиционированных элементов: Работает только для элементов с свойством `position`, отличным от\n`static`\n(т.е.,\n`relative`\n,\n`absolute`\n,\n`fixed`\n, или\n`sticky`\n).\nЦелочисленные значения: Значение\n`z-index`\nможет быть положительным или отрицательным целым числом, а также нулём. Элементы с более высоким числовым значением всегда будут располагаться поверх элементов с более низким числовым значением.\nКонтекст наложения: Работает в рамках одного контекста наложения. Элемент с\n`position: relative`\nили\n`position: absolute`\nсоздаёт новый контекст наложения для своих дочерних элементов. Это означает, что\n`z-index`\nдействует в пределах этого контекста и не влияет на элементы вне его.\nПример:\n.back {\n  position: absolute;\n  z-index: 1;\n}\n.front {\n  position: absolute;\n  z-index: 2;\n}\nВ этом примере элемент с классом\n`front`\nбудет располагаться поверх элемента с классом\n`back`\n, благодаря более высокому данному значению.\nИспользование\n`z-index`\nпозволяет разработчикам контролировать порядок наложения элементов, что особенно важно для создания сложных интерфейсов, модальных окон, выпадающих меню и других элементов, которые должны выделяться на общем фоне страницы.",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=733",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 733,
      },
      {
        url: "https://youtu.be/gV6eobXisYU?t=1043",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 1043,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1805,
    question: "Что знаешь о приоритете селекторов",
    explanation:
      'Приоритет селекторов (или специфичность селекторов) — это механизм, определяющий, какие стили будут применены к элементу в случае конфликта, когда несколько правил могут применяться к одному и тому же элементу. Специфичность определяет вес или его важность, и более специфичные стили имеют приоритет над менее специфичными.\nРассчитывается на основе четырёх компонентов (по убыванию приоритета):\n1.\nВстроенные стили (Inline styles):\nСтили, применяемые непосредственно к элементу через атрибут\n`style`\n, имеют наивысший приоритет.\n2.\nИдентификаторы (ID):\nОснованные на идентификаторе элемента (\n`#id`\n).\n3.\nКлассы, псевдоклассы и атрибуты:\nСюда входят классы (\n`.class`\n), псевдоклассы (\n`:hover`\n,\n`:focus`\nи т.д.) и селекторы атрибутов (\n`[type="text"]`\n).\n4.\nТипы элементов и псевдоэлементы:\nОснованные на типе элемента (\n`div`\n,\n`p`\nи т.д.) и псевдоэлементы (\n`::before`\n,\n`::after`\n).\nЧтобы определить приоритет, браузеры используют систему подсчета, где каждый тип селектора имеет своё числовое значение. Например, встроенный стиль имеет вес 1000, каждый ID — 100, каждый класс, псевдокласс или атрибут — 10, а каждый тип элемента или псевдоэлемент — 1. Селекторы суммируют свои значения, и большее значение имеет приоритет.\nЕсли два селектора имеют одинаковую специфичность, то приоритет отдаётся последнему из них в коде CSS.\nПримеры:\nВстроенный стиль (\n`style="font-size: 12px;"`\n) перебьёт любые стили, заданные через\n`<style>`\nили внешний CSS-файл.\nСелектор\n`#id`\nперебьёт селекторы\n`.class`\nи типов элементов, независимо от их количества.\nСелектор\n`.class1.class2.class3`\n(специфичность 30) перебьёт селектор\n`.class1`\n(специфичность 10).\nСпецифичность — это один из фундаментальных механизмов каскада, позволяющий точно контролировать применение стилей. Всегда рекомендуется стремиться к написанию чистого и понятного кода, избегая чрезмерного использования идентификаторов и встроенных стилей, чтобы облегчить поддержку и модификацию кода в будущем.',
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=836",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 836,
      },
      {
        url: "https://youtu.be/gV6eobXisYU?t=1076",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 1076,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1809,
    question: "Какие псевдоэлементы знаешь и используешь",
    explanation:
      'Псевдоэлементы озволяют стилизовать определенные части элементов, к которым нельзя обратиться напрямую через DOM-структуру. Они используются для добавления специальных эффектов или для стилизации частей элементов, которые не представлены в виде отдельных DOM-узлов.\n1.\n`::after` и `::before`:\nИспользуются для вставки содержимого до или после содержимого элемента. Очень полезны для декоративных целей, таких как иконки, украшения или дополнительный текст.\np::before {\n     content: "«";\n   }\n   p::after {\n     content: "»";\n   }\n2.\n`::first-line`:\nПозволяет стилизовать первую строку текстового блока. Может быть использован для создания "выделенной" первой строки, изменения её шрифта, цвета и других свойств.\np::first-line {\n     font-weight: bold;\n     color: blue;\n   }\n3.\n`::first-letter`:\nПрименяется для стилизации первой буквы текстового блока. Часто используется для создания буквиц в начале абзацев.\np::first-letter {\n     font-size: 200%;\n     color: red;\n   }\n4.\n`::selection`:\nПозволяет изменить стиль текста, который пользователь выделил (например, при помощи мыши или клавиатуры). Можно изменить цвет текста и фона выделения.\np::selection {\n     color: white;\n     background-color: black;\n   }\n5.\n`::placeholder`:\nХотя технически это псевдокласс, он используется для стилизации текста-плейсхолдера в полях форм (например, в\n`<input>`\nили\n`<textarea>`\n).\ninput::placeholder {\n     color: grey;\n   }\n6.\n`::marker`:\nПрименяется к маркерам списков (то есть к буллетам в неупорядоченных списках или цифрам в упорядоченных списках), позволяя изменять их стиль.\nli::marker {\n     color: red;\n   }\n7.\n`::backdrop`:\nИспользуется для стилизации фона за модальным элементом, например, за\n`<dialog>`\nэлементом, когда он отображается в модальном режиме.\nЭти псевдоэлементы расширяют возможности, позволяя разработчикам достигать более сложных визуальных эффектов и интерфейсов без необходимости добавления лишнего HTML-кода. Они делают код чище, а стилизацию более гибкой и мощной.',
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=919",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 919,
      },
      {
        url: "https://www.youtube.com/watch?v=EaTZXKlpsj0&t=3400s",
        title: "#11 Фронтендер в 17 лет? Собеседован…",
        time: 3400,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1810,
    question:
      "Flexbox свойство отвечающее за перенос элементов на новую строку",
    explanation:
      "Свойство, отвечающее за перенос элементов на новую строку, называется\n`flex-wrap`\n. Оно позволяет управлять тем, будут ли flex-элементы укладываться в одну строку или могут переноситься на новую строку, если для них не хватает места в контейнере.\nСинтаксис\n.container {\n  flex-wrap: nowrap | wrap | wrap-reverse;\n}\nЗначения\n`nowrap`:\nПо умолчанию. Оно указывает, что все flex-элементы должны находиться в одной строке, даже если для этого их придется сжать.\n`wrap`:\nПри этом значении flex-элементы будут переноситься на новую строку, если в текущей строке для них не хватает места. Элементы будут располагаться сверху вниз.\n`wrap-reverse`:\nЭлементы также будут переноситься на новую строку, но порядок строк будет обратным: новые строки будут добавляться сверху.\nПример:\n.flex-container {\n  display: flex;\n  flex-wrap: wrap;\n}\nВ этом примере\n`.flex-container`\nявляется flex-контейнером, и его дочерние flex-элементы будут переноситься на новую строку, когда пространство в текущей строке закончится. Это полезно для создания адаптивных макетов, где элементы могут гибко адаптироваться к различным размерам экрана без необходимости явного указания точек переноса.",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=960",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 960,
      },
      {
        url: "https://youtu.be/gV6eobXisYU?t=1118",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 1118,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1811,
    question:
      "Как увеличить в размере при наведении элемент, не сдвигая соседние",
    explanation:
      "Для увеличения размера элемента при наведении, не сдвигая при этом соседние элементы, можно использовать свойство\n`transform`\nс функцией\n`scale()`\n. Этот метод позволяет масштабировать элемент, при этом его физический размер в потоке документа остаётся неизменным, что исключает сдвиг соседних элементов.\nПример:\n.element {\n  transition: transform 0.3s ease;\n}\n.element:hover {\n  transform: scale(1.1); /* Увеличивает размер элемента на 10% */\n}\nВ этом примере при наведении курсора мыши на элемент с классом\n`.element`\nон будет плавно увеличиваться в размере на 10% относительно своих исходных размеров. Свойство\n`transition`\nиспользуется для добавления анимационного эффекта при масштабировании, делая переход более плавным.\nПочему это работает:\nИспользование\n`transform: scale()`\nизменяет масштаб элемента, но не изменяет его фактические размеры в разметке страницы. Благодаря этому соседние элементы не сдвигаются и не изменяют своё положение, в отличие от изменения свойств\n`width`\nи\n`height`\n, которые бы физически увеличили размер элемента, потенциально влияя на разметку вокруг него.\nДополнительные соображения:\nЦентрирование масштабированного элемента:\nЕсли вы хотите, чтобы элемент увеличивался равномерно во все стороны (то есть оставался центрированным относительно своего исходного положения), убедитесь, что точка трансформации (\n`transform-origin`\n) установлена в значение по умолчанию (\n`50% 50%`\n), что обычно и так является стандартным поведением.\nИзбегание перекрытия:\nПри увеличении элемент может начать перекрывать соседние элементы. В зависимости от контекста это может быть желаемым или нежелательным эффектом. Если перекрытие нежелательно, возможно, придется подумать о других способах достижения нужного визуального эффекта или использовать\n`z-index`\nдля управления слоями перекрытия.\nЭтот метод является отличным способом добавить интерактивности и визуального интереса к элементам веб-страницы, сохраняя при этом стабильность и не нарушая общую компоновку страницы.",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=1059",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 1059,
      },
      {
        url: "https://youtu.be/gV6eobXisYU?t=1130",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 1130,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1812,
    question: "Для чего нужен оператор spread",
    explanation:
      "Оператор spread (\n`...`\n) используется для \"расширения\" элементов итерируемых объектов (например, массивов) или свойств объектов в местах, где ожидается ноль или более аргументов (в вызовах функций) или элементов (в массивах). Также он применяется при создании новых объектов для копирования свойств из существующих объектов. Он облегчает работу с массивами и объектами, делая код более читабельным и сокращая количество необходимого кода для выполнения различных операций.\nПримеры:\n1.\nВ массивах:\nДля объединения массивов:\nlet fruits = ['яблоки', 'бананы'];\n     let moreFruits = ['груши', 'персики', ...fruits];\n     console.log(moreFruits); // ['груши', 'персики', 'яблоки', 'бананы']\nДля копирования массивов:\nlet original = [1, 2, 3];\n     let copy = [...original];\n     console.log(copy); // [1, 2, 3]\n2.\nВ объектах:\nДля копирования свойств из одного объекта в другой:\nlet obj = { a: 1, b: 2 };\n     let copyObj = { ...obj, c: 3 };\n     console.log(copyObj); // { a: 1, b: 2, c: 3 }\nДля объединения объектов:\nlet obj1 = { a: 1, b: 2 };\n     let obj2 = { c: 3, d: 4 };\n     let combinedObj = { ...obj1, ...obj2 };\n     console.log(combinedObj); // { a: 1, b: 2, c: 3, d: 4 }\n3.\nВ функциях:\nДля передачи элементов массива в функцию в качестве отдельных аргументов:\nfunction sum(x, y, z) {\n       return x + y + z;\n     }\n     let numbers = [1, 2, 3];\n     console.log(sum(...numbers)); // 6\nОператор spread полезен при работе с динамическими данными, когда точное количество элементов или свойств заранее неизвестно. Он позволяет легко и эффективно манипулировать данными, сокращая потребность в использовании более сложных конструкций, таких как циклы или функции для работы с массивами и объектами.",
    videos: [
      {
        url: "https://youtu.be/gV6eobXisYU?t=474",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 474,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=1603",
        title: "Собеседование cтажера Frontend разра…",
        time: 1603,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1813,
    question: "Какие способы работы с асинхронным кодом знаешь",
    explanation:
      "Существует несколько подходов для работы с асинхронным кодом. Ононеобходимо для выполнения операций, которые могут занять некоторое время, например, запросы к серверу, чтение файлов или задержки времени, без блокировки выполнения основного потока программы. Вот основные способы работы с асинхронным кодом:1. Обратные вызовы (Callbacks): Это функции, которые передаются в качестве аргументов другим функциям и вызываются после завершения асинхронной операции. Несмотря на свою простоту, использование обратных вызовов может привести к проблеме \"Callback Hell\" или \"Pyramid of Doom\", когда возникает сложная вложенность обратных вызовов.\nfunction getData(url, callback) {\n     fetch(url)\n       .then(response => response.json())\n       .then(data => callback(null, data))\n       .catch(error => callback(error, null));\n   }\n   getData('https://api.example.com/data', (err, data) => {\n     if (err) {\n       console.error(err);\n     } else {\n       console.log(data);\n     }\n   });\n2.\nПромисы (Promises):\nЭто объект, представляющий завершение (или неудачу) асинхронной операции и её результат. Промисы упрощают работу с асинхронным кодом, позволяя избежать избыточной вложенности и упростить обработку ошибок.\nfetch('https://api.example.com/data')\n     .then(response => response.json())\n     .then(data => console.log(data))\n     .catch(error => console.error(error));\n3.\nAsync/Await:\nЭто синтаксический сахар над промисами, который позволяет писать асинхронный код, который выглядит как синхронный. Функция, объявленная с ключевым словом `async`, всегда возвращает промис, а оператор\n`await`\nиспользуется для ожидания результата асинхронной операции.\nasync function fetchData(url) {\n     try {\n       const response = await fetch(url);\n       const data = await response.json();\n       console.log(data);\n     } catch (error) {\n       console.error(error);\n     }\n   }\n   fetchData('https://api.example.com/data');\n4.\nEvent Emitters (Событийно-ориентированное программирование):\nОбъекты могут генерировать события, на которые затем можно подписываться с помощью обратных вызовов. Это позволяет реагировать на различные асинхронные события в программе.\nconst EventEmitter = require('events');\n   class MyEmitter extends EventEmitter {}\n   const myEmitter = new MyEmitter();\n   myEmitter.on('event', () => {\n     console.log('Произошло событие!');\n   });\n   myEmitter.emit('event');\nКаждый из этих методов имеет свои преимущества и недостатки, и выбор конкретного метода зависит от задачи, условий её выполнения и личных предпочтений разработчика. Async/Await и Промисы в настоящее время являются наиболее популярными и предпочтительными способами работы с асинхронным кодом из-за их читабельности и удобства в обработке ошибок.",
    videos: [
      {
        url: "https://youtu.be/gV6eobXisYU?t=630",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 630,
      },
      {
        url: "https://youtu.be/ScRTey_dvhI?t=3302",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 3302,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1814,
    question: "Что такое миксины",
    explanation:
      'Миксины — это способ реализации повторного использования кода, который позволяет включать набор свойств и методов в различные классы или объекты без необходимости использования наследования в традиционном смысле. Они могут рассматриваться как инструмент для реализации композиции объектов или классов, позволяя эффективно "смешивать" функциональность между разными компонентами.\nПрименение:\nВ объектно-ориентированном программировании (ООП):\nИспользуются для добавления функциональности в классы. Это особенно полезно тогда, когда не поддерживается множественное наследование, позволяя обойти ограничение наследования от одного класса.\nВ CSS:\nИспользуются в препроцессорах, таких как Sass и Less, для группировки CSS-деклараций, которые можно повторно использовать во всем стилевом файле. Это упрощает поддержку и изменение стилей, позволяя избежать повторения кода.\n1.\nМиксины в ООП (JavaScript):\nlet sayHiMixin = {\n     sayHi() {\n       console.log(`Привет, ${this.name}`);\n     },\n     sayBye() {\n       console.log(`Пока, ${this.name}`);\n     }\n   };\n   class User {\n     constructor(name) {\n       this.name = name;\n     }\n   }\n   // Копирование методов\n   Object.assign(User.prototype, sayHiMixin);\n   let user = new User("Иван");\n   user.sayHi(); // Привет, Иван\n   user.sayBye(); // Пока, Иван\n2.\nМиксины в CSS (Sass):\n@mixin border-radius($radius) {\n     -webkit-border-radius: $radius;\n        -moz-border-radius: $radius;\n         -ms-border-radius: $radius;\n             border-radius: $radius;\n   }\n   .button {\n     @include border-radius(10px);\n   }\nВ обоих случаях миксины позволяют избежать дублирования кода и способствуют более чистой, модульной и легко поддерживаемой кодовой базе. В программировании и веб-разработке миксины представляют собой мощный инструмент для повышения эффективности и улучшения архитектуры проектов.',
    videos: [
      {
        url: "https://youtu.be/gV6eobXisYU?t=1737",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 1737,
      },
      {
        url: "https://youtu.be/umHjpWydn8I?t=860",
        title: "50 вопросов на Vue JS собеседование",
        time: 860,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1815,
    question: "Как передать данные из родительского компонента в дочерний",
    explanation:
      "Vue.js или Angular, часто возникает задача передачи данных из родительского компонента в дочерний. Этот процесс и методы его реализации могут немного отличаться в зависимости от используемой технологии.\nReact\nДля передачи данных из родительского компонента в дочерний используются\n`props`\n(свойства). Props — это объект, который хранит значения атрибутов компонента и передается в дочерний компонент как параметр.\n// Родительский компонент\nfunction ParentComponent() {\n  const message = \"Привет от родителя!\";\n  return <ChildComponent text={message} />;\n}\n// Дочерний компонент\nfunction ChildComponent(props) {\n  return <p>{props.text}</p>;\n}\nVue.js\nДля передачи данных от родителя к дочернему компоненту также используются props. Вы определяете свойства, которые дочерний компонент ожидает получить, а затем передаете их через атрибуты в шаблоне родителя.\n<!-- Родительский компонент -->\n<template>\n  <ChildComponent :text=\"message\" />\n</template>\n<script>\nimport ChildComponent from './ChildComponent.vue';\nexport default {\n  components: {\n    ChildComponent\n  },\n  data() {\n    return {\n      message: \"Привет от родителя!\"\n    };\n  }\n}\n</script>\n<!-- Дочерний компонент -->\n<template>\n  <p>{{ text }}</p>\n</template>\n<script>\nexport default {\n  props: ['text']\n}\n</script>\nAngular\nДля передачи данных из родительского компонента в дочерний используются декораторы\n`@Input()`\n. Это позволяет принимать данные в дочернем компоненте через свойства, аннотированные как\n`@Input()`\n.\n// Родительский компонент\n@Component({\n  selector: 'app-parent',\n  template: `<app-child [text]=\"message\"></app-child>`\n})\nexport class ParentComponent {\n  message = 'Привет от родителя!';\n}\n// Дочерний компонент\n@Component({\n  selector: 'app-child',\n  template: `<p>{{ text }}</p>`\n})\nexport class ChildComponent {\n  @Input() text: string;\n}\nВ каждом из этих примеров данные передаются от родительского компонента к дочернему с использованием механизма свойств (props) или специальных декораторов (\n`@Input()`\nв Angular), что обеспечивает четкую изоляцию и контроль над потоком данных в приложении.",
    videos: [
      {
        url: "https://youtu.be/gV6eobXisYU?t=1750",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 1750,
      },
      {
        url: "https://youtu.be/umHjpWydn8I?t=1634",
        title: "50 вопросов на Vue JS собеседование",
        time: 1634,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1816,
    question: "Что делает $emit",
    explanation:
      'Метод\n`$emit`\nиспользуется для создания пользовательских событий в дочерних компонентах, которые могут быть "подняты" (или "выброшены"). Это позволяет дочерним компонентам отправлять данные обратно к родителю, обеспечивая двустороннее общение между компонентами. Он является частью экземпляра Vue и предоставляет удобный способ для дочерних компонентов уведомлять родительские компоненты о том, что произошло какое-то событие, передавая при этом необходимые данные.\nПредположим, у нас есть дочерний компонент, который позволяет пользователю ввести текст в поле ввода, и мы хотим отправить этот текст обратно в родительский компонент, когда пользователь нажимает кнопку.\nДочерний компонент (ChildComponent.vue):\n<template>\n  <div>\n    <input v-model="userInput" placeholder="Введите текст">\n    <button @click="submit">Отправить</button>\n  </div>\n</template>\n<script>\nexport default {\n  data() {\n    return {\n      userInput: \'\'\n    };\n  },\n  methods: {\n    submit() {\n      // Вызываем событие \'input-submitted\' и передаем значение userInput как параметр\n      this.$emit(\'input-submitted\', this.userInput);\n    }\n  }\n}\n</script>\nРодительский компонент (ParentComponent.vue):\n<template>\n  <div>\n    <ChildComponent @input-submitted="handleInput" />\n    <p>Пользователь ввел: {{ userInput }}</p>\n  </div>\n</template>\n<script>\nimport ChildComponent from \'./ChildComponent.vue\';\nexport default {\n  components: {\n    ChildComponent\n  },\n  data() {\n    return {\n      userInput: \'\'\n    };\n  },\n  methods: {\n    handleInput(input) {\n      // Обрабатываем данные, полученные от дочернего компонента\n      this.userInput = input;\n    }\n  }\n}\n</script>\nКогда пользователь нажимает кнопку "Отправить" в дочернем компоненте, метод\n`submit`\nвызывает\n`$emit`\nс событием\n`input-submitted`\n, передавая текущее значение\n`userInput`\nкак параметр. Родительский компонент прослушивает это событие с помощью\n`@input-submitted`\nи вызывает метод\n`handleInput`\n, который обновляет своё локальное состояние\n`userInput`\nс полученным значением. Это демонстрирует, как\n`$emit`\nможет быть использован для поднятия событий и данных от дочерних к родительским компонентам.',
    videos: [
      {
        url: "https://youtu.be/gV6eobXisYU?t=1765",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 1765,
      },
      {
        url: "https://youtu.be/umHjpWydn8I?t=411",
        title: "50 вопросов на Vue JS собеседование",
        time: 411,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1817,
    question: "Что такое интерполяция",
    explanation:
      'Интерполяция — это процесс вставки значений переменных, выражений или данных в строку. Этот метод широко используется для динамической подстановки данных в текст, позволяя создавать более гибкие и изменяемые строки, без необходимости сложной конкатенации.\nВ различных контекстах интерполяция имеет следующие особенности:\n1.\nВ JavaScript\nС приходом ES6 появилась возможность использовать шаблонные строки (template literals), которые облегчают интерполяцию. Шаблонные строки обозначаются обратными кавычками (\n`` ` ``\n), и для интерполяции переменных или выражений внутри них используются фигурные скобки с долларом (\n`${...}`\n).\nconst name = "Алиса";\nconst greeting = `Привет, ${name}!`;\nconsole.log(greeting); // Выведет: Привет, Алиса!\n2.\nВ Angular\nИнтерполяция используется для вставки значений из компонента в шаблон HTML. Это делается с помощью двойных фигурных скобок\n`{{...}}`\n.\n<p>{{ greeting }}</p>\nЕсли в компоненте TypeScript определена переменная\n`greeting`\nсо значением "Добро пожаловать в Angular", то в результате на странице будет отображено: "Добро пожаловать в Angular".\n3.\nВ Vue.js\nТакже использует двойные фигурные скобки для интерполяции выражений в шаблонах HTML. Это позволяет легко отображать динамические значения из данных компонента.\n<div id="app">\n  <p>{{ message }}</p>\n</div>\nnew Vue({\n  el: \'#app\',\n  data: {\n    message: \'Привет, Vue!\'\n  }\n})\n4.\nВ CSS (С использованием препроцессоров)\nПозволяют использовать интерполяцию для создания динамических селекторов, свойств или значений.\n$name: "header";\n$size: "large";\n.#{$name}-#{$size} {\n  font-size: 20px;\n}\nЭто приведет к созданию класса\n`.header-large`\nс размером шрифта 20px.\nИнтерполяция является мощным инструментом, который делает код более читабельным и уменьшает количество ошибок при работе со строками и динамическими значениями в различных языках программирования и технологиях.',
    videos: [
      {
        url: "https://youtu.be/gV6eobXisYU?t=1809",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 1809,
      },
      {
        url: "https://youtu.be/umHjpWydn8I?t=744",
        title: "50 вопросов на Vue JS собеседование",
        time: 744,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1818,
    question: "Как отрисовать компоненты на основе массива",
    explanation:
      "Отрисовка компонентов  — распространенный паттерн в разработке пользовательских интерфейсов. Этот подход позволяет динамически создавать компоненты в соответствии с данными, имеющимися в массиве.\nReact\nДля отрисовки списка компонентов на основе массива данных часто используется метод массива `.map()`, который позволяет преобразовать каждый элемент массива в компонент.\nfunction App() {\n  const items = ['Apple', 'Banana', 'Cherry'];\n  return (\n    <ul>\n      {items.map((item, index) => (\n        <li key={index}>{item}</li>\n      ))}\n    </ul>\n  );\n}\nВажно использовать уникальный ключ\n`key`\nдля каждого элемента списка, чтобы он мог эффективно определять, какие элементы изменились, добавлены или удалены.\nVue.js\nДля отрисовки списка на основе массива используется директива\n`v-for`\n. Это позволяет биндить массив данных к шаблону и отрисовывать список компонентов.\n<template>\n  <ul>\n    <li v-for=\"(item, index) in items\" :key=\"index\">{{ item }}</li>\n  </ul>\n</template>\n<script>\nexport default {\n  data() {\n    return {\n      items: ['Apple', 'Banana', 'Cherry']\n    };\n  }\n}\n</script>\nАтрибут\n`key`\nтакже важен для поддержания уникальности каждого элемента списка и оптимизации процесса рендеринга.\nAngular\nДля отрисовки списка используется структурная директива\n`*ngFor`\n. Эта директива повторяет шаблон для каждого элемента в массиве.\n<ul>\n  <li *ngFor=\"let item of items; let i = index\" [key]=\"i\">{{ item }}</li>\n</ul>\nimport { Component } from '@angular/core';\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  items = ['Apple', 'Banana', 'Cherry'];\n}\nТут атрибут\n`key`\nне требуется, так как он автоматически отслеживает каждый элемент через его индекс или уникальный идентификатор.\nЭти примеры показывают, как можно использовать данные из массива для динамической отрисовки компонентов в разных фреймворках. Этот подход облегчает создание интерфейсов, которые могут адаптироваться и обновляться в соответствии с изменениями данных.",
    videos: [
      {
        url: "https://youtu.be/gV6eobXisYU?t=1820",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 1820,
      },
      {
        url: "https://youtu.be/umHjpWydn8I?t=1247",
        title: "50 вопросов на Vue JS собеседование",
        time: 1247,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1819,
    question: "Как добавить слушатель события",
    explanation:
      "Добавление слушателя события — это стандартная практика для отслеживания действий пользователя или системных событий (например, загрузка страницы, клики, нажатия клавиш и т.д.). В зависимости от контекста и используемых технологий, существуют различные способы реализации этого механизма.\nЧистый\nДля добавления слушателя событий используется метод\n`addEventListener`\n. Он принимает как минимум два аргумента: название события и функцию обработчика, которая будет вызвана при наступлении события.\n// Пример: добавление слушателя события клика на элемент button\nconst button = document.getElementById('myButton');\nbutton.addEventListener('click', function() {\n  console.log('Кнопка была нажата!');\n});\njQuery\nДля добавления слушателей событий можно использовать метод\n`.on()`\n. Этот метод универсален и позволяет привязывать обработчики к различным событиям.\n// Пример: добавление слушателя события клика на элемент button с использованием jQuery\n$('#myButton').on('click', function() {\n  console.log('Кнопка была нажата!');\n});\nReact\nСлушатели событий добавляются непосредственно в JSX-элементы с использованием camelCase синтаксиса. Функция-обработчик передаётся как атрибут элемента.\nfunction App() {\n  function handleClick() {\n    console.log('Кнопка была нажата!');\n  }\n  return <button onClick={handleClick}>Нажми на меня</button>;\n}\nVue.js\nСлушатели событий добавляются через директивы, такие как\n`v-on`\nили сокращённый вариант\n`@`\n, в шаблонах компонентов.\n<template>\n  <button @click=\"handleClick\">Нажми на меня</button>\n</template>\n<script>\nexport default {\n  methods: {\n    handleClick() {\n      console.log('Кнопка была нажата!');\n    }\n  }\n}\n</script>\nAngular\nДля добавления слушателей событий используются круглые скобки `()` вокруг названия события в шаблонах компонентов. Функция-обработчик указывается внутри компонента.\n<button (click)=\"handleClick()\">Нажми на меня</button>\n@Component({\n  // selector, template, etc.\n})\nexport class AppComponent {\n  handleClick() {\n    console.log('Кнопка была нажата!');\n  }\n}\nКаждый из этих подходов позволяет эффективно отслеживать и реагировать на события в приложении, улучшая интерактивность и пользовательский опыт.",
    videos: [
      {
        url: "https://youtu.be/gV6eobXisYU?t=1856",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 1856,
      },
      {
        url: "https://youtu.be/umHjpWydn8I?t=1422",
        title: "50 вопросов на Vue JS собеседование",
        time: 1422,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1820,
    question: "Назови отличия директив v show и v if",
    explanation:
      "Директивы\n`v-show`\nи\n`v-if`\nиспользуются для условного рендеринга элементов, но они работают по-разному и имеют разные применения в зависимости от ситуации.\n`v-if`\nФункциональность:\nКогда его условие истинно, элемент будет отрендерен. Если условие ложно, элемент не будет отрендерен и не появится в DOM.\nИспользование ресурсов:\nПоскольку он полностью добавляет или удаляет элементы из DOM, это может быть более затратно с точки зрения производительности при частых переключениях, особенно для больших блоков элементов.\nПрименение:\nЛучше всего подходит для случаев, когда необходимо условно отобразить элементы, и вероятность их частого переключения невелика. Также его стоит использовать, когда нужно избежать рендеринга элемента по условию (например, для экономии ресурсов или когда элемент не должен присутствовать в DOM по умолчанию).\n`v-show`\nФункциональность:\nИзменяет CSS-свойство `display` элемента в зависимости от истинности условия. Если условие истинно, элемент будет показан (\n`display`\nне равен\n`none`\n), если ложно — скрыт (\n`display`\nравен\n`none`\n). Элемент остаётся в DOM независимо от условия.\nИспользование ресурсов:\nПоскольку элемент с ним всегда присутствует в DOM, переключение между состояниями видимости происходит быстрее, чем у него, которому нужно каждый раз заново создавать или удалять элементы.\nПрименение:\nПодходит для случаев, когда элементы должны быть часто показаны или скрыты, так как переключение видимости происходит быстрее. Однако, начальная загрузка может занять больше времени, поскольку все элементы с ним сразу же добавляются в DOM.\nКлючевые отличия\n1.\nВлияние на DOM:\n`v-if`\nудаляет или добавляет элементы в DOM, в то время как `v-show` просто переключает их видимость через CSS.\n2.\nПроизводительность:\n`v-if`\nимеет большее влияние на производительность при инициализации, так как элементы физически добавляются или удаляются из DOM.\n`v-show`\nможет быть более производительным при частом переключении видимости, так как элементы остаются в DOM и просто скрываются.\n3.\nПрименение:\nВыбор между\n`v-if`\nи\n`v-show`\nзависит от конкретного случая использования —\n`v-if`\nлучше для условий, которые меняются редко, в то время как\n`v-show`\nлучше для элементов, чья видимость часто переключается.\nВыбор между\n`v-show`\nи\n`v-if`\nдолжен базироваться на потребностях вашего приложения, учитывая частоту изменений условий отображения и влияние на производительность.",
    videos: [
      {
        url: "https://youtu.be/gV6eobXisYU?t=1869",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 1869,
      },
      {
        url: "https://youtu.be/umHjpWydn8I?t=819",
        title: "50 вопросов на Vue JS собеседование",
        time: 819,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1821,
    question: "Какой опыт программирования",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/NRufVTyELC4?t=368",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 368,
      },
      {
        url: "https://youtu.be/NpQFVZoy4T8?t=6127",
        title: "FRONTEND СОБЕСЕДОВАНИЕ С БЫВШИМ РУКО…",
        time: 6127,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1822,
    question: "С каким фреймворком понравилось работать больше",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/NRufVTyELC4?t=864",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 864,
      },
      {
        url: "https://youtu.be/lq4eefCCuVo?t=524",
        title: "Реальное СОБЕСЕДОВАНИЕ на FRONTEND р…",
        time: 524,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1823,
    question: "Какие структуры данных есть в js",
    explanation:
      'Существует несколько встроенных структур данных, которые помогают организовать и хранить данные эффективным образом. Основные структуры данных включают:\n1.\nМассивы (Arrays)\nЭто упорядоченные коллекции элементов, которые могут содержать данные любого типа. Они являются гибкими и могут изменять размер динамически.\nlet fruits = ["Apple", "Banana", "Cherry"];\n2.\nОбъекты (Objects)\nПредставляют собой неупорядоченные коллекции пар ключ-значение. Они используются для хранения разнородных данных и сложных структур.\nlet person = {\n  name: "John",\n  age: 30,\n  isEmployed: true\n};\n3.\nМножества (Sets)\nЭто коллекция уникальных значений любого типа. Основное преимущество использования множеств заключается в том, что они автоматически удаляют дубликаты.\nlet mySet = new Set([1, 2, 3, 2, 1]);\nconsole.log(mySet); // Выведет Set {1, 2, 3}\n4.\nСловари / Карты (Maps)\nЭто коллекция пар ключ-значение, где ключи могут быть любого типа. В отличие от объектов, ключи в нем могут быть не только строками или символами.\nlet myMap = new Map([\n  ["key1", "value1"],\n  ["key2", "value2"]\n]);\n5.\nСлабые множества (WeakSets) и слабые карты (WeakMaps)\nЭто специальные версии\n`Set`\nи\n`Map`\nсоответственно, которые позволяют сборщику мусора автоматически удалить элементы, если на них больше нет ссылок. Они полезны для оптимизации памяти, но имеют более ограниченный API.\nlet weakSet = new WeakSet();\nlet obj = {};\nweakSet.add(obj);\nlet weakMap = new WeakMap();\nlet key = {};\nweakMap.set(key, "value");\n6.\nСимволы (Symbols)\nЭто уникальный и неизменяемый тип данных, используемый в качестве идентификатора для свойств объектов.\nlet sym = Symbol("description");\n7.\nТипизированные массивы (Typed Arrays)\nПредоставляют способ работы с бинарными данными и позволяют интерпретировать байты в массиве как числа специфического типа. Они полезны для работы с данными, получаемыми из сети, файлов или для использования в графических операциях.\nlet typedArray = new Uint8Array(8);\nКаждая из этих структур данных имеет свои особенности и предназначена для решения специфических задач, таких как оптимизация производительности, управление памятью, упорядочивание данных и т.д. Выбор подходящей структуры данных зависит от конкретных требований и условий задачи.',
    videos: [
      {
        url: "https://youtu.be/NRufVTyELC4?t=1688",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 1688,
      },
      {
        url: "https://youtu.be/g5LdFoV6iUg?t=2028",
        title: "#12 Фронтенд-разработчик нейросети н…",
        time: 2028,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1824,
    question: "Что делает метод apply",
    explanation:
      'Метод\n`apply`\nиспользуется для вызова функции с указанием контекста\n`this`\nи аргументов, передаваемых в виде массива (или массивоподобного объекта). Это один из методов управления контекстом вызова функции, наряду с\n`call`\nи\n`bind`\n.\nСинтаксис\nfunc.apply(thisArg, [argsArray])\n`thisArg`\n— значение, которое будет использоваться как `this` во время вызова\n`func`\n.\n`argsArray`\n— массив или массивоподобный объект, содержащий аргументы, которые будут переданы функции.\nОтличие от метода `call`.\nМетод\n`apply`\nочень похож на данный метод, основное отличие между ними заключается в том, как они принимают аргументы. Метод `call` принимает аргументы в виде списка, разделенных запятыми, в то время как он принимает аргументы в виде массива.\nfunction say(message, additional) {\n  console.log(`${this.name}: ${message} ${additional}`);\n}\nconst person = {\n  name: "Алекс"\n};\n// Использование apply для вызова функции\nsay.apply(person, ["Привет", "как дела?"]);\nВ этом примере, он используется для вызова функции\n`say`\nтак, что внутри\n`say`\nзначение\n`this`\nбудет указывать на объект\n`person`\n, а аргументы для функции передаются в виде массива.\nИспользование\nДанный метод полезен в ситуациях, когда необходимо вызвать функцию с динамически формируемым набором аргументов или когда нужно явно установить контекст\n`this`\nдля вызываемой функции. Он также часто используется вместе с функциями, принимающими переменное количество аргументов, или для методов, которые должны быть вызваны в контексте других объектов.\n`apply`\nможет быть полезен для вызова встроенных функций с аргументами, содержащимися в массиве. Например, использование\n`Math.max.apply(null, arrayOfNumbers)`\nдля нахождения максимального числа в массиве, где\n`arrayOfNumbers`\n— это массив чисел.',
    videos: [
      {
        url: "https://youtu.be/lq4eefCCuVo?t=1549",
        title: "Реальное СОБЕСЕДОВАНИЕ на FRONTEND р…",
        time: 1549,
      },
      {
        url: "https://youtu.be/0fI5sTI5uck?t=1296",
        title: "Собеседование в Яндексе - Разработчи…",
        time: 1296,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1825,
    question: "Что такое самовызывающаяся функция",
    explanation:
      "Самовызывающаяся функция, также известная как IIFE (Immediately Invoked Function Expression — немедленно вызываемое функциональное выражение), это функция, которая определяется и выполняется автоматически, как только она была определена. Основное назначение — создание области видимости для переменных и функций, чтобы они не засоряли глобальное пространство имен и не вступали в конфликт с другим кодом на странице или в приложении.\nСтруктура IIFE\nОбычно заключается в круглые скобки, которые обозначают функциональное выражение, за которыми следует ещё одна пара круглых скобок, вызывающих эту функцию:\n(function() {\n  // Тело функции\n})();\nПример:\n(function() {\n  var localVar = 'Я локальная переменная';\n  console.log(localVar); // Выводит: Я локальная переменная\n})();\n// localVar не доступна здесь, в глобальной области видимости\nПараметры\nТакже могут принимать параметры, которые передаются через вторую пару скобок:\n(function(message) {\n  console.log(message); // Выводит: Привет!\n})('Привет!');\nЗачем использовать IIFE?\n1.\nИзоляция переменных:\nСоздаёт новую область видимости, что позволяет избежать конфликтов имен переменных и функций с другим кодом в глобальной области видимости.\n2.\nОрганизация кода:\nКод внутри легко организовать и поддерживать, так как он является самодостаточным.\n3.\nПриватность:\nПеременные и функции, объявленные внутри нее, не доступны извне, что обеспечивает их приватность.\n4.\nИспользование в модулях:\nВ старых стандартах JavaScript, до введения модулей ES6, она часто использовались для имитации модульности, позволяя «инкапсулировать» модуль и его зависимости.\nНесмотря на то что в современном JS для создания модулей и инкапсуляции кода чаще используются другие подходы (например, модули ES6), IIFE всё ещё могут быть полезны в определённых ситуациях, особенно при работе с кодом, который должен быть совместим с более старыми версиями JavaScript.\nMarch 3, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/Y1SekvuZ3M4?t=987",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 987,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=1350",
        title: "Собеседование cтажера Frontend разра…",
        time: 1350,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1826,
    question: "Как работают map, reduce и filter",
    explanation:
      'Методы\n`map`\n,\n`reduce`\nи\n`filter`\nявляются частью прототипа массива и предоставляют мощные инструменты для обработки и трансформации массивов без необходимости использования циклов\n`for`\nили\n`while`\n. Эти функции высшего порядка принимают коллбэк-функцию в качестве аргумента и применяют её к каждому элементу массива, облегчая таким образом работу с массивами.\nMap\nСоздаёт новый массив, результатом выполнения функции, переданной в качестве аргумента для каждого элемента исходного массива.\nconst numbers = [1, 2, 3, 4];\nconst squaredNumbers = numbers.map(function(num) {\n  return num * num;\n});\nconsole.log(squaredNumbers); // [1, 4, 9, 16]\nFilter\nСоздаёт новый массив со всеми элементами исходного массива, для которых коллбэк-функция возвращает\n`true`\n. Это позволяет "фильтровать" массив, оставляя в нём только те элементы, которые соответствуют определённому условию.\nconst numbers = [1, 2, 3, 4];\nconst evenNumbers = numbers.filter(function(num) {\n  return num % 2 === 0;\n});\nconsole.log(evenNumbers); // [2, 4]\nReduce\nПрименяет функцию к аккумулятору и каждому элементу массива (слева направо), чтобы свести его к одному значению. Это делает он, очень мощным инструментом для агрегации данных.\nconst numbers = [1, 2, 3, 4];\nconst sum = numbers.reduce(function(accumulator, currentValue) {\n  return accumulator + currentValue;\n}, 0);\nconsole.log(sum); // 10\nЗдесь\n`0`\n- начальное значение аккумулятора. Если его не указать, то в качестве начального значения будет использоваться первый элемент массива, а обработка начнётся со второго.\nЭти методы делают код более чистым и понятным, предоставляя простые и мощные инструменты для обработки данных.\nMarch 3, 2024, easyoffer',
    videos: [
      {
        url: "https://youtu.be/Y1SekvuZ3M4?t=1134",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 1134,
      },
      {
        url: "https://youtu.be/MHrKcnyN46M?t=693",
        title: "СОБЕСЕДОВАНИЕ НА FRONTEND РАЗРАБОТЧИ…",
        time: 693,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1827,
    question: "Что такое стрелочная функция",
    explanation:
      "Стрелочная функция — это компактный способ объявления функций, введённый в ES6 (ECMAScript 2015). Имеют более короткий синтаксис по сравнению с традиционными функциями и лексически привязывают контекст\n`this`\n, что делает их особенно удобными для использования в обработчиках событий и коллбэках.\nСинтаксис\nОсновной синтаксис стрелочной функции выглядит следующим образом:\nconst functionName = (аргументы) => {\n  // тело функции\n};\nЕсли функция принимает только один аргумент, скобки вокруг параметров можно опустить:\nconst functionName = аргумент => {\n  // тело функции\n};\nЕсли тело функции состоит из одного выражения, которое должно быть возвращено, можно опустить фигурные скобки и слово\n`return`\n:\nconst functionName = аргумент => выражение;\nПримеры:\nБез аргументов:\nconst sayHello = () => console.log('Привет!');\nsayHello(); // Выводит: Привет!\nС одним аргументом:\nconst square = x => x * x;\nconsole.log(square(5)); // Выводит: 25\nС несколькими аргументами:\nconst sum = (a, b) => a + b;\nconsole.log(sum(5, 7)); // Выводит: 12\nВозвращающая объект:\nЧтобы вернуть объект, его нужно обернуть в круглые скобки:\nconst getObject = () => ({ key: 'value' });\nconsole.log(getObject()); // Выводит: { key: 'value' }\nОсобенности\nЛексический контекст `this`:\nВ отличие от обычных функций, стрелочные функции не создают собственного контекста\n`this`\n. Значение\n`this`\nвнутри стрелочной функции определяется контекстом, в котором она была создана. Это особенно полезно для коллбэков и обработчиков событий.\nНе имеют `arguments`:\nСтрелочные функции не имеют объекта\n`arguments`\n. Чтобы получить все аргументы функции, можно использовать оператор расширения (\n`...`\n).\nНе могут быть использованы как конструкторы:\nСтрелочные функции не могут быть использованы с оператором\n`new`\n.\nОтсутствие прототипа:\nУ стрелочных функций нет свойства\n`prototype`\n, поэтому они не могут быть использованы для создания прототипных наследников.\nСтрелочные функции делают синтаксис короче и чище, а также упрощают работу с контекстом\n`this`\n, что делает их предпочтительным выбором во многих сценариях.\nMarch 3, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/Y1SekvuZ3M4?t=1254",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 1254,
      },
      {
        url: "https://youtu.be/EaTZXKlpsj0?t=5799",
        title: "#11 Фронтендер в 17 лет? Собеседован…",
        time: 5799,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1828,
    question: "Зачем нужен виртуальный дом",
    explanation:
      "Виртуальный DOM (VDOM) — это концепция, широко используемая в современных фронтенд-фреймворках и библиотеках. Он представляет собой легковесную копию реального DOM-дерева в памяти, что позволяет оптимизировать процесс обновления интерфейса пользователя.\nЗачем нужен виртуальный DOM:\n1.\nОптимизация производительности:\nПрямые манипуляции с ним могут быть дорогостоящими с точки зрения производительности, особенно при частых обновлениях. Виртуальный DOM позволяет минимизировать количество операций с реальным DOM, обновляя только те части интерфейса, которые действительно изменились.\n2.\nБыстрое сравнение состояний:\nПозволяет эффективно сравнивать предыдущее и текущее состояния интерфейса, определяя минимально необходимые изменения для синхронизации с реальным DOM. Это достигается за счет использования алгоритмов сравнения, которые могут быстро определить различия между двумя версиями виртуального DOM.\n3.\nУпрощение разработки:\nРабота с ним абстрагирует разработчика от прямой манипуляции с элементами интерфейса, делая процесс разработки более простым и интуитивно понятным. Разработчики могут сосредоточиться на логике приложения, а не на том, как именно должны быть реализованы изменения в DOM.\n4.\nПовышение отзывчивости приложения:\nПоскольку обновления в нем выполняются намного быстрее, чем манипуляции с реальным DOM, приложения становятся более отзывчивыми и приятными в использовании.\n5.\nКроссплатформенность:\nОбеспечивает дополнительный уровень абстракции, который может быть реализован в различных средах, не только в браузерах. Это позволяет использовать один и тот же код для рендеринга интерфейсов в браузере, на сервере или даже в нативных мобильных приложениях.\nВиртуальный DOM является ключевым элементом для повышения производительности и упрощения разработки современных веб-приложений, делая возможным создание сложных, динамичных и высокоинтерактивных пользовательских интерфейсов.\nMarch 3, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/Y1SekvuZ3M4?t=1368",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 1368,
      },
      {
        url: "https://youtu.be/YwRgLQ0SoKk?t=3372",
        title: "Собеседование frontend разработчика",
        time: 3372,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1829,
    question: "Назови компоненты жизненного цикл",
    explanation:
      "Жизненный цикл компонентов — это серия этапов, через которые проходит компонент в процессе его создания, обновления и уничтожения. Рассмотрим на примере React, так как он является одной из самых популярных библиотек с явно выраженным концептом жизненного цикла компонентов.\nМонтаж (Mounting)\nЭти методы вызываются в момент добавления компонента в DOM.\n1.\nconstructor(props):\nКонструктор компонента, где можно инициализировать состояние и привязать обработчики событий.\n2.\nstatic getDerivedStateFromProps(props, state):\nВызывается непосредственно перед рендерингом как при монтаже, так и при обновлении. Используется для того, чтобы состояние компонента зависело от изменений в props.\n3.\nrender():\nМетод для рендеринга компонента. Должен быть чистой функцией, не производящей побочных эффектов.\n4.\ncomponentDidMount():\nВызывается сразу после монтажа (вставки компонента в DOM). Здесь можно выполнять запросы к удаленным ресурсам, подписываться на события и т.д.\nОбновление (Updating)\nЭти методы вызываются при обновлении компонента из-за изменений props или state.\n1.\nstatic getDerivedStateFromProps(props, state):\nТакже вызывается при обновлении компонента.\n2.\nshouldComponentUpdate(nextProps, nextState):\nПозволяет оптимизировать приложение, предотвращая ненужный рендеринг.\n3. render()**: Вызывается снова для рендеринга обновлённого компонента.\n4.\ngetSnapshotBeforeUpdate(prevProps, prevState):\nВызывается перед самым обновлением DOM. Позволяет захватить некоторые данные из DOM (например, позицию скролла), чтобы потом, возможно, восстановить их.\n5.\ncomponentDidUpdate(prevProps, prevState, snapshot):\nВызывается сразу после обновления компонента. Здесь можно выполнять запросы к серверу при изменении props.\nРазмонтирование (Unmounting)\n1.\ncomponentWillUnmount():\nВызывается перед удалением компонента из DOM. Используется для выполнения необходимой очистки: отмены подписок, отмены запросов и т.д.\nОшибки (Error Handling)\n1.\nstatic getDerivedStateFromError(error):\nИспользуется, когда в одном из дочерних компонентов возникла ошибка при рендеринге, в методе жизненного цикла или в конструкторе.\n2.\ncomponentDidCatch(error, info):\nИспользуется для логирования информации об ошибке.\nЭти этапы жизненного цикла предоставляют гибкие возможности для управления компонентами на разных этапах их существования, оптимизации производительности и обработки ошибок.\nMarch 3, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/Y1SekvuZ3M4?t=1657",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 1657,
      },
      {
        url: "https://youtu.be/YwRgLQ0SoKk?t=3952",
        title: "Собеседование frontend разработчика",
        time: 3952,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1830,
    question: "Что такое redux",
    explanation:
      'Redux — это библиотека для управления состоянием приложений. Чаще всего используется в сочетании с React, но может применяться и с другими библиотеками или фреймворками вроде Angular или Vue.js. Он предлагает удобный способ централизованно хранить всё состояние приложения в одном месте, называемом "хранилищем" (store), делая изменения состояния предсказуемыми благодаря строгим правилам обновления.\nОсновные принципы:\n1.\nЕдиный источник истины:\nВесь состав состояния приложения хранится в одном объекте-хранилище, что облегчает наблюдение за изменениями и отладку.\n2.\nСостояние доступно только для чтения:\nСостояние нельзя изменить напрямую. Для изменения состояния используются чистые функции, называемые редьюсерами (reducers), которые принимают предыдущее состояние и действие, а возвращают новое состояние.\n3.\nИзменения с помощью чистых функций:\nЭто чистые функции, которые описывают, каким образом действие трансформирует состояние приложения в следующее состояние.\nОсновные компоненты:\nХранилище (Store):\nХранит состояние всего приложения. В приложении может быть только одно хранилище.\nДействия (Actions):\nОбъекты, которые передают данные из приложения в хранилище. Действия отправляются в хранилище с помощью метода\n`dispatch()`\n.\nРедьюсеры (Reducers):\nЧистые функции, которые определяют, как изменяется состояние в ответ на действие. Редьюсеры принимают текущее состояние и действие в качестве аргументов и возвращают новое состояние.\nПодписки (Subscriptions):\nМеханизмы, позволяющие компонентам приложения подписываться на обновления состояния хранилища, чтобы при каждом его изменении компоненты могли реагировать соответствующим образом.\nПочему использовать Redux?\nУпрощение управления состоянием:\nОсобенно в больших приложениях с комплексным состоянием и множеством изменений, которые нужно синхронизировать между различными частями приложения.\nОтладка и разработка:\nПредлагают мощные средства для отладки приложений, включая возможность перемещения назад и вперед по "времени" изменений состояния.\nСохранение состояния:\nВозможность сохранять и восстанавливать состояние приложения, что может быть полезно для функций отладки, тестирования и сохранения пользовательской сессии.\nRedux вносит дополнительную сложность в приложение и может быть излишним для маленьких проектов, где простое управление состоянием через контекст React или другие локальные механизмы может оказаться более целесообразным.\nMarch 3, 2024, easyoffer',
    videos: [
      {
        url: "https://youtu.be/Y1SekvuZ3M4?t=2143",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 2143,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=3444",
        title: "Собеседование cтажера Frontend разра…",
        time: 3444,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1831,
    question: "Зачем нужен redux",
    explanation:
      'Redux предоставляет удобный способ централизованного управления состоянием, что особенно важно в крупных и сложных веб-приложениях. Вот несколько ключевых причин, почему его стоит выбрать:\n1.\nПредсказуемость состояния\nОбеспечивает предсказуемое изменение состояния, следуя трём основным принципам: единый источник истины (всё состояние приложения хранится в одном объекте), состояние доступно только для чтения (изменить состояние можно только отправив действие), изменения производятся с помощью чистых функций (редьюсеров). Это делает поведение приложения более понятным и предсказуемым.\n2.\nУпрощение управления состоянием\nВ больших приложениях, где состояние может распространяться через множество компонентов и может быть изменено в различных местах, централизованное управление состоянием упрощает разработку и поддержку.\n3.\nУлучшенная отладка\nС ним легче отслеживать, когда, где, почему и как обновилось состояние приложения. Инструменты, такие как Redux DevTools, позволяют разработчикам просматривать историю состояний, "путешествовать" по ней (time-travel debugging), а также изменять состояние "на лету" для тестирования различных сценариев.\n4.\nУпрощение логики\nМожет помочь упростить логику обработки данных и UI-логику, разделяя ответственности между редьюсерами (для обновления состояния) и компонентами (для отображения UI).\n5.\nПоддержка мидлваров\nПоддерживает мидлвары, что позволяет легко интегрировать дополнительную логику обработки, например, для асинхронных действий (с помощью redux-thunk или redux-saga), логирования, отправки аналитики и многого другого.\n6.\nУниверсальность\nМожет использоваться с любой библиотекой или фреймворком для фронтенда, что делает его универсальным инструментом для управления состоянием в различных проектах.\n7.\nСообщество и экосистема\nБлагодаря своей популярности, у него есть большое и активное сообщество разработчиков, множество руководств, лучших практик, готовых решений и плагинов, что упрощает изучение и использование Redux в проектах.\nRedux вносит дополнительную сложность в проект, поэтому его стоит использовать, когда преимущества централизованного управления состоянием перевешивают эту сложность, например, в больших или сложных приложениях с динамичным состоянием.\nMarch 3, 2024, easyoffer',
    videos: [
      {
        url: "https://youtu.be/Y1SekvuZ3M4?t=2144",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 2144,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=3445",
        title: "Собеседование cтажера Frontend разра…",
        time: 3445,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1832,
    question: "Как работает реактивность в vue.Js",
    explanation:
      'Реактивность — это механизм, который автоматически обновляет пользовательский интерфейс в ответ на изменения состояния приложения. Это одна из ключевых особенностей, позволяющая строить интерактивные и динамичные веб-приложения с минимальными усилиями. В основе механизма реактивности лежит система отслеживания зависимостей между компонентами приложения и их состоянием.\nКак работает реактивность\n1.\nОбъекты данных и Observer:\nПри создании экземпляра Vue, он обходит все свойства в объекте\n`data`\nи преобразует их в геттеры/сеттеры с помощью\n`Object.defineProperty()`\n. Это позволяет ему отслеживать доступ к свойствам.\nКаждое свойство, которое было преобразовано, получает своего "наблюдателя" (Observer), который мониторит изменения.\n2.\nЗависимости и Watcher:\nКогда свойство объекта\n`data`\nиспользуется в шаблоне, Vue создаёт "наблюдателя" (Watcher) для этого свойства. Это устанавливает зависимость между свойством и компонентом, который его использует.\nПри изменении значения свойства Vue уведомляет соответствующие наблюдатели о изменении, что приводит к повторному рендерингу компонента или выполнению других реактивных действий.\n3.\nПовторный рендеринг:\nКогда значение отслеживаемого свойства изменяется, Vue автоматически инициирует перерисовку компонента или выполнение вычисляемых свойств, которые зависят от этого значения. Это гарантирует, что пользовательский интерфейс всегда актуален и отражает текущее состояние приложения.\nРеактивность для массивов\nНе может обнаружить изменения, сделанные с использованием индексов для установки значения в массиве или изменения длины массива напрямую. Вместо этого Vue расширяет массивы новыми методами, такими как\n`push()`\n,\n`pop()`\n,\n`shift()`\n,\n`unshift()`\n,\n`splice()`\n,\n`sort()`\nи\n`reverse()`\n, которые также вызывают реактивные обновления.\nРеактивность в Vue 3\nВнедряет новый API реактивности, используя Proxy вместо\n`Object.defineProperty()`\n, что позволяет отслеживать изменения в гораздо более широком спектре случаев, включая доступ к свойствам через индексы, изменение длины массивов и даже изменения во вложенных объектах.\nМеханизм реактивности значительно упрощает процесс создания интерактивных веб-приложений, автоматизируя обновление пользовательского интерфейса в ответ на изменения состояния. Это делает код более декларативным и легким для понимания.\nMarch 3, 2024, easyoffer',
    videos: [
      {
        url: "https://youtu.be/umHjpWydn8I?t=140",
        title: "50 вопросов на Vue JS собеседование",
        time: 140,
      },
      {
        url: "https://www.youtube.com/watch?v=3D0IVhYzXJM&t=5154s",
        title: "#2 Собеседование смелого Frontend Mi…",
        time: 5154,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1833,
    question: "Расскажите о жизненном цикле компонента vue",
    explanation:
      "Каждый компонент проходит через серию этапов от создания до уничтожения, известных как жизненный цикл компонента. Он предоставляет хуки жизненного цикла, которые дают возможность выполнять код в определённые моменты. Разработчики могут использовать эти хуки для выполнения логики на разных этапах, например, для инициализации данных или очистки перед уничтожением компонента.\nОсновные хуки жизненного цикла:\n1.\nbeforeCreate:\nвызывается сразу после инициализации экземпляра, до инициализации реактивности и событий компонента.\n2.\ncreated:\nвызывается после создания экземпляра. В этой фазе компонент имеет доступ к данным и методам. События и реактивность инициализированы, но DOM ещё не смонтирован.\n3.\nbeforeMount:\nвызывается непосредственно перед монтированием компонента, когда шаблон компилирован в виртуальный DOM, но ещё не применён к реальному DOM.\n4.\nmounted:\nвызывается после монтирования компонента к DOM. В этот момент можно безопасно обращаться к DOM элементам компонента, так как они уже вставлены в документ.\n5.\nbeforeUpdate:\nвызывается при изменении данных, до того как изменения отразятся в DOM. Этот хук позволяет получить доступ к существующему DOM до его обновления.\n6.\nupdated:\nвызывается после того, как изменения в данных привели к обновлению DOM. Важно избегать изменений состояния в этом хуке, чтобы не вызвать бесконечный цикл обновлений.\n7.\nbeforeDestroy:\nвызывается прямо перед уничтожением экземпляра компонента. В этот момент экземпляр всё ещё полностью функционален.\n8.\ndestroyed:\nвызывается после уничтожения компонента. Все директивы компонента разрешены, и все обработчики событий удалены в этот момент.\nХуки активации и деактивации (для `<keep-alive>`):\nactivated:\nвызывается после активации содержимого\n`<keep-alive>`\n.\ndeactivated:\nвызывается после деактивации содержимого `<keep-alive>`.\nЭти хуки используются для управления ресурсами в компонентах, которые сохраняют своё состояние в\n`<keep-alive>`\n.\nПонимание жизненного цикла компонента важно, так как оно позволяет максимально точно определять, в какой момент выполнять определённые действия, например, загрузку данных с сервера, анимации или очистку ресурсов.\nMarch 3, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/umHjpWydn8I?t=1124",
        title: "50 вопросов на Vue JS собеседование",
        time: 1124,
      },
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=6034s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 6034,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1834,
    question: "Как проверить, что поле является массивом",
    explanation:
      "Для проверки того, является ли значение массивом, можно использовать статический метод\n`Array.isArray()`\n. Этот метод возвращает\n`true`\n, если переданный ему аргумент является массивом, и\n`false`\nв противном случае.\nПример:\nconsole.log(Array.isArray([1, 2, 3]));  // true\nconsole.log(Array.isArray({a: 1, b: 2}));  // false\nconsole.log(Array.isArray('Hello world'));  // false\nconsole.log(Array.isArray(undefined));  // false\nПочему лучше использовать `Array.isArray()`:\nДо его появления, определить, является ли объект массивом, было несколько сложнее, особенно с учетом различий в реализации между разными браузерами и средами выполнения. Разработчики использовали различные приемы, например, проверку\n`typeof`\nили проверку через\n`Object.prototype.toString.call()`\n, которая возвращала\n`[object Array]`\nдля массивов:\nvar myArray = [1, 2, 3];\nif (Object.prototype.toString.call(myArray) === '[object Array]') {\n  console.log('Это массив!');\n}\nОднако\n`Array.isArray()`\nявляется наиболее надежным и простым способом проверки, поддерживаемым во всех современных браузерах и средах. Этот метод был добавлен в стандарт ECMAScript 5, поэтому он может не поддерживаться в очень старых браузерах, что сегодня уже редко является проблемой.\nMarch 3, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/jf5TkGzWqiM?t=148",
        title: "Собеседование JUNIOR FRONTEND REACT …",
        time: 148,
      },
      {
        url: "https://youtu.be/B1IbTKdgCeE?t=891",
        title: "Крушитель алгоритмов? Собеседование …",
        time: 891,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1835,
    question: "Какие главные особенности куки",
    explanation:
      'Куки (cookies) — это небольшие фрагменты данных, которые веб-сайты сохраняют на компьютере пользователя через веб-браузер. Они играют важную роль в веб-разработке, позволяя сайтам "запоминать" информацию о посетителе, его предпочтениях и сессиях. Вот некоторые из главных особенностей:\n1.\nСохранение сессий пользователя\nЧасто используются для отслеживания сессий пользователя, позволяя веб-сайтам аутентифицировать пользователей после входа в систему. Это позволяет пользователям переходить между страницами сайта без необходимости повторного входа на каждой странице.\n2.\nХранение предпочтений пользователя\nСайты используют их для сохранения пользовательских настроек и предпочтений, таких как язык интерфейса, тема оформления или предпочтения в отображении контента. Это улучшает пользовательский опыт, делая веб-сайты более персонализированными.\n3.\nОтслеживание и аналитика\nИспользуются для сбора данных об использовании веб-сайта пользователями. Это позволяет анализировать трафик и поведение посетителей для оптимизации сайта и создания более эффективной маркетинговой стратегии.\n4.\nРекламное таргетирование\nС помощью них рекламные сети могут отслеживать активность пользователя в интернете и показывать рекламу, соответствующую его интересам. Это повышает эффективность рекламных кампаний.\nОграничения и недостатки\nОграничение размера:\nОно ограничено примерно 4 КБ данных, что ограничивает объем информации, которую можно в них хранить.\nКоличество куки:\nБраузеры ограничивают их количество, которые сайт может сохранить на компьютере пользователя, а также общее количество куки, которое может быть сохранено.\nБезопасность:\nМогут быть уязвимыми для различных атак, таких как кража сессий и кросс-сайтовый скриптинг (XSS). Важно корректно настраивать атрибуты безопасности куки, такие как\n`Secure`\n,\n`HttpOnly`\nи\n`SameSite`\n.\nКонфиденциальность и приватность:\nИспользование их для отслеживания действий пользователей вызывает опасения по поводу конфиденциальности, что привело к разработке законодательства в некоторых регионах (например, GDPR в Европейском Союзе), требующего ясного уведомления пользователей и получения их согласия на использование куки.\nКуки являются важным инструментом, но их использование требует внимательного рассмотрения вопросов безопасности и приватности пользователей.\nMarch 3, 2024, easyoffer',
    videos: [
      {
        url: "https://youtu.be/jf5TkGzWqiM?t=280",
        title: "Собеседование JUNIOR FRONTEND REACT …",
        time: 280,
      },
      {
        url: "https://youtu.be/BOCkaqdbdCg?t=3544",
        title: "Собеседование на Junior Frontend раз…",
        time: 3544,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1836,
    question: "Что такое usecontext",
    explanation:
      "`useContext`\n— это один из встроенных хуков, который позволяет компонентам подписываться на контекст и получать доступ к данным контекста. Используется для передачи данных через дерево компонентов без необходимости передавать пропсы на каждом уровне. Это особенно полезно для глобальных данных, таких как текущий авторизованный пользователь, тема (светлая/темная) или настройки локализации.\nКак он работает\n1. Создание контекста\nДля создания контекста используется функция\n`createContext`\n. Она возвращает объект контекста, который содержит два компонента:\n`Provider`\nи\n`Consumer`\n.\n```javascript\n   import React, { createContext, useState } from 'react';\n   const MyContext = createContext();\n   ```\n2. Provider\nКомпонент\n`Provider`\nиспользуется для предоставления значения контекста всем дочерним компонентам. Все компоненты внутри\n`Provider`\nмогут получить доступ к значениям, переданным в\n`value`\n.\n```javascript\n   const MyProvider = ({ children }) => {\n     const [state, setState] = useState('Hello World');\n     return (\n       <MyContext.Provider value={{ state, setState }}>\n         {children}\n       </MyContext.Provider>\n     );\n   };\n   ```\n3. useContext\nИспользуется для подписки на контекст в функциональных компонентах. Он принимает объект контекста, возвращаемый из\n`createContext`\n, и возвращает текущее значение контекста.\n```javascript\n   import React, { useContext } from 'react';\n   const MyComponent = () => {\n     const { state, setState } = useContext(MyContext);\n     return (\n       <div>\n         <p>{state}</p>\n         <button onClick={() => setState('New Value')}>Change Value</button>\n       </div>\n     );\n   };\n   ```\nПолный пример\n```javascript\nimport React, { createContext, useState, useContext } from 'react';\n// Создание контекста\nconst MyContext = createContext();\nconst MyProvider = ({ children }) => {\n  const [state, setState] = useState('Hello World');\n  return (\n    <MyContext.Provider value={{ state, setState }}>\n      {children}\n    </MyContext.Provider>\n  );\n};\nconst MyComponent = () => {\n  const { state, setState } = useContext(MyContext);\n  return (\n    <div>\n      <p>{state}</p>\n      <button onClick={() => setState('New Value')}>Change Value</button>\n    </div>\n  );\n};\nconst App = () => (\n  <MyProvider>\n    <MyComponent />\n  </MyProvider>\n);\nexport default App;\n```\n`useContext`\n— это хук, который позволяет компонентам получать данные из контекста. Он используется для доступа к глобальным данным без необходимости передавать пропсы на каждом уровне компонента.\nJune 1, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/jf5TkGzWqiM?t=2212",
        title: "Собеседование JUNIOR FRONTEND REACT …",
        time: 2212,
      },
      {
        url: "https://youtu.be/YwRgLQ0SoKk?t=3786",
        title: "Собеседование frontend разработчика",
        time: 3786,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1837,
    question: "Что такое схлопывание границ",
    explanation:
      'Схлопывание границ (или\nсхлопывание отступов\n,\nmargin collapsing\n) — это поведение CSS, при котором вертикальные отступы (margins) соседних блоков могут быть объединены (схлопнуты) в один отступ. Это позволяет избежать удвоения вертикальных отступов между элементами и упрощает их управление.\nОсновные правила\n1. Смежные вертикальные отступы:\nКогда два вертикальных отступа соседних блоков соприкасаются, они схлопываются в один. Размер схлопнутого отступа равен наибольшему из двух схлопывающихся отступов.\n```html\n   <div class="block1"></div>\n   <div class="block2"></div>\n   ```\nВ данном случае итоговый отступ между\n`.block1`\nи\n`.block2`\nбудет 30px, а не 50px.\n2. Родитель и первый/последний дочерний элемент:\nЕсли первый или последний дочерний элемент имеет вертикальный отступ, он схлопывается с отступом родительского элемента, если между ними нет границ, внутреннего отступа или контента.\n```html\n   <div class="parent">\n     <div class="child"></div>\n   </div>\n   ```\nВ этом случае итоговый отступ сверху для\n`.child`\nбудет 20px, так как отступ\n`.child`\nсхлопывается с отступом родителя.\n3. Пустые блоки:\nЕсли блок не содержит контента, границ или внутреннего отступа, его вертикальные отступы также могут схлопываться.\nПримеры\nСхлопывание между соседними элементами\n```html\n<div class="box1">Box 1</div>\n<div class="box2">Box 2</div>\n```\nИтоговый отступ между\n`.box1`\nи\n`.box2`\nбудет 30px.\nСхлопывание границ родителя и первого/последнего дочернего элемента\n```html\n<div class="container">\n  <div class="content">Content</div>\n</div>\n```\nИтоговый верхний отступ для\n`.content`\nбудет 25px, так как отступы схлопываются.\nИсключения и предотвращение схлопывания\nГраницы или внутренние отступы:\nЕсли между элементами добавить границу или внутренний отступ, схлопывания не произойдет.\n```css\n  .parent {\n    padding-top: 1px;\n  }\n  ```\nFlexbox и Grid:\nЭлементы, расположенные с помощью Flexbox или Grid, не схлопывают свои отступы.\nБлоки с\n`overflow: hidden`\n,\n`position: absolute`\n, или\n`display: inline-block`\n:\nТакие блоки не участвуют в схлопывании отступов.\nСхлопывание границ\n— это процесс объединения вертикальных отступов соседних блоков в один, чтобы избежать удвоения отступов. В результате итоговый отступ равен наибольшему из схлопывающихся отступов.\nJune 1, 2024, easyoffer',
    videos: [
      {
        url: "https://youtu.be/PLwrvZahiO4?t=322",
        title: "Собеседование на JavaScript разработ…",
        time: 322,
      },
      {
        url: "https://youtu.be/e2r3JAuMSSg?t=4912",
        title: "#1. Публичное собеседование JUNIOR F…",
        time: 4912,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1838,
    question: "В чем преимущество методологии bem",
    explanation:
      'Методология БЭМ (Блок, Элемент, Модификатор)\n— это подход к написанию и организации CSS кода, который помогает создавать масштабируемые и поддерживаемые интерфейсы. Основные преимущества методологии:\n1. Четкая структура и семантика\nБЭМ обеспечивает ясную и логичную структуру именования классов, что делает код более читаемым и понятным. Это особенно полезно в больших проектах.\n```html\n<div class="button button--primary">\n  <span class="button__text">Click me</span>\n</div>\n```\n`button`\n— блок\n`button__text`\n— элемент\n`button--primary`\n— модификатор\n2. Изоляция компонентов\nБлоки в БЭМ независимы и изолированы друг от друга, что предотвращает проблемы с каскадностью и неожиданным переопределением стилей.\n```html\n<div class="header">\n  <div class="header__logo"></div>\n  <div class="header__nav"></div>\n</div>\n<div class="footer">\n  <div class="footer__logo"></div>\n</div>\n```\nКлассы\n`.header__logo`\nи\n`.footer__logo`\nне пересекаются и не влияют друг на друга.\n3. Легкость в переиспользовании\nБлоки можно легко переиспользовать в разных частях проекта или даже в разных проектах без изменения их стилей.\n```html\n<div class="card">\n  <div class="card__title">Title</div>\n  <div class="card__content">Content</div>\n</div>\n<div class="profile">\n  <div class="card">\n    <div class="card__title">Profile Title</div>\n    <div class="card__content">Profile Content</div>\n  </div>\n</div>\n```\n4. Удобство в поддержке и масштабировании\nБлагодаря четкой структуре и изоляции, код написанный по БЭМ легче поддерживать и масштабировать. Добавление новых компонентов или модификация существующих не вызывает каскадных изменений в других частях системы.\n5. Унификация стилей\nМетодология БЭМ способствует унификации и стандартизации стилей, что упрощает работу с проектом и делает его более предсказуемым.\nПример\nHTML:\n```html\n<div class="menu">\n  <div class="menu__item menu__item--active">Home</div>\n  <div class="menu__item">About</div>\n  <div class="menu__item">Contact</div>\n</div>\n```\nCSS:\n```css\n.menu {\n  background-color: #fff;\n  border: 1px solid #ccc;\n}\n.menu__item {\n  padding: 10px;\n  color: #333;\n}\n.menu__item--active {\n  background-color: #007bff;\n  color: #fff;\n}\n```\nМетодология БЭМ упрощает чтение, поддержку и масштабирование кода за счет четкой структуры, изоляции компонентов и унификации стилей. Она делает интерфейсы более предсказуемыми и удобными для работы в команде.\nJune 1, 2024, easyoffer',
    videos: [
      {
        url: "https://youtu.be/PLwrvZahiO4?t=464",
        title: "Собеседование на JavaScript разработ…",
        time: 464,
      },
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=1089",
        title: "Первое интервью фронтендера самоучки…",
        time: 1089,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1839,
    question: "Что такое всплытие",
    explanation:
      "Всплытие (или\nбабблинг\n,\nevent bubbling\n) — это механизм обработки событий в веб-разработке, при котором событие, происходящее на одном элементе, сначала обрабатывается этим элементом, а затем последовательно передаётся (всплывает) вверх по дереву DOM к его родительским элементам вплоть до корневого элемента (обычно\n`document`\n).\nКак работает всплытие событий\nКогда это происходит на элементе, сначала выполняются обработчики, прикрепленные к самому элементу, затем к его родителю, потом к родителю родителя, и так далее до\n`document`\n.\nРассмотрим пример с вложенными элементами и обработчиками событий:\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Event Bubbling</title>\n</head>\n<body>\n  <div id=\"parent\" style=\"padding: 20px; background-color: lightblue;\">\n    Parent\n    <div id=\"child\" style=\"padding: 20px; background-color: lightcoral;\">\n      Child\n    </div>\n  </div>\n  <script>\n    document.getElementById('parent').addEventListener('click', () => {\n      alert('Parent clicked!');\n    });\n    document.getElementById('child').addEventListener('click', () => {\n      alert('Child clicked!');\n    });\n  </script>\n</body>\n</html>\n```\nВ этом примере, если вы кликнете на элемент\n`#child`\n, вы увидите два алерта: сначала \"Child clicked!\", затем \"Parent clicked!\". Это происходит потому, что событие клика всплывает от элемента\n`#child`\nк его родителю\n`#parent`\n.\nУправление всплытием\nИногда нужно предотвратить всплытие события, чтобы оно не передавалось родительским элементам. Это можно сделать с помощью метода\n`event.stopPropagation()`\n.\n```html\n<script>\n  document.getElementById('parent').addEventListener('click', () => {\n    alert('Parent clicked!');\n  });\n  document.getElementById('child').addEventListener('click', (event) => {\n    alert('Child clicked!');\n    event.stopPropagation(); // предотвращает всплытие события\n  });\n</script>\n```\nТеперь, если вы кликнете на элемент\n`#child`\n, вы увидите только алерт \"Child clicked!\", так как всплытие события было остановлено.\nЗахват событий\nПомимо всплытия, существует другой этап обработки событий, называемый\nзахватом (event capturing)\n. Событие сначала идет сверху вниз от корневого элемента к цели (начиная с\n`document`\nи заканчивая целевым элементом), а затем поднимается обратно вверх (всплытие).\nЧтобы добавить обработчик на этапе захвата, нужно передать\n`true`\nв качестве третьего аргумента в\n`addEventListener`\n:\n```html\n<script>\n  document.getElementById('parent').addEventListener('click', () => {\n    alert('Parent clicked!');\n  }, true);\n  document.getElementById('child').addEventListener('click', () => {\n    alert('Child clicked!');\n  }, true);\n</script>\n```\nВсплытие событий\n— это механизм, при котором событие сначала обрабатывается целевым элементом, а затем передается его родителям по дереву DOM. Чтобы остановить всплытие, можно использовать\n`event.stopPropagation()`\n.\nJune 1, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/PLwrvZahiO4?t=504",
        title: "Собеседование на JavaScript разработ…",
        time: 504,
      },
      {
        url: "https://youtu.be/wP7XVriACtA?t=1216",
        title: "Frontend Собеседование на Junior раз…",
        time: 1216,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1840,
    question: "Что такое ssr",
    explanation:
      "SSR (Server-Side Rendering)\n— это технология рендеринга веб-страниц на сервере, а не на клиенте. В контексте современных JavaScript-фреймворков, таких как React или Vue.js, это означает, что HTML-код страницы генерируется на сервере и отправляется в браузер уже готовым для отображения. Это отличается от традиционного подхода клиентского рендеринга (Client-Side Rendering, CSR), где HTML генерируется непосредственно в браузере с использованием JavaScript.\nОсновные особенности и преимущества\n1. Улучшение производительности и скорости загрузки:\nПервичный контент:\nПоскольку HTML генерируется на сервере, браузеры могут отображать готовый контент без необходимости ждать загрузки и выполнения JavaScript.\nSEO:\nПоисковые системы лучше индексируют страницы, так как весь контент доступен сразу.\n2. Лучшая поддержка SEO:\nСтатические HTML-страницы, генерируемые сервером, легче индексируются поисковыми системами, что улучшает видимость сайта в поисковых результатах.\n3. Улучшенное восприятие пользователем (First Paint):\nПользователи видят контент быстрее, так как сервер отправляет уже готовую HTML-разметку.\nКак он работает\n1. Запрос от клиента:\nБраузер отправляет запрос на сервер для получения страницы.\n2. Генерация HTML на сервере:\nСервер запускает JavaScript-код для рендеринга компонента или всей страницы.\nСервер генерирует HTML-код и отправляет его клиенту.\n3. Отображение страницы в браузере:\nБраузер получает готовую HTML-страницу и отображает её.\nЗатем JavaScript-фреймворк (например, React или Vue) «гидрирует» страницу, то есть связывает готовую HTML-разметку с JavaScript-кодом, чтобы сделать страницу интерактивной.\nNext.js — популярный фреймворк для React, который поддерживает SSR из коробки.\n1. Установка Next.js:\n```bash\n   npx create-next-app my-ssr-app\n   cd my-ssr-app\n   npm run dev\n   ```\n2. Создание страницы с SSR:\n```javascript\n   // pages/index.js\n   import React from 'react';\n   const Home = ({ data }) => {\n     return (\n       <div>\n         <h1>Server-Side Rendering Example</h1>\n         <p>{data.message}</p>\n       </div>\n     );\n   };\n   // Эта функция вызывается на сервере при каждом запросе к странице\n   export async function getServerSideProps() {\n     // Выполняем запрос к API или базе данных\n     const res = await fetch('https://api.example.com/data');\n     const data = await res.json();\n     // Передаем данные как пропсы в компонент\n     return {\n       props: {\n         data\n       }\n     };\n   }\n   export default Home;\n   ```\nВ этом примере Next.js использует функцию\n`getServerSideProps`\nдля получения данных на сервере перед рендерингом страницы. Эти данные затем передаются в компонент как пропсы и используются для генерации HTML.\nSSR (Server-Side Rendering)\n— это процесс рендеринга веб-страниц на сервере, а не в браузере. Это улучшает производительность, SEO и восприятие пользователем за счет отправки готового HTML-кода с сервера.\nJune 1, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/hDl7w9U-Ly8?t=1596",
        title: "Собеседование на Junior Frontend раз…",
        time: 1596,
      },
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=5436",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 5436,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1841,
    question: "Зачем нужна функция iife",
    explanation:
      "IIFE (Immediately Invoked Function Expression)\n— это функция, которая определяется и вызывается немедленно после ее создания. IIFE полезны по нескольким причинам:\nОсновные преимущества\n1. Изоляция кода:\nСоздают новую область видимости, что помогает избежать загрязнения глобального пространства имен. Это особенно полезно при работе с переменными, которые могут конфликтовать с другими частями кода.\n2. Создание приватных переменных:\nПеременные, объявленные внутри IIFE, не доступны снаружи, что делает их приватными. Это помогает защитить данные и функции от нежелательного доступа или модификации.\n3. Предотвращение конфликтов переменных:\nПоскольку IIFE создают собственную область видимости, переменные внутри них не конфликтуют с переменными в других частях программы.\n4. Инициализация кода:\nIIFE часто используются для выполнения однократной инициализации, которая должна произойти сразу после загрузки кода.\nСинтаксис IIFE\nМожет быть объявлена с помощью двух основных синтаксисов:\n1. Анонимная функция\n```javascript\n(function() {\n  console.log('This is an IIFE');\n})();\n```\n2. Функция с именем\n```javascript\n(function namedIIFE() {\n  console.log('This is a named IIFE');\n})();\n```\nПримеры\n1. Изоляция переменных\n```javascript\nvar i = 10;\n(function() {\n  var i = 20;\n  console.log(i); // 20\n})();\nconsole.log(i); // 10\n```\nВ этом примере переменная\n`i`\nвнутри IIFE не конфликтует с переменной\n`i`\nв глобальной области видимости.\n2. Создание приватных переменных\n```javascript\nvar counter = (function() {\n  var count = 0;\n  return {\n    increment: function() {\n      count++;\n      return count;\n    },\n    reset: function() {\n      count = 0;\n    }\n  };\n})();\nconsole.log(counter.increment()); // 1\nconsole.log(counter.increment()); // 2\ncounter.reset();\nconsole.log(counter.increment()); // 1\n```\nЗдесь переменная\n`count`\nявляется приватной и доступна только через методы\n`increment`\nи\n`reset`\n.\n3. Инициализация кода\n```javascript\n(function() {\n  console.log('IIFE for initialization');\n  // Initialization code here\n})();\n```\nIIFE нужны для создания новой области видимости, изоляции кода, создания приватных переменных и предотвращения конфликтов переменных. Они выполняются сразу после объявления и часто используются для инициализации кода.\nJune 1, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/VzorPrTjUII?t=577",
        title: "Middle за год? Собеседование #3 fron…",
        time: 577,
      },
      {
        url: "https://youtu.be/ZEKcJgVI-YM?t=398",
        title: "Талант в 18 лет? Собеседование #2 fr…",
        time: 398,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1842,
    question: "Для чего использовал map и set в работе",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/VzorPrTjUII?t=700",
        title: "Middle за год? Собеседование #3 fron…",
        time: 700,
      },
      {
        url: "https://youtu.be/B1IbTKdgCeE?t=935",
        title: "Крушитель алгоритмов? Собеседование …",
        time: 935,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1843,
    question: "Расскажи про утилити типы",
    explanation:
      "Утилити типы (utility types)\n— это встроенные типы, которые помогают манипулировать другими типами и упрощают работу с ними. Они позволяют изменять, расширять, ограничивать и комбинировать типы, что делает код более гибким и безопасным. Вот некоторые из наиболее часто используемых утилити и их примеры:\n1. Partial\nДелает все свойства типа\n`T`\nнеобязательными.\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\nconst updateUser = (id: number, userUpdates: Partial<User>) => {\n  // Обновление пользователя\n};\nupdateUser(1, { name: 'Alice' }); // Можно передать только часть свойств\n```\n2. Required\nДелает все свойства типа\n`T`\nобязательными.\n```typescript\ninterface User {\n  id?: number;\n  name?: string;\n  email?: string;\n}\nconst user: Required<User> = {\n  id: 1,\n  name: 'Alice',\n  email: 'alice@example.com'\n}; // Все свойства должны быть указаны\n```\n3. Readonly\nДелает все свойства типа\n`T`\nтолько для чтения.\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\nconst user: Readonly<User> = {\n  id: 1,\n  name: 'Alice',\n  email: 'alice@example.com'\n};\nuser.id = 2; // Ошибка: свойство id доступно только для чтения\n```\n4. Pick\nСоздает тип с набором свойств\n`K`\nиз типа\n`T`\n.\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\nconst user: Pick<User, 'id' | 'name'> = {\n  id: 1,\n  name: 'Alice'\n}; // Только свойства id и name\n```\n5. Omit\nСоздает тип, исключающий свойства\n`K`\nиз типа\n`T`\n.\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\nconst user: Omit<User, 'email'> = {\n  id: 1,\n  name: 'Alice'\n}; // Все свойства, кроме email\n```\n6. Record\nСоздает тип объекта, ключи которого из\n`K`\n, а значения типа\n`T`\n.\n```typescript\ntype Roles = 'admin' | 'user' | 'guest';\nconst roles: Record<Roles, string> = {\n  admin: 'Admin User',\n  user: 'Regular User',\n  guest: 'Guest User'\n};\n```\n7. Exclude\nСоздает тип, исключая из\n`T`\nте типы, которые находятся в\n`U`\n.\n```typescript\ntype T = 'a' | 'b' | 'c';\ntype U = 'a';\ntype Result = Exclude<T, U>; // 'b' | 'c'\n```\n8. Extract\nСоздает тип, включающий только те типы из\n`T`\n, которые также находятся в\n`U`\n.\n```typescript\ntype T = 'a' | 'b' | 'c';\ntype U = 'a' | 'c';\ntype Result = Extract<T, U>; // 'a' | 'c'\n```\n9. NonNullable\nИсключает\n`null`\nи\n`undefined`\nиз типа\n`T`\n.\n```typescript\ntype T = string | number | null | undefined;\ntype NonNullableT = NonNullable<T>; // string | number\n```\n10. ReturnType\nПолучает тип возвращаемого значения функции\n`T`\n.\n```typescript\nfunction getUser() {\n  return { id: 1, name: 'Alice' };\n}\ntype User = ReturnType<typeof getUser>; // { id: number, name: string }\n```\nУтилити типы помогают манипулировать типами, делая их более гибкими и безопасными. Они позволяют изменять, расширять, ограничивать и комбинировать типы. Вот основные утилити типы и их примеры:\nОсновные утилити\n1. Partial:\nДелает все свойства типа необязательными.\n```typescript\n   interface User {\n     id: number;\n     name: string;\n     email: string;\n   }\n   const updateUser = (id: number, userUpdates: Partial<User>) => {\n     // Обновление пользователя\n   };\n   updateUser(1, { name: 'Alice' }); // Можно передать только часть свойств\n   ```\n2. Required:\nДелает все свойства типа обязательными.\n```typescript\n   interface User {\n     id?: number;\n     name?: string;\n     email?: string;\n   }\n   const user: Required<User> = {\n     id: 1,\n     name: 'Alice',\n     email: 'alice@example.com'\n   }; // Все свойства должны быть указаны\n   ```\n3. Readonly:\nДелает все свойства типа только для чтения.\n```typescript\n   interface User {\n     id: number;\n     name: string;\n     email: string;\n   }\n   const user: Readonly<User> = {\n     id: 1,\n     name: 'Alice',\n     email: 'alice@example.com'\n   };\n   user.id = 2; // Ошибка: свойство id доступно только для чтения\n   ```\n4. Pick:\nСоздает тип с набором свойств из указанного типа.\n```typescript\n   interface User {\n     id: number;\n     name: string;\n     email: string;\n   }\n   const user: Pick<User, 'id' | 'name'> = {\n     id: 1,\n     name: 'Alice'\n   }; // Только свойства id и name\n   ```\n5. Omit:\nСоздает тип, исключающий указанные свойства из типа.\n```typescript\n   interface User {\n     id: number;\n     name: string;\n     email: string;\n   }\n   const user: Omit<User, 'email'> = {\n     id: 1,\n     name: 'Alice'\n   }; // Все свойства, кроме email\n   ```\n6. Record:\nСоздает тип объекта с ключами из одного типа и значениями другого типа.\n```typescript\n   type Roles = 'admin' | 'user' | 'guest';\n   const roles: Record<Roles, string> = {\n     admin: 'Admin User',\n     user: 'Regular User',\n     guest: 'Guest User'\n   };\n   ```\n7. Exclude:\nИсключает из типа те типы, которые находятся в другом типе.\n```typescript\n   type T = 'a' | 'b' | 'c';\n   type U = 'a';\n   type Result = Exclude<T, U>; // 'b' | 'c'\n   ```\n8. Extract:\nВключает только те типы, которые находятся в обоих типах.\n```typescript\n   type T = 'a' | 'b' | 'c';\n   type U = 'a' | 'c';\n   type Result = Extract<T, U>; // 'a' | 'c'\n   ```\n9. NonNullable:\nИсключает\n`null`\nи\n`undefined`\nиз типа.\n```typescript\n   type T = string | number | null | undefined;\n   type NonNullableT = NonNullable<T>; // string | number\n   ```\n10. ReturnType:\nПолучает тип возвращаемого значения функции.\n```typescript\n   function getUser() {\n     return { id: 1, name: 'Alice' };\n   }\n   type User = ReturnType<typeof getUser>; // { id: number, name: string }\n   ```\nУтилити типы\n— это встроенные типы, которые позволяют легко изменять, расширять и комбинировать другие типы. Они делают код более гибким, безопасным и удобным для поддержки.\nJune 1, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/VzorPrTjUII?t=2295",
        title: "Middle за год? Собеседование #3 fron…",
        time: 2295,
      },
      {
        url: "https://youtu.be/ZEKcJgVI-YM?t=2810",
        title: "Талант в 18 лет? Собеседование #2 fr…",
        time: 2810,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1844,
    question: "Кем работал",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/VzorPrTjUII?t=81",
        title: "Middle за год? Собеседование #3 fron…",
        time: 81,
      },
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=274",
        title: "Первое интервью фронтендера самоучки…",
        time: 274,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1845,
    question: "Что такое call, apply и bind",
    explanation:
      "`call`\n,\n`apply`\nи\n`bind`\n— это методы, которые позволяют управлять контекстом (\n`this`\n) функции. Они полезны для вызова функции с определённым значением\n`this`\nи передачи аргументов. Вот как они работают:\n1. `call`\nВызывает функцию с указанным значением `this` и аргументами, переданными по отдельности.\nСинтаксис:\n```javascript\nfunc.call(thisArg, arg1, arg2, ...);\n```\nПример:\n```javascript\nfunction greet(greeting, punctuation) {\n  console.log(greeting + ', ' + this.name + punctuation);\n}\nconst user = { name: 'Alice' };\ngreet.call(user, 'Hello', '!'); // Hello, Alice!\n```\n2. `apply`\nПохож на\n`call`\n, но аргументы передаются в виде массива.\nСинтаксис:\n```javascript\nfunc.apply(thisArg, [arg1, arg2, ...]);\n```\nПример:\n```javascript\nfunction greet(greeting, punctuation) {\n  console.log(greeting + ', ' + this.name + punctuation);\n}\nconst user = { name: 'Alice' };\ngreet.apply(user, ['Hello', '!']); // Hello, Alice!\n```\n3. `bind`\nСоздаёт новую функцию, которая при вызове будет иметь указанный контекст\n`this`\nи аргументы, переданные при создании. Он не вызывает функцию сразу, а возвращает новую функцию.\nСинтаксис:\n```javascript\nconst boundFunction = func.bind(thisArg, arg1, arg2, ...);\n``\nПример:\n```javascript\nfunction greet(greeting, punctuation) {\n  console.log(greeting + ', ' + this.name + punctuation);\n}\nconst user = { name: 'Alice' };\nconst boundGreet = greet.bind(user, 'Hello');\nboundGreet('!'); // Hello, Alice!\n```\nСравнение методов\n1. `call`\nи\n`apply`\n:\nИспользуются для немедленного вызова функции с заданным\n`this`\n.\n`call`\nпринимает аргументы по отдельности.\n`apply`\nпринимает аргументы в виде массива.\n2. `bind`:\nВозвращает новую функцию с заданным\n`this`\n, которую можно вызвать позже.\nПолезен для создания функции с постоянным контекстом.\nКраткий ответ:\n`call`\nвызывает функцию с указанным значением\n`this`\nи аргументами, переданными по отдельности.\n`apply`\nвызывает функцию с указанным значением\n`this`\nи аргументами, переданными в виде массива.\n`bind`\nсоздаёт новую функцию с указанным значением\n`this`\nи аргументами, которую можно вызвать позже.\nJune 1, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/VzorPrTjUII?t=884",
        title: "Middle за год? Собеседование #3 fron…",
        time: 884,
      },
      {
        url: "https://youtu.be/e2r3JAuMSSg?t=3479",
        title: "#1. Публичное собеседование JUNIOR F…",
        time: 3479,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1846,
    question: "Какие плюсы есть у ts",
    explanation:
      "TypeScript (TS)\n— это надстройка над JavaScript, добавляющая статическую типизацию и другие возможности. Он предоставляет множество преимуществ, которые делают его привлекательным для разработки крупных и сложных приложений. Вот основные плюсы TypeScript:\n1. Статическая типизация\nПозволяет явно указывать типы переменных, функций и объектов, что помогает выявлять ошибки на этапе компиляции, а не во время выполнения. Это делает код более надежным и уменьшает количество багов.\n```typescript\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n// Ошибка на этапе компиляции, если передать нечисловые значения\n// add('1', '2');\n```\n2. Улучшенная поддержка инструментов и автодополнение\nСтатическая типизация и декларации типов позволяют редакторам кода (например, Visual Studio Code) предоставлять улучшенное автодополнение, подсказки и рефакторинг.\n```typescript\ninterface User {\n  id: number;\n  name: string;\n}\nconst user: User = {\n  id: 1,\n  name: 'Alice'\n};\n// Автодополнение будет предлагать поля 'id' и 'name' для объекта 'user'\n```\n3. Рефакторинг и поддержка кода\nБлагодаря типизации и строгим правилам, TypeScript упрощает рефакторинг кода. Вы можете безопасно переименовывать переменные, функции и классы, уверенные в том, что все использования будут обновлены.\n4. Совместимость с JavaScript\nЯвляется надстройкой над JavaScript, поэтому любой корректный JavaScript-код также является корректным TypeScript-кодом. Это позволяет постепенно внедрять TypeScript в существующие проекты.\n```typescript\n// Это корректный TypeScript-код, так как он также является корректным JavaScript-кодом\nconst message = \"Hello, TypeScript!\";\nconsole.log(message);\n```\n5. Расширенные возможности OOP\nДобавляет возможности объектно-ориентированного программирования (ООП) к JavaScript, такие как классы, интерфейсы, абстрактные классы и модификаторы доступа (public, private, protected).\n```typescript\nclass Animal {\n  private name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n  public speak(): void {\n    console.log(`${this.name} makes a noise.`);\n  }\n}\nclass Dog extends Animal {\n  constructor(name: string) {\n    super(name);\n  }\n  public speak(): void {\n    console.log(`${this.name} barks.`);\n  }\n}\nconst dog = new Dog('Rex');\ndog.speak(); // Rex barks.\n```\n6. Система модулей\nПоддерживает современные стандарты модулей (ES6 и CommonJS), что упрощает организацию и управление зависимостями в проекте.\n```typescript\n// module.ts\nexport function greet(name: string): string {\n  return `Hello, ${name}`;\n}\n// main.ts\nimport { greet } from './module';\nconsole.log(greet('TypeScript'));\n```\n7. Поддержка современных возможностей JavaScript\nTypeScript поддерживает последние версии JavaScript и позволяет использовать новые возможности языка даже в старых браузерах благодаря транспиляции.\n8. Сообщество и экосистема\nИмеет большое и активное сообщество, множество библиотек и инструментов. Это делает его надежным выбором для долгосрочных проектов.\nTypeScript добавляет статическую типизацию, улучшает автодополнение и рефакторинг, предоставляет возможности ООП, поддерживает современные стандарты модулей и совместим с JavaScript. Это делает код более надежным, удобным в поддержке и разработке.\nJune 1, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/VzorPrTjUII?t=2056",
        title: "Middle за год? Собеседование #3 fron…",
        time: 2056,
      },
      {
        url: "https://youtu.be/NpQFVZoy4T8?t=1950",
        title: "FRONTEND СОБЕСЕДОВАНИЕ С БЫВШИМ РУКО…",
        time: 1950,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1847,
    question: "Где учился",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/YwRgLQ0SoKk?t=4",
        title: "Собеседование frontend разработчика",
        time: 4,
      },
      {
        url: "https://youtu.be/ZEKcJgVI-YM?t=6",
        title: "Талант в 18 лет? Собеседование #2 fr…",
        time: 6,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1848,
    question: "С помощью чего скопировал бы объект",
    explanation:
      "Есть несколько способов скопировать объект. Важно понимать разницу между поверхностным (shallow) и глубоким (deep) копированием. Поверхностная копия копирует только сам объект и его непосредственные свойства, в то время как глубокая копия копирует весь объект и все его вложенные объекты.\nПоверхностное копирование\n1. Object.assign\nМетод\n`Object.assign`\nкопирует все перечисляемые свойства из одного или более исходных объектов в целевой объект.\n```javascript\nconst original = { a: 1, b: 2 };\nconst copy = Object.assign({}, original);\nconsole.log(copy); // { a: 1, b: 2 }\n```\n2. Оператор расширения (spread operator)\nОператор расширения (\n`...`\n) также можно использовать для создания поверхностной копии объекта.\n```javascript\nconst original = { a: 1, b: 2 };\nconst copy = { ...original };\nconsole.log(copy); // { a: 1, b: 2 }\n```\nГлубокое копирование\n1. JSON.parse и JSON.stringify\nЭтот метод преобразует объект в строку JSON, а затем обратно в объект, создавая тем самым глубокую копию. Однако он имеет ограничения, такие как невозможность копирования функций и потеря `undefined` значений.\n```javascript\nconst original = { a: 1, b: { c: 2 } };\nconst copy = JSON.parse(JSON.stringify(original));\nconsole.log(copy); // { a: 1, b: { c: 2 } }\n```\n2. Рекурсивная функция\nМожно написать свою рекурсивную функцию для глубокого копирования объекта.\n```javascript\nfunction deepCopy(obj) {\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n  if (Array.isArray(obj)) {\n    const arrCopy = [];\n    for (let i = 0; i < obj.length; i++) {\n      arrCopy[i] = deepCopy(obj[i]);\n    }\n    return arrCopy;\n  }\n  const copy = {};\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      copy[key] = deepCopy(obj[key]);\n    }\n  }\n  return copy;\n}\nconst original = { a: 1, b: { c: 2 } };\nconst copy = deepCopy(original);\nconsole.log(copy); // { a: 1, b: { c: 2 } }\n```\n3. Библиотеки для глубокого копирования\nСуществуют библиотеки, такие как\n`lodash`\n, которые предоставляют готовые функции для глубокого копирования объектов.\n```javascript\nconst _ = require('lodash');\nconst original = { a: 1, b: { c: 2 } };\nconst copy = _.cloneDeep(original);\nconsole.log(copy); // { a: 1, b: { c: 2 } }\n```\nДля поверхностного копирования объектов можно использовать\n`Object.assign`\nили оператор расширения (\n`...`\n). Для глубокого копирования можно использовать\n`JSON.parse`\nи\n`JSON.stringify`\n, написать рекурсивную функцию или воспользоваться библиотекой, такой как\n`lodash`\n.\nJune 1, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/YwRgLQ0SoKk?t=537",
        title: "Собеседование frontend разработчика",
        time: 537,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=777",
        title: "Собеседование cтажера Frontend разра…",
        time: 777,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1849,
    question: "В чём разница между сессией и куком",
    explanation:
      "Сессии и куки\n— это два различных способа хранения данных в веб-приложениях, и у них есть свои особенности и случаи применения. Вот основные различия между ними:\nКуки (Cookies)\n1. Хранение данных на клиенте:\nКуки хранятся в браузере пользователя. Это небольшие кусочки данных, которые веб-сервер отправляет браузеру, и браузер сохраняет их и отправляет обратно на сервер с каждым запросом.\n2. Долговременное хранение:\nКуки могут иметь установленный срок действия и могут сохраняться на длительное время (например, несколько дней, недель или даже лет), если это явно указано при их создании.\n3. Использование для идентификации:\nКуки часто используются для сохранения информации о пользователе, такой как предпочтения, идентификаторы сессий или данные для авторизации.\n4. Размер и количество ограничены:\nОбычно размер одной куки ограничен 4KB, и браузеры могут ограничивать количество куки (например, до 20-30 на один домен).\n5. Безопасность:\nКуки могут быть подвержены угрозам безопасности, таким как кража куки (cookie theft) или атаки с подделкой межсайтовых запросов (CSRF). Использование флага\n`HttpOnly`\nпомогает защитить куки от доступа через JavaScript, а флаг\n`Secure`\nгарантирует их передачу только по HTTPS.\nПример создания куки:\n```javascript\ndocument.cookie = \"username=JohnDoe; expires=Fri, 31 Dec 2024 23:59:59 GMT; path=/\";\n```\nСессии (Sessions)\n1. Хранение данных на сервере:\nДанные сессии хранятся на сервере, а не в браузере пользователя. Браузер хранит только идентификатор сессии (обычно в куке), который используется для связи данных сессии с конкретным пользователем.\n2. Кратковременное хранение:\nСессии, как правило, предназначены для хранения данных в течение одного сеанса работы пользователя (например, до закрытия браузера или истечения времени бездействия). Данные сессии удаляются, когда сессия заканчивается.\n3. Использование для хранения состояния:\nСессии используются для хранения состояния пользователя между запросами, таких как состояние авторизации, содержимое корзины покупок и другие временные данные.\n4. Размер и масштабируемость:\nПоскольку данные сессии хранятся на сервере, размер их ограничен только серверными ресурсами. Это позволяет хранить больше данных по сравнению с куки.\n5. Безопасность:\nСессии обычно считаются более безопасными, так как данные не передаются с каждым запросом и хранятся на сервере. Однако нужно заботиться о безопасности идентификаторов сессий, чтобы предотвратить атаки, такие как угон сессий (session hijacking).\nПример создания сессии на сервере (с использованием Express.js):\n```javascript\nconst express = require('express');\nconst session = require('express-session');\nconst app = express();\napp.use(session({\n  secret: 'mySecret',\n  resave: false,\n  saveUninitialized: true,\n  cookie: { secure: true }\n}));\napp.get('/', (req, res) => {\n  if (req.session.views) {\n    req.session.views++;\n    res.send(`Number of views: ${req.session.views}`);\n  } else {\n    req.session.views = 1;\n    res.send('Welcome to the session demo. Refresh!');\n  }\n});\napp.listen(3000);\n```\nКуки\nхранятся в браузере пользователя, могут быть долговременными и используются для хранения небольших данных, таких как идентификаторы и предпочтения.\nСессии\nхранятся на сервере, обычно кратковременные и используются для хранения состояния пользователя между запросами.\nJune 1, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/YwRgLQ0SoKk?t=1190",
        title: "Собеседование frontend разработчика",
        time: 1190,
      },
      {
        url: "https://youtu.be/BOCkaqdbdCg?t=3544",
        title: "Собеседование на Junior Frontend раз…",
        time: 3544,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1850,
    question: "Как сравнить объекты в js",
    explanation:
      "Сравнение объектов требует особого внимания, поскольку объекты являются ссылочными типами данных. Это значит, что при сравнении объектов вы фактически сравниваете их ссылки в памяти, а не их содержимое. Вот несколько способов сравнения объектов:\n1. Сравнение ссылок на объекты\nПри сравнении объектов с использованием оператора равенства (\n`==`\nили\n`===`\n), сравниваются их ссылки, а не содержимое.\n```javascript\nconst obj1 = { a: 1 };\nconst obj2 = { a: 1 };\nconst obj3 = obj1;\nconsole.log(obj1 === obj2); // false\nconsole.log(obj1 === obj3); // true\n```\n2. Глубокое сравнение объектов\nДля сравнения содержимого объектов необходимо проверять каждое свойство. Один из способов — написать рекурсивную функцию для глубокого сравнения.\n```javascript\nfunction deepEqual(obj1, obj2) {\n  if (obj1 === obj2) {\n    return true;\n  }\n  if (obj1 == null || typeof obj1 !== 'object' ||\n      obj2 == null || typeof obj2 !== 'object') {\n    return false;\n  }\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n  if (keys1.length !== keys2.length) {\n    return false;\n  }\n  for (let key of keys1) {\n    if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {\n      return false;\n    }\n  }\n  return true;\n}\nconst obj1 = { a: 1, b: { c: 2 } };\nconst obj2 = { a: 1, b: { c: 2 } };\nconst obj3 = { a: 1, b: { c: 3 } };\nconsole.log(deepEqual(obj1, obj2)); // true\nconsole.log(deepEqual(obj1, obj3)); // false\n```\n3. Использование библиотек\nСуществуют библиотеки, которые предоставляют функции для глубокого сравнения объектов, например,\n`lodash`\nили\n`deep-equal`\n.\n```javascript\nconst _ = require('lodash');\nconst obj1 = { a: 1, b: { c: 2 } };\nconst obj2 = { a: 1, b: { c: 2 } };\nconst obj3 = { a: 1, b: { c: 3 } };\nconsole.log(_.isEqual(obj1, obj2)); // true\nconsole.log(_.isEqual(obj1, obj3)); // false\n```\n4. Проверка свойств с учетом порядка и типов\nДля простых случаев можно использовать сериализацию объектов с помощью\n`JSON.stringify`\n, однако этот метод имеет ограничения и может не работать с более сложными структурами (например, с функциями,\n`undefined`\n, или символами).\n```javascript\nconst obj1 = { a: 1, b: { c: 2 } };\nconst obj2 = { a: 1, b: { c: 2 } };\nconst obj3 = { a: 1, b: { c: 3 } };\nconsole.log(JSON.stringify(obj1) === JSON.stringify(obj2)); // true\nconsole.log(JSON.stringify(obj1) === JSON.stringify(obj3)); // false\n```\nДля сравнения объектов можно использовать:\nСравнение ссылок\nс\n`===`\n, если нужно проверить, указывают ли переменные на один и тот же объект.\nГлубокое сравнение\nс помощью рекурсивной функции или библиотек (например,\n`lodash`\n), чтобы проверить равенство содержимого объектов.\nСериализация с JSON.stringify\nдля простых случаев, хотя этот метод имеет ограничения и может не работать с более сложными структурами.\nJune 5, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/YwRgLQ0SoKk?t=371",
        title: "Собеседование frontend разработчика",
        time: 371,
      },
      {
        url: "https://youtu.be/ZEKcJgVI-YM?t=438",
        title: "Талант в 18 лет? Собеседование #2 fr…",
        time: 438,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1851,
    question:
      "В чём разница между event.Preventdefault и event.Stoppropagation",
    explanation:
      "`event.preventDefault()`\nи\n`event.stopPropagation()`\n— это два метода, которые используются для управления поведением событий в JavaScript. Они выполняют разные задачи и полезны в различных сценариях.\n`event.preventDefault()`\nПредотвращает поведение браузера по умолчанию для события. Это может быть полезно, когда вы хотите отменить действие, которое обычно происходит при определенном событии.\nПримеры:\n1. Отмена отправки формы:\n```javascript\ndocument.querySelector('form').addEventListener('submit', function(event) {\n  event.preventDefault();\n  console.log('Форма не отправлена!');\n});\n```\n2. Отмена перехода по ссылке:\n```javascript\ndocument.querySelector('a').addEventListener('click', function(event) {\n  event.preventDefault();\n  console.log('Переход по ссылке отменен!');\n});\n```\n`event.stopPropagation()`\nПредотвращает дальнейшее распространение события по дереву DOM. Это полезно, когда вы хотите остановить событие от всплытия (bubbling) или захвата (capturing) к родительским элементам.\nПримеры:\n1. Остановка всплытия события:\n```javascript\ndocument.querySelector('.child').addEventListener('click', function(event) {\n  event.stopPropagation();\n  console.log('Клик на child');\n});\ndocument.querySelector('.parent').addEventListener('click', function() {\n  console.log('Клик на parent');\n});\n```\nВ этом примере клик на\n`.child`\nэлемент не вызовет обработчик клика на\n`.parent`\nэлементе.\nСравнение\n`event.preventDefault()`:\nПредотвращает действие браузера по умолчанию.\nПримеры: отмена отправки формы, отмена перехода по ссылке.\n`event.stopPropagation()`:\nОстанавливает дальнейшее распространение события по дереву DOM.\nПримеры: остановка всплытия события от дочернего элемента к родительскому.\nJune 5, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/YwRgLQ0SoKk?t=912",
        title: "Собеседование frontend разработчика",
        time: 912,
      },
      {
        url: "https://youtu.be/wP7XVriACtA?t=1364",
        title: "Frontend Собеседование на Junior раз…",
        time: 1364,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1852,
    question: "Как можно оптимизировать перерисовки",
    explanation:
      "Оптимизация перерисовок (или \"repaints\" и \"reflows\") в веб-приложениях является важной задачей для обеспечения высокой производительности и плавности интерфейса. Вот несколько методов и стратегий, которые можно использовать для оптимизации перерисовок:\n1. Минимизация количества изменений в DOM\nИспользуйте Document Fragments:\nВместо многократного добавления элементов в DOM, добавляйте их в\n`DocumentFragment`\n, а затем добавьте фрагмент в DOM одним действием.\n```javascript\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < 100; i++) {\n    const div = document.createElement('div');\n    div.textContent = `Item ${i}`;\n    fragment.appendChild(div);\n  }\n  document.body.appendChild(fragment);\n  ```\nBatch DOM updates:\nГруппируйте несколько изменений DOM в одно действие. Это уменьшает количество вызовов для перерисовки.\n2. Избегайте синхронных изменений стилей и компоновки\nCSS класс:\nВместо изменения нескольких отдельных стилей, измените один класс.\n```javascript\n  element.style.width = '100px';\n  element.style.height = '100px';\n  element.style.backgroundColor = 'red';\n  ```\nВместо этого используйте класс:\n```css\n  .new-style {\n    width: 100px;\n    height: 100px;\n    background-color: red;\n  }\n  ```\n```javascript\n  element.classList.add('new-style');\n  ```\nИзбегайте чтения свойств, вызывающих перерисовку:\nЧтение некоторых свойств, таких как\n`offsetHeight`\nили\n`offsetWidth`\n, после изменения стилей, заставляет браузер выполнять немедленную перерисовку. Избегайте таких действий.\n3. Используйте CSS для анимаций\nCSS анимации и трансформации:\nИспользуйте CSS для анимаций и трансформаций, так как они могут выполняться на уровне GPU, что снижает нагрузку на основной поток.\n```css\n  .animated {\n    transition: transform 0.3s;\n    transform: translateX(100px);\n  }\n  ```\n```javascript\n  element.classList.add('animated');\n  ```\n4. Дебаунс и троттлинг\nDebouncing и Throttling:\nИспользуйте дебаунс и троттлинг для событий, которые происходят часто (например,\n`resize`\nили\n`scroll`\n), чтобы уменьшить количество вызовов обработчиков событий.\n```javascript\n  function debounce(func, wait) {\n    let timeout;\n    return function(...args) {\n      clearTimeout(timeout);\n      timeout = setTimeout(() => func.apply(this, args), wait);\n    };\n  }\n  window.addEventListener('resize', debounce(() => {\n    console.log('Resized!');\n  }, 200));\n  ```\n5. Виртуальный DOM\nИспользование библиотек с виртуальным DOM:\nБиблиотеки, такие как React, используют виртуальный DOM, чтобы минимизировать количество изменений в реальном DOM, что значительно улучшает производительность.\n6. Избегайте использования layout thrashing\nLayout Thrashing:\nЭто происходит, когда чередуются операции записи и чтения из DOM, что вызывает множественные перерисовки.\n```javascript\n  const height = element.offsetHeight;\n  element.style.height = `${height + 10}px`;\n  ```\nСгруппируйте чтения и записи отдельно:\n```javascript\n  const height = element.offsetHeight;\n  element.style.height = `${height + 10}px`;\n  ```\n7. Избегайте глубоких вложенностей в DOM\nМеньше вложенностей:\nСтарайтесь минимизировать глубину вложенности элементов, так как это может усложнить перерисовку и компоновку.\n8. Оптимизация стилей\nУменьшите количество правил и селекторов:\nСложные CSS-селекторы могут замедлить работу браузера. Используйте более простые селекторы и старайтесь избегать вложенных правил.\n9. Использование will-change\nwill-change:\nИспользуйте свойство\n`will-change`\n, чтобы заранее сообщить браузеру о планируемых изменениях, что позволяет оптимизировать рендеринг.\n```css\n  .will-change-transform {\n    will-change: transform;\n  }\n  ```\n```javascript\n  element.classList.add('will-change-transform');\n  ```\nДля оптимизации перерисовок в веб-приложениях, минимизируйте изменения в DOM, используйте CSS для анимаций, применяйте дебаунс и троттлинг для событий, избегайте layout thrashing, уменьшайте глубину вложенностей в DOM и используйте библиотеки с виртуальным DOM. Эти методы помогают улучшить производительность и плавность интерфейса.\nJune 5, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/YwRgLQ0SoKk?t=3654",
        title: "Собеседование frontend разработчика",
        time: 3654,
      },
      {
        url: "https://youtu.be/qGdV5YOmtrs?t=3680",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 3680,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1853,
    question: "Что такое falsy значения",
    explanation:
      "\"falsy\" (ложные) значения\n— это значения, которые при приведении к логическому типу (Boolean) дают\n`false`\n. Эти значения часто используются в условиях (например, в\n`if`\nвыражениях) для проверки истинности или ложности.\nОсновные значения:\n1. `false`:\nСамо значение\n`false`\nявляется ложным.\n```javascript\n   if (false) {\n     console.log('Это не выполнится');\n   }\n   ```\n2. `0` и `-0`:\nНулевые значения считаются ложными.\n```javascript\n   if (0) {\n     console.log('Это не выполнится');\n   }\n   if (-0) {\n     console.log('Это тоже не выполнится');\n   }\n   ```\n3. `\"\"` (пустая строка):\nПустая строка считается ложной.\n```javascript\n   if (\"\") {\n     console.log('Это не выполнится');\n   }\n   ```\n4. `null`:\nЗначение\n`null`\nтакже является ложным.\n```javascript\n   if (null) {\n     console.log('Это не выполнится');\n   }\n   ```\n5. `undefined`:\nЗначение\n`undefined`\nявляется ложным.\n```javascript\n   if (undefined) {\n     console.log('Это не выполнится');\n   }\n   ```\n6. `NaN` (Not-a-Number):\nСпециальное значение\n`NaN`\n, которое обозначает нечисловое значение, считается ложным.\n```javascript\n   if (NaN) {\n     console.log('Это не выполнится');\n   }\n   ```\nПримеры\n1. Условные операторы:\n```javascript\n   const value = 0;\n   if (!value) {\n     console.log('value является falsy'); // Это выполнится\n   }\n   ```\n2. Логические операторы:\nЛогические операторы могут быть использованы для проверки на \"falsy\" значения.\n```javascript\n   const value = null;\n   const result = value || 'Значение по умолчанию';\n   console.log(result); // 'Значение по умолчанию'\n   ```\n3. Функции с параметрами по умолчанию:\nФункции могут использовать \"falsy\" значения для предоставления параметров по умолчанию.\n```javascript\n   function greet(name) {\n     name = name || 'гость';\n     console.log('Привет, ' + name);\n   }\n   greet(); // Привет, гость\n   greet('Алиса'); // Привет, Алиса\n   ```\n\"Falsy\" значения — это значения, которые приводятся к `false` в логическом контексте. Основные \"falsy\" значения:\n`false`\n,\n`0`\n,\n`-0`\n,\n`\"\"`\n,\n`null`\n,\n`undefined`\n,\n`NaN`\n. Эти значения часто используются в условиях для проверки их истинности или ложности.\nJune 5, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/ZEKcJgVI-YM?t=183",
        title: "Талант в 18 лет? Собеседование #2 fr…",
        time: 183,
      },
      {
        url: "https://www.youtube.com/watch?v=EaTZXKlpsj0&t=5570s",
        title: "#11 Фронтендер в 17 лет? Собеседован…",
        time: 5570,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1854,
    question: "Как работает promiseall",
    explanation:
      "`Promise.all`\n— это метод, который позволяет обрабатывать несколько промисов одновременно и возвращает один промис, который завершится, когда все переданные промисы будут выполнены (или когда один из них будет отклонен).\nОсновные особенности:\n1. Параллельное выполнение промисов:\n`Promise.all`\nпринимает массив промисов и выполняет их параллельно. Он завершится успешно, когда все промисы в массиве будут выполнены.\n2. Возвращает один промис:\nМетод возвращает один промис, который:\nВыполняется с массивом результатов, если все промисы в массиве были успешно выполнены.\nОтклоняется с причиной отклонения первого промиса, который был отклонен.\n3. Отклонение при первой ошибке:\nЕсли один из промисов в массиве отклоняется,\n`Promise.all`\nсразу отклоняет весь промис, не дожидаясь выполнения остальных.\nСинтаксис\n```javascript\nPromise.all(iterable);\n```\niterable:\nМассив или другой итерируемый объект, элементы которого являются промисами или значениями.\nРассмотрим пример, где мы запускаем несколько асинхронных операций одновременно и ждем их завершения.\n```javascript\nconst promise1 = new Promise((resolve) => setTimeout(resolve, 100, 'First'));\nconst promise2 = new Promise((resolve) => setTimeout(resolve, 200, 'Second'));\nconst promise3 = new Promise((resolve) => setTimeout(resolve, 300, 'Third'));\nPromise.all([promise1, promise2, promise3])\n  .then((results) => {\n    console.log(results); // ['First', 'Second', 'Third']\n  })\n  .catch((error) => {\n    console.error('One of the promises failed:', error);\n  });\n```\nЕсли один из промисов отклоняется,\n`Promise.all`\nотклоняет весь результат.\n```javascript\nconst promise1 = new Promise((resolve) => setTimeout(resolve, 100, 'First'));\nconst promise2 = new Promise((resolve, reject) => setTimeout(reject, 200, 'Error in Second'));\nconst promise3 = new Promise((resolve) => setTimeout(resolve, 300, 'Third'));\nPromise.all([promise1, promise2, promise3])\n  .then((results) => {\n    console.log(results); // This line will not be executed\n  })\n  .catch((error) => {\n    console.error('One of the promises failed:', error); // 'Error in Second'\n  });\n```\n`Promise.all`\nтакже можно использовать с\n`async/await`\nдля более удобной работы с асинхронным кодом.\n```javascript\nconst promise1 = new Promise((resolve) => setTimeout(resolve, 100, 'First'));\nconst promise2 = new Promise((resolve) => setTimeout(resolve, 200, 'Second'));\nconst promise3 = new Promise((resolve) => setTimeout(resolve, 300, 'Third'));\nasync function runPromises() {\n  try {\n    const results = await Promise.all([promise1, promise2, promise3]);\n    console.log(results); // ['First', 'Second', 'Third']\n  } catch (error) {\n    console.error('One of the promises failed:', error);\n  }\n}\nrunPromises();\n```\n`Promise.all`\nпринимает массив промисов и возвращает один промис, который выполняется, когда все промисы в массиве выполнены успешно, или отклоняется, если любой из промисов отклонен. Он позволяет обрабатывать несколько асинхронных операций параллельно и возвращает массив результатов всех промисов.\nJune 5, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/ZEKcJgVI-YM?t=868",
        title: "Талант в 18 лет? Собеседование #2 fr…",
        time: 868,
      },
      {
        url: "https://youtu.be/MHrKcnyN46M?t=1435",
        title: "СОБЕСЕДОВАНИЕ НА FRONTEND РАЗРАБОТЧИ…",
        time: 1435,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1855,
    question: "В чем отличие map от обычного объекта",
    explanation:
      "Объекты, и\n`Map`\nиспользуются для хранения пар ключ-значение. Однако, у них есть различия, которые могут сделать\n`Map`\nболее подходящим для определенных задач по сравнению с обычными объектами. Вот основные отличия:\n1. Типы ключей\nОбъекты:\nКлючами могут быть только строки или символы. Другие типы, такие как числа или объекты, автоматически преобразуются в строки.\n```javascript\n  const obj = {};\n  obj[1] = 'one'; // Ключ преобразуется в строку '1'\n  console.log(obj['1']); // 'one'\n  const a = { key: 'a' };\n  const b = { key: 'b' };\n  obj[a] = 'value'; // Ключ преобразуется в '[object Object]'\n  console.log(obj['[object Object]']); // 'value'\n  ```\nMap:\nКлючами могут быть любые значения, включая объекты, функции и примитивы.\n```javascript\n  const map = new Map();\n  map.set(1, 'one');\n  console.log(map.get(1)); // 'one'\n  const a = { key: 'a' };\n  const b = { key: 'b' };\n  map.set(a, 'valueA');\n  map.set(b, 'valueB');\n  console.log(map.get(a)); // 'valueA'\n  console.log(map.get(b)); // 'valueB'\n  ```\n2. Итерация\nОбъекты:\nОсуществляется с помощью циклов\n`for...in`\nили методов\n`Object.keys()`\n,\n`Object.values()`\nи\n`Object.entries()`\n.\n```javascript\n  const obj = { a: 1, b: 2 };\n  for (const key in obj) {\n    console.log(key, obj[key]);\n  }\n  Object.keys(obj).forEach(key => console.log(key, obj[key]));\n  ```\nMap:\nИмеет встроенные методы для итерации, такие как\n`map.keys()`\n,\n`map.values()`\nи\n`map.entries()`\n. Эти методы возвращают итерируемые объекты.\n```javascript\n  const map = new Map([['a', 1], ['b', 2]]);\n  for (const [key, value] of map) {\n    console.log(key, value);\n  }\n  map.forEach((value, key) => console.log(key, value));\n  ```\n3. Сохранение порядка\nОбъекты:\nПорядок свойств в объектах не гарантирован, хотя современные реализации JavaScript сохраняют порядок добавления свойств.\nMap:\nПорядок добавления пар ключ-значение всегда сохраняется.\n4. Производительность\nОбъекты:\nИспользование объектов может быть быстрее для создания и доступа к свойствам, но это зависит от реализации в конкретной среде выполнения.\nMap: `Map`\nоптимизирован для частого добавления и удаления ключей и значений.\n5. Методы и свойства\nОбъекты:\nНе имеют встроенных методов для работы с коллекцией ключей и значений.\nMap:\nПредоставляет множество встроенных методов, таких как\n`set`\n,\n`get`\n,\n`has`\n,\n`delete`\n, и свойства, такие как\n`size`\n.\n```javascript\n  const map = new Map();\n  map.set('key', 'value');\n  console.log(map.has('key')); // true\n  console.log(map.get('key')); // 'value'\n  map.delete('key');\n  console.log(map.size); // 0\n  ```\n6. Прототипное наследование\nОбъекты:\nИмеют цепочку прототипов, которая может приводить к коллизиям имен свойств с прототипами.\n```javascript\n  const obj = { a: 1 };\n  console.log(obj.toString); // [Function: toString] - свойство унаследовано от Object.prototype\n  ```\nMap:\nВ\n`Map`\nнет такой проблемы, так как он не использует цепочку прототипов для хранения данных.\n```javascript\n  const map = new Map();\n  map.set('a', 1);\n  console.log(map.toString); // [Function: toString] - метод самого Map, а не его данных\n  ```\nОбъекты\nиспользуют строки и символы как ключи, их итерация может быть менее удобной, и они могут сталкиваться с проблемами прототипного наследования.\nMap\nподдерживает любые типы ключей, сохраняет порядок вставки, предоставляет удобные методы для работы с коллекцией и оптимизирован для частых операций добавления и удаления.\nJune 6, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/ZEKcJgVI-YM?t=1132",
        title: "Талант в 18 лет? Собеседование #2 fr…",
        time: 1132,
      },
      {
        url: "https://youtu.be/LcAQMKXpcqg?t=1495",
        title: "СОБЕСЕДОВАНИЕ JUNIOR FRONTEND РАЗРАБ…",
        time: 1495,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1856,
    question: "Что такое ts",
    explanation:
      'TypeScript (TS)\n— это язык с открытым исходным кодом, разработанный и поддерживаемый Microsoft. Является строгой надстройкой над JavaScript, которая добавляет статическую типизацию и другие возможности, упрощая разработку больших и сложных приложений.\nОсновные особенности\n1. Статическая типизация:\nПозволяет указывать типы переменных, параметров функций и возвращаемых значений. Это помогает выявлять ошибки на этапе компиляции, а не во время выполнения, что делает код более надежным и упрощает отладку.\n```typescript\n   let age: number = 25;\n   let name: string = "Alice";\n   function greet(name: string): string {\n     return `Hello, ${name}`;\n   }\n   ```\n2. Совместимость:\nTypeScript полностью совместим. Любой корректный JavaScript-код также является корректным TypeScript-кодом. Это позволяет постепенно внедрять TypeScript в существующие проекты.\n3. Поддержка современных возможностей:\nПоддерживает все современные стандарты JavaScript (ES6 и выше), а также предоставляет дополнительные возможности, такие как декораторы и асинхронные функции.\n4. Расширенные возможности ООП (объектно-ориентированного программирования):\nДобавляет возможности, такие как классы, интерфейсы, абстрактные классы и модификаторы доступа (public, private, protected).\n```typescript\n   class Person {\n     private name: string;\n     \n     constructor(name: string) {\n       this.name = name;\n     }\n     public greet(): void {\n       console.log(`Hello, my name is ${this.name}`);\n     }\n   }\n   const alice = new Person("Alice");\n   alice.greet(); // Hello, my name is Alice\n   ```\n5. Типы данных и интерфейсы:\nTypeScript позволяет определять собственные типы и интерфейсы, что делает код более выразительным и понятным.\n```typescript\n   interface User {\n     id: number;\n     name: string;\n     email: string;\n   }\n   const user: User = {\n     id: 1,\n     name: "Alice",\n     email: "alice@example.com"\n   };\n   ```\n6. Инструменты разработки:\nБлагодаря статической типизации и метаданным, TypeScript обеспечивает улучшенное автодополнение, рефакторинг и навигацию по коду в популярных редакторах кода, таких как Visual Studio Code.\n7. Компиляция:\nКомпилируется (или транслируется) в JavaScript. Это означает, что код TypeScript преобразуется в JavaScript, который затем может выполняться в любом браузере или среде выполнения JavaScript.\n```typescript\n   // TypeScript\n   let message: string = "Hello, TypeScript";\n   // Компилированный JavaScript\n   var message = "Hello, TypeScript";\n   ```\nСоздание простого проекта может включать следующие шаги:\n1. Установка TypeScript:\n```bash\n   npm install -g typescript\n   ```\n2. Инициализация проекта TypeScript:\n```bash\n   tsc --init\n   ```\nЭто создаст файл\n`tsconfig.json`\n, в котором можно настроить параметры компиляции TypeScript.\n3. Создание TypeScript-файла:\n```typescript\n   // src/index.ts\n   const greet = (name: string): string => {\n     return `Hello, ${name}`;\n   };\n   console.log(greet("TypeScript"));\n   ```\n4. Компиляция TypeScript в JavaScript:\n```bash\n   tsc\n   ```\nЭто создаст файл\n`index.js`\nв папке\n`dist`\nили другой указанной папке.\n5. Запуск скомпилированного JavaScript-кода:\n```bash\n   node dist/index.js\n   ```\nTypeScript\n— он является строгой надстройкой над JavaScript. Он добавляет статическую типизацию, улучшенные возможности ООП, поддержку современных стандартов JavaScript и улучшенные инструменты разработки. TypeScript компилируется в JavaScript, что позволяет использовать его в любых средах выполнения JavaScript.\nJune 6, 2024, easyoffer',
    videos: [
      {
        url: "https://youtu.be/ZEKcJgVI-YM?t=2607",
        title: "Талант в 18 лет? Собеседование #2 fr…",
        time: 2607,
      },
      {
        url: "https://youtu.be/2zVAkqcUI4o?t=1153",
        title: "СОБЕСЕДОВАНИЕ Middle FRONTEND разраб…",
        time: 1153,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1857,
    question: "В каком самом сложном проекте ты участвовал",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/B1IbTKdgCeE?t=81",
        title: "Крушитель алгоритмов? Собеседование …",
        time: 81,
      },
      {
        url: "https://youtu.be/wP7XVriACtA?t=767",
        title: "Frontend Собеседование на Junior раз…",
        time: 767,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1858,
    question: "Для чего нужны map, set",
    explanation:
      "`Map`\nи\n`Set`\n— это структуры данных, введенные в ECMAScript 6 (ES6), которые предоставляют дополнительные возможности и более гибкую работу с коллекциями данных по сравнению с традиционными объектами и массивами. Вот основные особенности и случаи их использования:\n`Map`\nЭто структура данных, которая позволяет хранить пары ключ-значение и поддерживает любые типы данных в качестве ключей.\nОсновные особенности:\n1. Любые типы ключей:\nВ ней ключами могут быть любые значения, включая объекты, функции и примитивы. Это отличает\n`Map`\nот объектов, где ключи могут быть только строками или символами.\n```javascript\n   const map = new Map();\n   map.set('a', 1);\n   map.set(1, 'one');\n   map.set({}, 'object');\n   map.set(function() {}, 'function');\n   console.log(map);\n   ```\n2. Сохранение порядка:\nСохраняет порядок вставки элементов, что позволяет итерировать по элементам в порядке их добавления.\n3. Итерируемость:\nИмеет встроенные методы для итерации, такие как\n`map.keys()`\n,\n`map.values()`\n, и\n`map.entries()`\n, что упрощает работу с коллекцией данных.\n4. Методы и свойства:\n`set(key, value)`:\nДобавляет новую пару ключ-значение в\n`Map`\n.\n`get(key)`:\nВозвращает значение, соответствующее ключу.\n`has(key)`:\nВозвращает\n`true`\n, если ключ присутствует в\n`Map`\n.\n`delete(key)`:\nУдаляет пару ключ-значение по ключу.\n`clear()`:\nОчищает\n`Map`\n.\n`size`:\nВозвращает количество элементов в\n`Map`\n.\nПример:\n```javascript\nconst map = new Map();\nmap.set('name', 'Alice');\nmap.set('age', 25);\nconsole.log(map.get('name')); // Alice\nconsole.log(map.has('age')); // true\nconsole.log(map.size); // 2\nfor (const [key, value] of map) {\n  console.log(key, value);\n}\n// name Alice\n// age 25\n```\n`Set`\nЭто структура данных, которая хранит уникальные значения. В\n`Set`\nкаждое значение может присутствовать только один раз.\nОсновные особенности:\n1. Только уникальные значения:\n`Set`\nавтоматически удаляет дубликаты значений, что позволяет легко создавать коллекции уникальных элементов.\n2. Итерируемость:\n`Set`\nподдерживает итерацию и имеет встроенные методы для работы с коллекцией данных.\n3. Методы и свойства:\n`add(value)`:\nДобавляет новое значение в\n`Set`\n.\n`has(value)`:\nВозвращает\n`true`\n, если значение присутствует в\n`Set`\n.\n`delete(value)`:\nУдаляет значение из\n`Set`\n.\n`clear()`:\nОчищает\n`Set`\n.\n`size`:\nВозвращает количество элементов в\n`Set`\n.\nПример:\n```javascript\nconst set = new Set();\nset.add(1);\nset.add(2);\nset.add(2); // Дубликат не добавится\nset.add(3);\nconsole.log(set.has(2)); // true\nconsole.log(set.size); // 3\nfor (const value of set) {\n  console.log(value);\n}\n// 1\n// 2\n// 3\n```\nСравнение с традиционными структурами данных\nОбъекты и массивы:\nОбъекты используются для хранения пар ключ-значение, но ключи могут быть только строками или символами.\nМассивы используются для хранения упорядоченных коллекций элементов, но они не гарантируют уникальность значений.\nMap и Set:\n`Map`\nпредоставляет более гибкую работу с парами ключ-значение, поддерживая любые типы данных в качестве ключей и сохраняя порядок вставки.\n`Set`\nпредоставляет коллекцию уникальных значений и автоматически удаляет дубликаты.\nJune 6, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/B1IbTKdgCeE?t=935",
        title: "Крушитель алгоритмов? Собеседование …",
        time: 935,
      },
      {
        url: "https://youtu.be/LcAQMKXpcqg?t=1495",
        title: "СОБЕСЕДОВАНИЕ JUNIOR FRONTEND РАЗРАБ…",
        time: 1495,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1859,
    question: "В чем разница uselayuouteffect и useeffect",
    explanation:
      "`useEffect`\nи\n`useLayoutEffect`\n— это хуки, которые позволяют выполнять побочные эффекты в функциональных компонентах. Оба они предназначены для выполнения кода после рендеринга компонента, но их поведение различается по времени выполнения и влиянию на рендеринг.\n`useEffect`\nКогда выполняется:\nВыполняется после того, как браузер закончил обновлять DOM. Это означает, что все изменения в DOM уже произошли, и браузер уже отрисовал интерфейс.\nОсновное использование:\nИспользуется для выполнения побочных эффектов, которые не блокируют отрисовку, таких как сетевые запросы, подписки на события, манипуляции с DOM (не критичные к рендерингу) и регистрация таймеров.\nПоведение:\nНе блокирует рендеринг. Это означает, что пользователь может видеть обновленный интерфейс перед выполнением побочного эффекта.\nПример:\n```javascript\nimport React, { useEffect, useState } from 'react';\nfunction Example() {\n  const [count, setCount] = useState(0);\n  useEffect(() => {\n    console.log('useEffect: Выполняется после рендеринга');\n    document.title = `Вы нажали ${count} раз`;\n    return () => {\n      console.log('useEffect: Очистка');\n    };\n  }, [count]);\n  return (\n    <div>\n      <p>Вы нажали {count} раз</p>\n      <button onClick={() => setCount(count + 1)}>Нажми меня</button>\n    </div>\n  );\n}\nexport default Example;\n```\n`useLayoutEffect`\nКогда выполняется:\nВыполняется синхронно после всех мутировавших эффектов DOM, но перед тем, как браузер обновит экран. Это означает, что изменения, сделанные в\n`useLayoutEffect`\n, будут видны пользователю до того, как браузер нарисует обновленный интерфейс.\nОсновное использование:\nИспользуется для выполнения побочных эффектов, которые должны произойти до отрисовки интерфейса, таких как измерение размеров DOM-элементов, выполнение синхронных изменений в DOM, которые должны произойти перед отрисовкой, или выполнение операций, которые блокируют отрисовку.\nПоведение:\nБлокирует отрисовку до тех пор, пока эффект не будет выполнен. Это может привести к задержке в отображении интерфейса, если эффект выполняется долго.\nПример:\n```javascript\nimport React, { useLayoutEffect, useState } from 'react';\nfunction Example() {\n  const [count, setCount] = useState(0);\n  useLayoutEffect(() => {\n    console.log('useLayoutEffect: Выполняется после рендеринга, но перед отрисовкой');\n    document.title = `Вы нажали ${count} раз`;\n    return () => {\n      console.log('useLayoutEffect: Очистка');\n    };\n  }, [count]);\n  return (\n    <div>\n      <p>Вы нажали {count} раз</p>\n      <button onClick={() => setCount(count + 1)}>Нажми меня</button>\n    </div>\n  );\n}\nexport default Example;\n```\nОсновные различия\n1. Время выполнения:\n`useEffect`\nвыполняется асинхронно после того, как браузер обновил экран.\n`useLayoutEffect`\nвыполняется синхронно перед тем, как браузер обновит экран.\n2. Использование:\n`useEffect`\nлучше подходит для побочных эффектов, которые не влияют на компоновку и отрисовку интерфейса.\n`useLayoutEffect`\nлучше подходит для побочных эффектов, которые должны быть выполнены перед отрисовкой, таких как измерение или изменения в DOM.\nJune 6, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/2zVAkqcUI4o?t=3784",
        title: "СОБЕСЕДОВАНИЕ Middle FRONTEND разраб…",
        time: 3784,
      },
      {
        url: "https://youtu.be/BsIcbU4LB0k?t=4418",
        title: "ИНТЕРЕСНОЕ СОБЕСЕДОВАНИЕ JUNIOR Fron…",
        time: 4418,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1860,
    question: "Для чего нужен promiseall",
    explanation:
      "`Promise.all`\n— это метод, который позволяет обрабатывать несколько промисов одновременно и возвращает один промис, который завершается, когда все переданные промисы либо выполнены, либо один из них отклонен. Он полезен для выполнения нескольких асинхронных операций параллельно и для управления их результатами.\nОсновные особенности\n1. Параллельное выполнение промисов:\nПозволяет выполнять несколько асинхронных операций параллельно. Это особенно полезно, когда результаты этих операций независимы друг от друга.\n2. Единый промис в ответ:\n`Promise.all`\nвозвращает новый промис, который:\nЗавершается успешно, когда все промисы в массиве выполнены.\nОтклоняется, если любой из промисов в массиве отклоняется.\n3. Сбор результатов:\nКогда все промисы успешно выполнены, результирующий промис разрешается массивом результатов всех переданных промисов.\nСинтаксис\n```javascript\nPromise.all(iterable);\n```\niterable:\nмассив или любой итерируемый объект, элементы которого являются промисами или значениями.\nРассмотрим пример, где мы запускаем несколько асинхронных операций одновременно и ждем их завершения.\n```javascript\nconst promise1 = new Promise((resolve) => setTimeout(resolve, 100, 'First'));\nconst promise2 = new Promise((resolve) => setTimeout(resolve, 200, 'Second'));\nconst promise3 = new Promise((resolve) => setTimeout(resolve, 300, 'Third'));\nPromise.all([promise1, promise2, promise3])\n  .then((results) => {\n    console.log(results); // ['First', 'Second', 'Third']\n  })\n  .catch((error) => {\n    console.error('One of the promises failed:', error);\n  });\n```\nЕсли один из промисов отклоняется,\n`Promise.all`\nотклоняет весь результат.\n```javascript\nconst promise1 = new Promise((resolve) => setTimeout(resolve, 100, 'First'));\nconst promise2 = new Promise((resolve, reject) => setTimeout(reject, 200, 'Error in Second'));\nconst promise3 = new Promise((resolve) => setTimeout(resolve, 300, 'Third'));\nPromise.all([promise1, promise2, promise3])\n  .then((results) => {\n    console.log(results); // This line will not be executed\n  })\n  .catch((error) => {\n    console.error('One of the promises failed:', error); // 'Error in Second'\n  });\n```\n`Promise.all`\nтакже можно использовать с\n`async/await`\nдля более удобной работы с асинхронным кодом.\n```javascript\nconst promise1 = new Promise((resolve) => setTimeout(resolve, 100, 'First'));\nconst promise2 = new Promise((resolve) => setTimeout(resolve, 200, 'Second'));\nconst promise3 = new Promise((resolve) => setTimeout(resolve, 300, 'Third'));\nasync function runPromises() {\n  try {\n    const results = await Promise.all([promise1, promise2, promise3]);\n    console.log(results); // ['First', 'Second', 'Third']\n  } catch (error) {\n    console.error('One of the promises failed:', error);\n  }\n}\nrunPromises();\n```\n`Promise.all`\nиспользуется для выполнения нескольких асинхронных операций параллельно и возвращает один промис, который разрешается массивом результатов, если все промисы выполнены успешно, или отклоняется, если любой из промисов отклоняется. Это полезно для управления несколькими асинхронными задачами одновременно.\nJune 6, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/BsIcbU4LB0k?t=1520",
        title: "ИНТЕРЕСНОЕ СОБЕСЕДОВАНИЕ JUNIOR Fron…",
        time: 1520,
      },
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=3079",
        title: "Первое интервью фронтендера самоучки…",
        time: 3079,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1861,
    question: "Как сейчас развиваешься",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/gt-Glqr-1DM?t=20",
        title: "Собеседование frontend junior+ разра…",
        time: 20,
      },
      {
        url: "https://www.youtube.com/watch?v=SR7S5NeJ_JY&t=3210s",
        title: "#18 Сеньор в 23? Собеседование Middl…",
        time: 3210,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1862,
    question: "Что означает слово специфичность в css",
    explanation:
      'Специфичность (specificity)\n— это механизм, который браузеры используют для определения приоритета применяемых стилей. Специфичность определяет, какие правила CSS будут применены к элементу, когда существуют конфликтующие правила. Она рассчитывается на основе различных типов селекторов, используемых в правиле CSS.\nОсновные концепции\n1. Типы селекторов и их веса:\nСпецифичность определяется по типу селекторов, и каждый тип имеет свой вес. В порядке увеличения специфичности:\nЭлементы и псевдоэлементы\n(\n`div`\n,\n`h1`\n,\n`p`\n,\n`::before`\n,\n`::after`\n): вес 1.\nКлассы, атрибуты и псевдоклассы\n(\n`.class`\n,\n`[type="text"]`\n,\n`:hover`\n,\n`:nth-child`\n): вес 10.\nИдентификаторы\n(\n`#id`\n): вес 100.\nИнлайновые стили\n(стили, заданные непосредственно в элементе с атрибутом\n`style`\n): вес 1000.\nВажные правила\n(\n`!important`\n): не учитывают специфичность, а просто переопределяют другие правила.\n2. Правила вычисления специфичности:\nСпецифичность CSS выражается в виде чисел (a, b, c, d), где:\n`a`\n— количество инлайновых стилей (1 или 0).\n`b`\n— количество идентификаторов.\n`c`\n— количество классов, атрибутов и псевдоклассов.\n`d`\n— количество элементов и псевдоэлементов.\nПримеры расчета специфичности\n1. Элементы и псевдоэлементы:\n```css\n   div { color: red; } /* Специфичность: 0, 0, 0, 1 */\n   p::before { content: \'\'; } /* Специфичность: 0, 0, 0, 2 */\n   ```\n2. Классы, атрибуты и псевдоклассы:\n```css\n   .example { color: blue; } /* Специфичность: 0, 0, 1, 0 */\n   [type="text"] { color: green; } /* Специфичность: 0, 0, 1, 0 */\n   :hover { color: yellow; } /* Специфичность: 0, 0, 1, 0 */\n   ```\n3. Идентификаторы:\n```css\n   #unique { color: orange; } /* Специфичность: 0, 1, 0, 0 */\n   ```\n4. Инлайновые стили:\n```html\n   <div style="color: purple;"></div> <!-- Специфичность: 1, 0, 0, 0 -->\n   ```\n5. Комбинированные селекторы:\n```css\n   #unique .example:hover { color: pink; } /* Специфичность: 0, 1, 1, 1 */\n   ```\nЕсли два или более правил CSS применяются к одному и тому же элементу, приоритет будет у правила с наибольшей специфичностью.\n```html\n<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>Specificity Example</title>\n  <style>\n    p { color: red; } /* Специфичность: 0, 0, 0, 1 */\n    .text { color: green; } /* Специфичность: 0, 0, 1, 0 */\n    #unique { color: blue; } /* Специфичность: 0, 1, 0, 0 */\n    .text#unique { color: orange; } /* Специфичность: 0, 1, 1, 0 */\n  </style>\n</head>\n<body>\n  <p class="text" id="unique">This is a paragraph.</p>\n</body>\n</html>\n```\nВ этом примере, текст параграфа будет оранжевого цвета, так как правило\n`.text#unique`\nимеет наибольшую специфичность (0, 1, 1, 0).\nИспользование\n`!important`\nПравила с ним имеют наивысший приоритет и могут переопределить даже те стили, которые имеют более высокую специфичность. Тем не менее, злоупотребление\n`!important`\nможет затруднить управление стилями и отладку.\n```css\np { color: red !important; } /* Перебивает все другие правила */\n```\nСпецифичность пределяет приоритет применяемых стилей на основе типов селекторов и их веса. Она используется браузером для разрешения конфликтов между различными правилами CSS, чтобы определить, какие стили применяются к элементу.\nJune 6, 2024, easyoffer',
    videos: [
      {
        url: "https://youtu.be/gt-Glqr-1DM?t=1410",
        title: "Собеседование frontend junior+ разра…",
        time: 1410,
      },
      {
        url: "https://youtu.be/e2r3JAuMSSg?t=5322",
        title: "#1. Публичное собеседование JUNIOR F…",
        time: 5322,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1863,
    question: "Расскажи про преобразование типов",
    explanation:
      "Преобразование типов\n— это процесс приведения значения из одного типа в другой. JavaScript, как язык с динамической типизацией, автоматически преобразует типы значений, когда это необходимо, но также позволяет разработчикам явно выполнять преобразования типов.\nВиды преобразования\n1. Неявное (автоматическое):\nЭто преобразование, которое происходит автоматически при выполнении операций с разными типами данных. Например, при сложении числа и строки JavaScript автоматически преобразует число в строку.\n2. Явное:\nЭто преобразование, которое выполняется разработчиком явно с использованием встроенных функций или операторов.\nПримеры неявного\n1. Строковое преобразование:\nПри конкатенации строки с числом число автоматически преобразуется в строку.\n```javascript\n   const result = 'The answer is ' + 42;\n   console.log(result); // 'The answer is 42'\n   ```\n2. Числовое преобразование:\nПри выполнении арифметических операций строка, содержащая число, автоматически преобразуется в число.\n```javascript\n   const result = '42' - 10;\n   console.log(result); // 32\n   ```\n3. Логическое преобразование:\nВ логическом контексте (например, в условиях\n`if`\n) значения автоматически приводятся к логическому типу (\n`true`\nили\n`false`\n).\n```javascript\n   if ('hello') {\n     console.log('This is true'); // This is true\n   }\n   if (0) {\n     console.log('This is false'); // This will not be executed\n   }\n   ```\nПримеры явного\n1. Преобразование в строку:\nДля явного преобразования в строку можно использовать метод\n`String()`\nили оператор\n`+`\nс пустой строкой.\n```javascript\n   const num = 42;\n   const str1 = String(num);\n   const str2 = num + '';\n   console.log(str1); // '42'\n   console.log(str2); // '42'\n   ```\n2. Преобразование в число:\nДля явного преобразования в число можно использовать функции\n`Number()`\n,\n`parseInt()`\n, или\n`parseFloat()`\n.\n```javascript\n   const str = '42';\n   const num1 = Number(str);\n   const num2 = parseInt(str, 10);\n   const num3 = parseFloat(str);\n   console.log(num1); // 42\n   console.log(num2); // 42\n   console.log(num3); // 42\n   ```\n3. Преобразование в логическое значение:\nДля явного преобразования в логическое значение можно использовать функцию\n`Boolean()`\nили двойное отрицание\n`!!`\n.\n```javascript\n   const value = 0;\n   const bool1 = Boolean(value);\n   const bool2 = !!value;\n   console.log(bool1); // false\n   console.log(bool2); // false\n   ```\nТаблица преобразования типов\n| Значение          | К строке          | К числу          | К логическому   |\n|-------------------|-------------------|------------------|-----------------|\n| `undefined`       | `'undefined'`     | `NaN`            | `false`         |\n| `null`            | `'null'`          | `0`              | `false`         |\n| `true`            | `'true'`          | `1`              | `true`          |\n| `false`           | `'false'`         | `0`              | `false`         |\n| `42`              | `'42'`            | `42`             | `true`          |\n| `0`               | `'0'`             | `0`              | `false`         |\n| `''` (пустая строка) | `''`          | `0`              | `false`         |\n| `'42'`            | `'42'`            | `42`             | `true`          |\n| `'hello'`         | `'hello'`         | `NaN`            | `true`          |\n| `{}` (пустой объект) | `'[object Object]'` | `NaN`        | `true`          |\n| `[]` (пустой массив) | `''`          | `0`              | `true`          |\n| `[42]`            | `'42'`            | `42`             | `true`          |\n| `[1, 2, 3]`       | `'1,2,3'`         | `NaN`            | `true`          |\nПреобразование типов\n— это процесс приведения значения из одного типа в другой. Оно может происходить автоматически (неявное преобразование) или выполняться разработчиком явно (явное преобразование). Предоставляет функции и методы для преобразования в строки, числа и логические значения.\nJune 16, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/gt-Glqr-1DM?t=2080",
        title: "Собеседование frontend junior+ разра…",
        time: 2080,
      },
      {
        url: "https://youtu.be/cRqBsepPgoI?t=1731",
        title: "Собеседование frontend junior+ разра…",
        time: 1731,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1864,
    question: "Как расшифровывается css",
    explanation:
      'CSS расшифровывается как\nCascading Style Sheets\n, что в переводе означает "каскадные таблицы стилей". Давайте рассмотрим каждый элемент этого термина:\n1. Cascading (каскадные):\nЭтот термин указывает на то, что стили применяются к элементам HTML в определенном порядке приоритетов. Когда стили конфликтуют (например, когда одно и то же свойство задано несколькими стилями), CSS использует каскадные правила для разрешения этих конфликтов. Эти правила включают:\nСпецифичность селекторов (различные типы селекторов имеют разный приоритет).\nПорядок расположения в коде (последний стиль имеет больший приоритет).\nИспользование ключевого слова\n`!important`\n(приоритет выше всех обычных правил).\n2. Style (стили):\nСтили определяют, как должны выглядеть элементы HTML на веб-странице. Это включает в себя множество свойств, таких как цвета, шрифты, размеры, расположение, отступы и многие другие аспекты внешнего вида.\n3. Sheets (таблицы):\nCSS-правила обычно хранятся в файлах, которые называются таблицами стилей. Эти файлы могут быть внешними (подключенными к HTML-документу через элемент\n`<link>`\n), встроенными (внутри элемента\n`<style>`\nв самом HTML-документе) или инлайновыми (непосредственно в атрибутах стиля HTML-элементов).\nВот пример CSS, который показывает использование каскадных таблиц стилей для стилизации HTML-документа:\n```html\n<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>CSS Example</title>\n  <link rel="stylesheet" href="styles.css">\n  <style>\n    .inline-style {\n      color: red;\n    }\n  </style>\n</head>\n<body>\n  <h1 class="heading inline-style">Hello, World!</h1>\n  <p>This is a paragraph.</p>\n</body>\n</html>\n```\nВ этом примере:\nВнешний файл\n`styles.css`\nзадает стили для\n`body`\n,\n`h1`\nи элементов с классом\n`.heading`\n.\nВстроенные стили в элементе\n`<style>`\nзадают цвет текста для элементов с классом\n`.inline-style`\n.\nКаскадные правила CSS определяют, что цвет текста элемента\n`<h1>`\nбудет красным, так как инлайновые стили имеют наибольший приоритет.\nCSS расшифровывается как Cascading Style Sheets, что означает "каскадные таблицы стилей". Это язык, используемый для описания внешнего вида и форматирования HTML-документов, поддерживающий каскадные правила для разрешения конфликтов между стилями.\nJune 16, 2024, easyoffer',
    videos: [
      {
        url: "https://youtu.be/cRqBsepPgoI?t=1270",
        title: "Собеседование frontend junior+ разра…",
        time: 1270,
      },
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=821s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 821,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1865,
    question: "Какие функции есть в js",
    explanation:
      "Существует несколько типов функций, каждая из которых имеет свои особенности и области применения. Вот основные виды функций:\n1. Функциональные выражения и объявленные функции\nОбъявленные функции (Function Declaration)\nОбъявленные с использованием ключевого слова\n`function`\n, идущего перед именем функции. Эти функции \"всплывают\" (hoisted), что означает, что они могут быть вызваны до их определения в коде.\n```javascript\nfunction greet(name) {\n  return `Hello, ${name}!`;\n}\nconsole.log(greet('Alice')); // Hello, Alice!\n```\nФункциональные выражения (Function Expression)\nНе \"всплывают\" и не могут быть вызваны до их определения.\n```javascript\nconst greet = function(name) {\n  return `Hello, ${name}!`;\n};\nconsole.log(greet('Bob')); // Hello, Bob!\n```\n2. Стрелочные функции (Arrow Functions)\nЭто сокращенный синтаксис для создания функций, введенный в ES6. Они не имеют собственного контекста\n`this`\nи не могут быть использованы в качестве методов или конструктора.\n```javascript\nconst greet = (name) => `Hello, ${name}!`;\nconsole.log(greet('Charlie')); // Hello, Charlie!\n```\n3. Анонимные функции\nЧасто используются в качестве аргументов для других функций или для создания замыканий.\n```javascript\nsetTimeout(function() {\n  console.log('This will run after 1 second');\n}, 1000);\n```\n4. Функции-конструкторы\nДля создания объектов. Они вызываются с ключевым словом\n`new`\nи обычно имеют заглавную букву в названии.\n```javascript\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\nconst alice = new Person('Alice', 30);\nconsole.log(alice.name); // Alice\n```\n5. Методы объекта\nЯвляются свойствами объекта.\n```javascript\nconst person = {\n  name: 'Alice',\n  greet: function() {\n    return `Hello, my name is ${this.name}`;\n  }\n};\nconsole.log(person.greet()); // Hello, my name is Alice\n```\n6. Генераторы (Generators)\nМогут быть приостановлены и возобновлены в любой момент. Они объявляются с помощью\n`function*`\nи используют ключевое слово\n`yield`\n.\n```javascript\nfunction* generatorFunction() {\n  yield 'First';\n  yield 'Second';\n  yield 'Third';\n}\nconst gen = generatorFunction();\nconsole.log(gen.next().value); // First\nconsole.log(gen.next().value); // Second\nconsole.log(gen.next().value); // Third\n```\n7. Асинхронные функции (Async/Await)\nВозвращают промис и позволяют использовать синтаксис\n`await`\nдля упрощения работы с асинхронным кодом.\n```javascript\nasync function fetchData() {\n  const response = await fetch('https://api.example.com/data');\n  const data = await response.json();\n  return data;\n}\nfetchData().then(data => console.log(data));\n```\n8. Функции обратного вызова (Callbacks)\nПередаваемые в качестве аргументов в другие функции и вызываемые позже.\n```javascript\nfunction fetchData(callback) {\n  setTimeout(() => {\n    const data = { name: 'Alice' };\n    callback(data);\n  }, 1000);\n}\nfetchData(function(data) {\n  console.log(data); // { name: 'Alice' }\n});\n```\nЕсть несколько типов функций, включая объявленные функции, функциональные выражения, стрелочные функции, анонимные функции, функции-конструкторы, методы объекта, генераторы, асинхронные функции и функции обратного вызова. Каждый тип функций имеет свои особенности и области применения.\nJune 16, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=1079",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 1079,
      },
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=438",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 438,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1866,
    question: "Откуда берется контекст функции",
    explanation:
      "Контекст функции\n— это значение, которое доступно через ключевое слово\n`this`\n. Контекст функции определяется способом ее вызова, а не тем, где функция была определена. Вот основные способы, которыми определяется контекст функции:\n1. Глобальный контекст и контекст функций\nГлобальный контекст:\nВ глобальной области видимости\n`this`\nссылается на глобальный объект. В браузере это объект\n`window`\n.\n```javascript\n  console.log(this); // В браузере это будет window\n  ```\nКонтекст функции:\nПри обычном вызове функции\n`this`\nссылается на глобальный объект (в строгом режиме —\n`undefined`\n).\n```javascript\n  function showThis() {\n    console.log(this);\n  }\n  showThis(); // В браузере это будет window (или undefined в строгом режиме)\n  ```\n2. Контекст методов объекта\nКогда функция вызывается как метод объекта,\n`this`\nссылается на объект, которому принадлежит метод.\n```javascript\nconst obj = {\n  name: 'Alice',\n  showThis: function() {\n    console.log(this);\n  }\n};\nobj.showThis(); // { name: 'Alice', showThis: [Function: showThis] }\n```\n3. Конструкторы и классы\nПри вызове функции-конструктора с ключевым словом\n`new`\n,\n`this`\nссылается на новый созданный объект.\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\nconst alice = new Person('Alice');\nconsole.log(alice.name); // Alice\n```\n4. call, apply и bind\nЭти методы позволяют явно устанавливать контекст\n`this`\nпри вызове функции.\n`call`:\nвызывает функцию с указанным значением\n`this`\nи аргументами, переданными по отдельности.\n```javascript\n  function showThis() {\n    console.log(this);\n  }\n  const obj = { name: 'Alice' };\n  showThis.call(obj); // { name: 'Alice' }\n  ```\n`apply`:\nвызывает функцию с указанным значением\n`this`\nи аргументами, переданными в виде массива.\n```javascript\n  showThis.apply(obj); // { name: 'Alice' }\n  ```\n`bind`:\nвозвращает новую функцию, которая при вызове будет иметь указанный контекст\n`this`\n.\n```javascript\n  const boundShowThis = showThis.bind(obj);\n  boundShowThis(); // { name: 'Alice' }\n  ```\n5. Стрелочные функции\nНе имеют собственного контекста\n`this`\n. Вместо этого они захватывают\n`this`\nиз окружающего лексического контекста.\n```javascript\nconst obj = {\n  name: 'Alice',\n  showThis: function() {\n    const arrowFunc = () => console.log(this);\n    arrowFunc();\n  }\n};\nobj.showThis(); // { name: 'Alice' }\n```\n6. Обработчики событий\nВ обработчиках событий\n`this`\nссылается на элемент, к которому прикреплен обработчик.\n```javascript\nconst button = document.querySelector('button');\nbutton.addEventListener('click', function() {\n  console.log(this); // <button> элемент\n});\n```\nКонтекст функции (\n`this`\n) определяется способом вызова функции. В глобальной области видимости\n`this`\nссылается на глобальный объект. В методах объекта\n`this`\nссылается на сам объект. В функциях-конструкторах\n`this`\nссылается на новый созданный объект. Методы\n`call`\n,\n`apply`\nи\n`bind`\nпозволяют явно задавать значение\n`this`\n. Стрелочные функции захватывают\n`this`\nиз окружающего контекста. В обработчиках событий\n`this`\nссылается на элемент, к которому прикреплен обработчик.\nJune 16, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=1470",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 1470,
      },
      {
        url: "https://www.youtube.com/watch?v=EaTZXKlpsj0&t=5860s",
        title: "#11 Фронтендер в 17 лет? Собеседован…",
        time: 5860,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1867,
    question: "Почему важно указывать ширину и высоту для картинок",
    explanation:
      'Указание ширины и высоты для изображений в HTML имеет несколько важных преимуществ, которые влияют на производительность, рендеринг и пользовательский опыт:\n1. Улучшение производительности и оптимизация рендеринга\nПредотвращение перерисовок и переформатирования (reflows):\nКогда браузер загружает страницу, он сначала строит DOM (Document Object Model) и CSSOM (CSS Object Model). Если размеры изображений не указаны, браузеру приходится ждать, пока изображения загрузятся, чтобы узнать их размеры. Это может вызвать переформатирование страницы, когда элементы перемещаются, чтобы освободить место для изображений. Указание размеров заранее позволяет браузеру зарезервировать нужное пространство, избегая дополнительных перерисовок и улучшая производительность.\n2. Улучшение пользовательского опыта\nСтабильная компоновка (layout stability):\nКогда размеры изображений указаны, браузер может зарезервировать пространство для каждого изображения до его загрузки. Это предотвращает смещение контента во время загрузки страницы, обеспечивая более плавный и предсказуемый пользовательский опыт.\n3. Быстрая загрузка страниц\nЭффективное использование сетевых ресурсов:\nЗнание точных размеров изображений позволяет браузеру более эффективно обрабатывать загрузку и отображение контента, уменьшая задержки и улучшая общую производительность страницы.\n4. Сокращение времени до первого отрисовки (First Contentful Paint, FCP)\nОптимизация рендеринга:\nКогда браузер знает размеры изображений, он может быстрее отрисовать контент страницы, даже если изображения еще не загружены. Это сокращает время до первого отрисовки (FCP), что является важным показателем производительности.\nРассмотрим пример HTML-кода, в котором указаны размеры изображения:\n```html\n<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>Image Size Example</title>\n  <style>\n    img {\n      display: block;\n      max-width: 100%;\n      height: auto;\n    }\n  </style>\n</head>\n<body>\n  <h1>Example Image</h1>\n  <img src="image.jpg" width="600" height="400" alt="Example Image">\n</body>\n</html>\n```\nВ этом примере:\nАтрибуты\n`width`\nи\n`height`\nзадают фиксированные размеры для изображения. Это позволяет браузеру зарезервировать нужное пространство до загрузки изображения.\nCSS-правило\n`max-width: 100%; height: auto;`\nгарантирует, что изображение будет масштабироваться в зависимости от ширины контейнера, сохраняя пропорции.\nУказание ширины и высоты для изображений в HTML улучшает производительность и пользовательский опыт. Оно позволяет браузеру зарезервировать пространство для изображений, предотвращает переформатирование страницы и смещение контента, ускоряет рендеринг и снижает время до первого отрисовки.\nJune 16, 2024, easyoffer',
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=5642",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 5642,
      },
      {
        url: "https://youtu.be/BOCkaqdbdCg?t=710",
        title: "Собеседование на Junior Frontend раз…",
        time: 710,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1868,
    question:
      "Расскажи какие задачи решаешь на текущей работе и с чем сталкиваешься",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/d5weK2w1V4A?t=117",
        title: "Собеседование Junior Frontend разраб…",
        time: 117,
      },
      {
        url: "https://www.youtube.com/watch?v=lrdaRbJctaA&t=401s",
        title: "Frontend интервью. Ильнура, первая р…",
        time: 401,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1869,
    question: "Когда используются переменные, var, let, const",
    explanation:
      "Переменные объявляются с помощью ключевых слов\n`var`\n,\n`let`\nи\n`const`\n. Они имеют разные особенности и используются в разных ситуациях.\n`var`\nИспользовался до появления ES6 (ECMAScript 2015) и обладает следующими особенностями:\n1. Область видимости: `var`\nимеет функциональную область видимости, то есть она видна внутри функции, где была объявлена, или в глобальной области, если объявлена вне функций.\n2. Поднятие (hoisting):\nОбъявления с\n`var`\nподнимаются вверх своей области видимости, но присвоение значения происходит в том месте, где оно записано. Это значит, что переменную можно использовать до ее объявления.\n3. Повторное объявление:\nПеременные, объявленные с\n`var`\n, могут быть переобъявлены в пределах одной и той же области видимости.\nПример:\n```javascript\nfunction exampleVar() {\n  console.log(x); // undefined\n  var x = 10;\n  console.log(x); // 10\n}\nexampleVar();\n```\n`let`\nПоявился в ES6 и решает многие проблемы, связанные с\n`var`\n:\n1. Область видимости: `let`\nимеет блочную область видимости, то есть виден только внутри блока\n`{}`\n, в котором объявлен.\n2. Поднятие (hoisting):\nХотя объявления с\n`let`\nподнимаются, доступ к ним возможен только после строки, где они объявлены (временная мертвая зона).\n3. Повторное объявление:\nНельзя переобъявить переменную, объявленную с\n`let`\n, в той же области видимости.\nПример:\n```javascript\nfunction exampleLet() {\n  console.log(y); // ReferenceError: y is not defined\n  let y = 10;\n  console.log(y); // 10\n}\nexampleLet();\n```\n`const`\nТакже введённый в ES6, используется для объявления констант:\n1. Область видимости:\nКак и\n`let`\n, имеет блочную область видимости.\n2. Поднятие (hoisting):\nВедет себя аналогично\n`let`\nв плане поднятия и временной мертвой зоны.\n3. Изменение значения:\nПеременная, объявленная с\n`const`\n, должна быть инициализирована при объявлении и её значение нельзя изменить после этого. Однако, если\n`const`\nиспользуется для объявления объекта или массива, можно изменять их содержимое.Пример:\n```javascript\nfunction exampleConst() {\n  const z = 10;\n  console.log(z); // 10\n  z = 20; // TypeError: Assignment to constant variable.\n}\nexampleConst();\nfunction exampleConstObject() {\n  const obj = { key: 'value' };\n  obj.key = 'new value'; // Изменение допустимо\n  console.log(obj.key); // 'new value'\n}\nexampleConstObject();\n```\nКогда использовать\n`var`:\nОбычно рекомендуется избегать, так как `let` и `const` обеспечивают лучшую управляемость кода.\n`let`:\nИспользуется для переменных, которые могут изменяться в процессе выполнения программы.\n`const`:\nИспользуется для значений, которые не будут переназначены. Это помогает предотвратить ошибки и делает код более предсказуемым.\nJune 16, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/d5weK2w1V4A?t=378",
        title: "Собеседование Junior Frontend разраб…",
        time: 378,
      },
      {
        url: "https://youtu.be/FrP3AGanqX0?t=570",
        title: "Собеседование cтажера Frontend разра…",
        time: 570,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1870,
    question: "Что такое функция в js",
    explanation:
      "Функция\n— это блок кода, предназначенный для выполнения конкретной задачи, который может быть вызван многократно в разных местах программы. Функции позволяют структурировать код, повышать его читаемость и повторно использовать части кода.\nЗачем нужны функции\n1. Повторное использование кода:\nОдин раз написав функцию, можно вызывать её множество раз с разными аргументами, не переписывая один и тот же код.\n2. Упрощение и структурирование кода:\nФункции помогают разбивать программу на логические блоки, что делает код более понятным и поддерживаемым.\n3. Инкапсуляция:\nФункции могут скрывать внутреннюю реализацию и предоставлять только необходимый интерфейс.\nКак они создаются\nЕсть несколько способов создания функций:\n1. Function Declaration (Объявление функции):\n```javascript\nfunction greet(name) {\n  return `Hello, ${name}!`;\n}\nconsole.log(greet('Alice')); // Hello, Alice!\n```\nФункция объявляется с помощью ключевого слова\n`function`\n, за которым следуют имя функции, список параметров в круглых скобках и тело функции в фигурных скобках.\n2. Function Expression (Функциональное выражение):\n```javascript\nconst greet = function(name) {\n  return `Hello, ${name}!`;\n};\nconsole.log(greet('Bob')); // Hello, Bob!\n```\nФункция создается и присваивается переменной. Такие функции могут быть анонимными (без имени).\n3. Arrow Function (Стрелочная функция):\n```javascript\nconst greet = (name) => {\n  return `Hello, ${name}!`;\n};\nconsole.log(greet('Carol')); // Hello, Carol!\n```\nСтрелочные функции имеют более короткий синтаксис и не имеют своего контекста\n`this`\n.\nВызов функции\nФункцию можно вызвать, используя её имя и передавая необходимые аргументы в круглых скобках:\n```javascript\nfunction add(a, b) {\n  return a + b;\n}\nconsole.log(add(2, 3)); // 5\n```\nПараметры и аргументы\nПараметры\n— это переменные, которые перечислены в круглых скобках при объявлении функции.\nАргументы\n— это значения, которые передаются функции при её вызове.\nВозвращаемое значение\nФункция может возвращать значение с помощью ключевого слова\n`return`\n. Если\n`return`\nотсутствует, функция возвращает `undefined`.\n```javascript\nfunction multiply(a, b) {\n  return a * b;\n}\nconsole.log(multiply(4, 5)); // 20\n```\nОбласть видимости\nПеременные, объявленные внутри функции, имеют локальную область видимости и недоступны за её пределами:\n```javascript\nfunction scopeExample() {\n  let localVar = 'I am local';\n  console.log(localVar); // I am local\n}\nscopeExample();\nconsole.log(localVar); // ReferenceError: localVar is not defined\n```\nЗамыкания (Closures)\nФункции имеют доступ к переменным из внешних функций благодаря замыканиям:\n```javascript\nfunction outerFunction() {\n  let outerVar = 'I am outside!';\n  function innerFunction() {\n    console.log(outerVar);\n  }\n  return innerFunction;\n}\nconst inner = outerFunction();\ninner(); // I am outside!\n```\nФункция\n— это блок кода, который можно многократно использовать. Функции помогают делать код структурированным, повторно используемым и более читаемым.\nJune 16, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=435",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 435,
      },
      {
        url: "https://youtu.be/KvPUlwkSs_E?t=1377",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 1377,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1871,
    question: "Зачем необходим dom",
    explanation:
      "DOM (Document Object Model)\nнеобходим для взаимодействия с веб-страницами и управления их содержимым, структурой и стилями программным образом. DOM представляет собой программный интерфейс для HTML и XML документов. Он описывает логическую структуру документов и позволяет языкам программирования взаимодействовать с ними.\nЗачем он нужен\n1. Доступ к элементам страницы:\nПозволяет программно получать доступ к элементам HTML-документа (теги, текст, атрибуты) и манипулировать ими.\n2. Изменение содержимого:\nС помощью него можно изменять содержимое страницы динамически, например, обновлять текст, менять изображения, добавлять или удалять элементы.\n3. Обработка событий:\nПозволяет обрабатывать события, такие как клики, нажатия клавиш, прокрутка и другие взаимодействия пользователя с веб-страницей.\n4. Динамическое изменение структуры страницы:\nПредоставляет методы для добавления, удаления и изменения элементов и атрибутов, что позволяет динамически изменять структуру страницы.\n5. Интерактивность:\nС помощью него можно создавать интерактивные веб-приложения, которые реагируют на действия пользователя без перезагрузки страницы.\nКак он работает\nПредставляет собой древовидную структуру, где каждый элемент страницы является узлом дерева. Вершиной дерева является объект\n`document`\n, который представляет весь HTML-документ. Узлы могут быть элементами (\n`<div>`\n,\n`<p>`\n,\n`<a>`\nи т.д.), текстом, комментариями и другими типами.Пример HTML-документа:\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <title>Document Object Model</title>\n</head>\n<body>\n  <h1>Hello, world!</h1>\n  <p>This is a paragraph.</p>\n</body>\n</html>\n```\nСтруктура для этого документа:\n```\ndocument\n └── html\n     ├── head\n     │   └── title\n     │       └── \"Document Object Model\"\n     └── body\n         ├── h1\n         │   └── \"Hello, world!\"\n         └── p\n             └── \"This is a paragraph.\"\n```\nОсновные методы и свойства\n1. Доступ к элементам:\n`document.getElementById(id)`:\nВозвращает элемент по его\n`id`\n.\n`document.getElementsByClassName(className)`:\nВозвращает все элементы с указанным классом.\n`document.getElementsByTagName(tagName)`:\nВозвращает все элементы с указанным тегом.\n`document.querySelector(selector)`:\nВозвращает первый элемент, соответствующий CSS селектору.\n`document.querySelectorAll(selector)`:\nВозвращает все элементы, соответствующие CSS селектору.\n2. Создание и удаление элементов:\n`document.createElement(tagName)`:\nСоздает новый элемент.\n`parentElement.appendChild(childElement)`:\nДобавляет элемент в конец дочерних элементов родителя.\n`parentElement.removeChild(childElement)`:\nУдаляет элемент из дочерних элементов родителя.\n3. Изменение содержимого и атрибутов:\n`element.innerHTML`:\nИзменяет или получает HTML-содержимое элемента.\n`element.textContent`:\nИзменяет или получает текстовое содержимое элемента.\n`element.setAttribute(name, value)`:\nУстанавливает значение атрибута элемента.\n`element.getAttribute(name)`:\nПолучает значение атрибута элемента.\nПример:\n```javascript\n// Изменение текста заголовка\nconst header = document.querySelector('h1');\nheader.textContent = 'Hello, DOM!';\n// Добавление нового параграфа\nconst newParagraph = document.createElement('p');\nnewParagraph.textContent = 'This is a new paragraph.';\ndocument.body.appendChild(newParagraph);\n// Изменение атрибута\nconst link = document.querySelector('a');\nlink.setAttribute('href', 'https://www.example.com');\n```\nDOM необходим для программного доступа и управления содержимым веб-страницы. Он позволяет изменять текст, структуру, стили и обрабатывать события на странице.\nJune 16, 2024, easyoffer",
    videos: [
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=2944",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 2944,
      },
      {
        url: "https://www.youtube.com/watch?v=EaTZXKlpsj0&t=6595s",
        title: "#11 Фронтендер в 17 лет? Собеседован…",
        time: 6595,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1876,
    question: "Какие есть способы общения между компонентами",
    explanation:
      'В современных фронтенд-фреймворках, таких как React, Vue.js и Angular, есть несколько способов общения между компонентами. Эти способы включают передачу данных и событий, управление состоянием и использование контекста или глобальных хранилищ. Основные методы:\n1. Передача пропсов (props)\nПередача данных от родительского компонента к дочернему с помощью свойств (props) является самым распространенным способом общения.\n```jsx\n// Родительский компонент\nfunction ParentComponent() {\n  const message = "Привет, мир!";\n  return <ChildComponent message={message} />;\n}\n// Дочерний компонент\nfunction ChildComponent(props) {\n  return <p>{props.message}</p>;\n}\n```\n2. Обратный вызов функций (Callback Functions)\nРодительский компонент может передать дочернему компоненту функцию в качестве пропса. Дочерний компонент вызывает эту функцию, чтобы отправить данные обратно родителю.\n```jsx\n// Родительский компонент\nfunction ParentComponent() {\n  const handleData = (data) => {\n    console.log("Данные от дочернего компонента:", data);\n  };\n  return <ChildComponent onSendData={handleData} />;\n}\n// Дочерний компонент\nfunction ChildComponent(props) {\n  const sendData = () => {\n    props.onSendData("Привет от дочернего компонента!");\n  };\n  return <button onClick={sendData}>Отправить данные</button>;\n}\n```\n3. Контекст (Context)\nПозволяет передавать данные через дерево компонентов, не прибегая к явной передаче пропсов на каждом уровне.\n```jsx\nconst MyContext = React.createContext();\n// Родительский компонент\nfunction ParentComponent() {\n  const value = "Данные из контекста";\n  return (\n    <MyContext.Provider value={value}>\n      <ChildComponent />\n    </MyContext.Provider>\n  );\n}\n// Дочерний компонент\nfunction ChildComponent() {\n  const contextValue = React.useContext(MyContext);\n  return <p>{contextValue}</p>;\n}\n```\n4. Глобальное состояние (State Management)\nИспользование библиотек для управления состоянием, таких как Redux, Vuex или Zustand, позволяет управлять состоянием приложения централизованно и предоставлять доступ к данным любому компоненту.\n```jsx\n// Действие\nconst setMessage = (message) => ({\n  type: "SET_MESSAGE",\n  payload: message,\n});\n// Редуктор\nconst reducer = (state = { message: "" }, action) => {\n  switch (action.type) {\n    case "SET_MESSAGE":\n      return { ...state, message: action.payload };\n    default:\n      return state;\n  }\n};\n// Компонент, отправляющий действие\nfunction SenderComponent() {\n  const dispatch = useDispatch();\n  const sendMessage = () => {\n    dispatch(setMessage("Привет из Redux!"));\n  };\n  return <button onClick={sendMessage}>Отправить сообщение</button>;\n}\n// Компонент, получающий данные из состояния\nfunction ReceiverComponent() {\n  const message = useSelector((state) => state.message);\n  return <p>{message}</p>;\n}\n```\n5. События и эмиттеры (Event Emitters)\nНекоторые фреймворки, такие как Vue.js, предоставляют встроенные возможности для передачи событий между компонентами.\n```html\n<!-- Родительский компонент -->\n<template>\n  <ChildComponent @custom-event="handleEvent" />\n</template>\n<script>\nexport default {\n  methods: {\n    handleEvent(data) {\n      console.log("Получено событие с данными:", data);\n    },\n  },\n};\n</script>\n<!-- Дочерний компонент -->\n<template>\n  <button @click="emitEvent">Отправить событие</button>\n</template>\n<script>\nexport default {\n  methods: {\n    emitEvent() {\n      this.$emit("custom-event", "Данные от дочернего компонента");\n    },\n  },\n};\n</script>\n```\n6. Локальное состояние и методы передачи (Local State and Prop Drilling)\nВ небольших приложениях передача состояния через пропсы (prop drilling) может быть приемлемой, хотя и не всегда удобной.\n```jsx\n// Корневой компонент\nfunction RootComponent() {\n  const [state, setState] = React.useState("Начальное состояние");\n  const updateState = (newState) => {\n    setState(newState);\n  };\n  return <ParentComponent state={state} updateState={updateState} />;\n}\n// Родительский компонент\nfunction ParentComponent({ state, updateState }) {\n  return <ChildComponent state={state} updateState={updateState} />;\n}\n// Дочерний компонент\nfunction ChildComponent({ state, updateState }) {\n  const changeState = () => {\n    updateState("Обновленное состояние");\n  };\n  return (\n    <div>\n      <p>{state}</p>\n      <button onClick={changeState}>Изменить состояние</button>\n    </div>\n  );\n}\n```\nКомпоненты могут общаться через пропсы, обратные вызовы, контекст, глобальное состояние, события и эмиттеры, а также через передачу состояния по цепочке компонентов. Каждый метод подходит для определенных задач и зависит от структуры приложения и используемого фреймворка.\nJuly 1, 2024, easyoffer',
    videos: [
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=4806s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 4806,
      },
      {
        url: "https://youtu.be/qGdV5YOmtrs?t=5149",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 5149,
      },
    ],
    rating: 6,
    image: null,
  },
  {
    id: 1886,
    question: "Почему именно angular",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/N1gKaF6BhDc?t=190",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 190,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1887,
    question: "Какие примитивные данные в javascript знаешь",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/N1gKaF6BhDc?t=689",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 689,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1888,
    question: "Особенности работы с function expression и function declaration",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/N1gKaF6BhDc?t=1117",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 1117,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1889,
    question: "Для чего нужны методы call apply bind",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/N1gKaF6BhDc?t=1183",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 1183,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1890,
    question: "Что такое fiction function expression и для чего она нужна",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/N1gKaF6BhDc?t=1556",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 1556,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1891,
    question:
      "В чём преимущество синтаксического сахара в виде async await над promise",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/N1gKaF6BhDc?t=2174",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 2174,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1892,
    question: "Расскажи о том что такое promise race",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/N1gKaF6BhDc?feature=share&t=2506",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 2506,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1893,
    question: "Что является результатом выполнения асинхронных функций",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/N1gKaF6BhDc?t=2595",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 2595,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1894,
    question: "Какой тип возвращает синхронная функция",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/N1gKaF6BhDc?feature=share&t=2642",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 2642,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1895,
    question: "Как работает angular",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/N1gKaF6BhDc?t=2713",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 2713,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1896,
    question: "Какие есть типы привязок в angular",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/N1gKaF6BhDc?feature=share&t=2850",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 2850,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1897,
    question: "Отличия между привязками в angular",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/N1gKaF6BhDc?t=2855",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 2855,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1898,
    question: "Что такое pipe",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/N1gKaF6BhDc?t=3105",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 3105,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1899,
    question: "Какой особенностью обладает pipe",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/N1gKaF6BhDc?t=3107",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 3107,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1900,
    question: "Какая есть важная особенность у pipe",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/N1gKaF6BhDc?t=3192",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 3192,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1901,
    question: "Что такое observable",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/N1gKaF6BhDc?t=3413",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 3413,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1902,
    question: "К какой структуре данных в javascript близок observable",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/N1gKaF6BhDc?feature=share&t=3467",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 3467,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1903,
    question: "Сходство и отличия observable от promise",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/N1gKaF6BhDc?t=3534",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 3534,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1904,
    question: "Отличия subject behaviorsubject replaysubject",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/N1gKaF6BhDc?t=3929",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 3929,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1905,
    question: "Какие операторы работы с потоками знаешь",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/N1gKaF6BhDc?t=4067",
        title: "Tech Interview Fest | Моковое cобесе…",
        time: 4067,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1906,
    question: "Почему функции массивов являются объектом",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/xGyI3uOXRjY?t=658",
        title: "Tech Interview Fest | Пробное собесе…",
        time: 658,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1907,
    question: "В качестве чего можно использовать функцию",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/xGyI3uOXRjY?t=721",
        title: "Tech Interview Fest | Пробное собесе…",
        time: 721,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1908,
    question: "Как узнать где начать, а где закончить при использовании for",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/xGyI3uOXRjY?t=887",
        title: "Tech Interview Fest | Пробное собесе…",
        time: 887,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1909,
    question: "Расскажи поподробнее об null и undefined",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/xGyI3uOXRjY?t=1181",
        title: "Tech Interview Fest | Пробное собесе…",
        time: 1181,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1910,
    question: "Можно ли применить bind на стрелочную функцию",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/xGyI3uOXRjY?t=1758",
        title: "Tech Interview Fest | Пробное собесе…",
        time: 1758,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1911,
    question: "Можно ли перезапустить остановленный promise",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/xGyI3uOXRjY?t=2304",
        title: "Tech Interview Fest | Пробное собесе…",
        time: 2304,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1912,
    question:
      "В каких случаях можно использовать локальное состояние, а в каких глобальный state",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/gV6eobXisYU?t=1539",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 1539,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1913,
    question: "Почему vue",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PgQ4Bn8g4Fg?t=365",
        title: "Публичное собеседование: Frontend-ра…",
        time: 365,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1914,
    question: "Что нравится во vue",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PgQ4Bn8g4Fg?t=437",
        title: "Публичное собеседование: Frontend-ра…",
        time: 437,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1915,
    question: "С чем используешь vue",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PgQ4Bn8g4Fg?t=597",
        title: "Публичное собеседование: Frontend-ра…",
        time: 597,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1916,
    question: "В чём разница между junior, middle и senior",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PgQ4Bn8g4Fg?t=653",
        title: "Публичное собеседование: Frontend-ра…",
        time: 653,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1917,
    question: "Если бы собеседовал middle, какой вопрос бы задал",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PgQ4Bn8g4Fg?t=759",
        title: "Публичное собеседование: Frontend-ра…",
        time: 759,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1918,
    question: "Какая самая важная отличительная черта promise",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PgQ4Bn8g4Fg?t=1711",
        title: "Публичное собеседование: Frontend-ра…",
        time: 1711,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1919,
    question: "Что делает второй аргумент resolve",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PgQ4Bn8g4Fg?t=1851",
        title: "Публичное собеседование: Frontend-ра…",
        time: 1851,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1920,
    question: "Что используете async await или send",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PgQ4Bn8g4Fg?t=1967",
        title: "Публичное собеседование: Frontend-ра…",
        time: 1967,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1921,
    question:
      "Что произойдёт если я использую await на то что не является promise",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PgQ4Bn8g4Fg?t=2021",
        title: "Публичное собеседование: Frontend-ра…",
        time: 2021,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1922,
    question: "Почему none в javascript это число",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PgQ4Bn8g4Fg?t=2108",
        title: "Публичное собеседование: Frontend-ра…",
        time: 2108,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1923,
    question: "Что чаще всего нарушают в accessibility по опыту",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PgQ4Bn8g4Fg?t=2230",
        title: "Публичное собеседование: Frontend-ра…",
        time: 2230,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1924,
    question: "Зачем был добавлен атрибут roll",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PgQ4Bn8g4Fg?t=2293",
        title: "Публичное собеседование: Frontend-ра…",
        time: 2293,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1925,
    question: "Расскажи своими словами что такое vuex",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PgQ4Bn8g4Fg?t=2448",
        title: "Публичное собеседование: Frontend-ра…",
        time: 2448,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1926,
    question: "Какую последнюю статью или книжку читал связанную с frontend",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PgQ4Bn8g4Fg?t=2662",
        title: "Публичное собеседование: Frontend-ра…",
        time: 2662,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1927,
    question:
      "Зачем frontend программисту знать алгоритмы и понимать оценку сложности алгоритмов",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PgQ4Bn8g4Fg?t=2755",
        title: "Публичное собеседование: Frontend-ра…",
        time: 2755,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1928,
    question: "Как дать оценку сложности бинарному коду",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PgQ4Bn8g4Fg?t=2798",
        title: "Публичное собеседование: Frontend-ра…",
        time: 2798,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1929,
    question:
      "Сколько понадобиться сравнений для того чтобы найти нужный элемент из 8",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PgQ4Bn8g4Fg?t=2947",
        title: "Публичное собеседование: Frontend-ра…",
        time: 2947,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1930,
    question: "Расскажи про последнюю интересную вещь которую узнал про css",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PgQ4Bn8g4Fg?t=3064",
        title: "Публичное собеседование: Frontend-ра…",
        time: 3064,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1931,
    question:
      "Расскажи как видится идеальный процесс работы в команде над задачей",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PgQ4Bn8g4Fg?t=3203",
        title: "Публичное собеседование: Frontend-ра…",
        time: 3203,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1932,
    question: "Зачем, для чего и как во vue нужны слоты",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PgQ4Bn8g4Fg?t=3376",
        title: "Публичное собеседование: Frontend-ра…",
        time: 3376,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1933,
    question:
      "Как организовывал изоляцию css в компонентах vue у себя на проектах",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PgQ4Bn8g4Fg?t=3455",
        title: "Публичное собеседование: Frontend-ра…",
        time: 3455,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1934,
    question: "Что будешь делать если проект на vue не работает в e11",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PgQ4Bn8g4Fg?t=3665",
        title: "Публичное собеседование: Frontend-ра…",
        time: 3665,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1935,
    question: "Сталкивался ли во vue, с таким понятием как потеря реактивности",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PgQ4Bn8g4Fg?t=3725",
        title: "Публичное собеседование: Frontend-ра…",
        time: 3725,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1936,
    question: "Какие варианты есть у позишн",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/qgdsHdkQYYQ?feature=share&t=1205",
        title: "Публичное собеседование: Middle фрон…",
        time: 1205,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1937,
    question: "Какие css - ные раскладки знаешь",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/qgdsHdkQYYQ?t=1121",
        title: "Публичное собеседование: Middle фрон…",
        time: 1121,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1938,
    question: "Любишь верстать",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/qgdsHdkQYYQ?t=355",
        title: "Публичное собеседование: Middle фрон…",
        time: 355,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1939,
    question: "Какая есть хорошая верстка",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/qgdsHdkQYYQ?t=391",
        title: "Публичное собеседование: Middle фрон…",
        time: 391,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1940,
    question: "Когда использовать флексы и греды",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/qgdsHdkQYYQ?t=1525",
        title: "Публичное собеседование: Middle фрон…",
        time: 1525,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1941,
    question: "При каких значениях свойство позишн работает за индекс",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/qgdsHdkQYYQ?t=1236",
        title: "Публичное собеседование: Middle фрон…",
        time: 1236,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1942,
    question: "Что будет с релетив, если сказать ему топ 5 пикселей",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/qgdsHdkQYYQ?t=1315",
        title: "Публичное собеседование: Middle фрон…",
        time: 1315,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1943,
    question: "Уживаются ли джеквери и реакт на одной странице",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/Jmpft3r3E2E?t=779",
        title: "Публичное собеседование: frontend-ра…",
        time: 779,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1944,
    question: "Расскажи какие библиотеки использовал для интересных ui решений",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/Jmpft3r3E2E?t=842",
        title: "Публичное собеседование: frontend-ра…",
        time: 842,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1945,
    question: "Много ли данных нужно обрабатывать в приложении",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/Jmpft3r3E2E?t=964",
        title: "Публичное собеседование: frontend-ра…",
        time: 964,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1946,
    question: "Что знаешь про оптимизацию",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/Jmpft3r3E2E?t=1732",
        title: "Публичное собеседование: frontend-ра…",
        time: 1732,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1947,
    question: "Какие есть правила для написания хуков",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/Jmpft3r3E2E?t=1528",
        title: "Публичное собеседование: frontend-ра…",
        time: 1528,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1948,
    question: "Расскажи как относишься к виртуал дом",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/Jmpft3r3E2E?feature=share&t=1623",
        title: "Публичное собеседование: frontend-ра…",
        time: 1623,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1949,
    question: "Расскажи про особое свойство реакт",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/Jmpft3r3E2E?feature=share&t=1935",
        title: "Публичное собеседование: frontend-ра…",
        time: 1935,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1950,
    question: "Как расставляешь ключи у списка",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/Jmpft3r3E2E?t=2102",
        title: "Публичное собеседование: frontend-ра…",
        time: 2102,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1951,
    question: "Почему выбрал библиотеку create react up",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/Jmpft3r3E2E?t=2266",
        title: "Публичное собеседование: frontend-ра…",
        time: 2266,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1952,
    question: "Что можешь рассказать об version",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/Jmpft3r3E2E?t=2599",
        title: "Публичное собеседование: frontend-ра…",
        time: 2599,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1953,
    question: "Расскажи как коммитишь код",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/Jmpft3r3E2E?t=3009",
        title: "Публичное собеседование: frontend-ра…",
        time: 3009,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1954,
    question: "Как следишь за код стаймом",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/Jmpft3r3E2E?t=3202",
        title: "Публичное собеседование: frontend-ра…",
        time: 3202,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1955,
    question: "Если не разработка, то что",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/Jmpft3r3E2E?t=3747",
        title: "Публичное собеседование: frontend-ра…",
        time: 3747,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1956,
    question: "Что не нравится в программировании",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/Jmpft3r3E2E?t=3774",
        title: "Публичное собеседование: frontend-ра…",
        time: 3774,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1957,
    question: "Назови 3 интересных человека в сфере it",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/Jmpft3r3E2E?t=3837",
        title: "Публичное собеседование: frontend-ра…",
        time: 3837,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1958,
    question: "Как оцениваешь трудность",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/Jmpft3r3E2E?t=4025",
        title: "Публичное собеседование: frontend-ра…",
        time: 4025,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1960,
    question: "Как взаимодействуют front-end и back-end",
    explanation:
      "Взаимодействие между front-end и back-end в веб-разработке играет ключевую роль в создании динамических веб-приложений. Front-end (клиентская сторона) отвечает за всё, что пользователи видят и с чем взаимодействуют в веб-браузере, включая структуру, дизайн и поведение веб-страницы. Back-end (серверная сторона) занимается обработкой данных, выполнением бизнес-логики, хранением информации и обеспечением безопасности.\nОсновные аспекты взаимодействия:\n1.\nHTTP Запросы:\nКлиент (браузер) отправляет HTTP запросы к серверу, который обрабатывает их и возвращает ответы. Это может быть запрос данных (GET), отправка данных форм (POST), обновление данных (PUT) и т.д.\n2.\nAPI (Application Programming Interface):\nБэкенд часто предоставляет API, который фронтенд может использовать для запроса данных или выполнения операций. API может быть RESTful, GraphQL или другого типа, и он определяет, каким образом фронтенд может общаться с бэкендом.\n3.\nФорматы данных:\nДанные обычно передаются между фронтендом и бэкендом в формате JSON или XML. Эти форматы легко читаемы как людьми, так и машинами, что делает их идеальными для обмена данными.\n4.\nАсинхронность:\nВзаимодействие с бэкендом часто асинхронно, что означает, что фронтенд может продолжать работать, пока ожидает ответа от сервера. Технологии, такие как AJAX, Fetch API и библиотеки, например, Axios, используются для асинхронных запросов.\n5.\nWebSockets:\nДля реализации двустороннего взаимодействия в реальном времени между клиентом и сервером можно использовать WebSockets. Это позволяет серверу отправлять данные клиенту без предварительного запроса, что идеально подходит для чатов, игр и приложений с коллаборативной работой.\n6.\nАутентификация и авторизация:\nБэкенд обрабатывает аутентификацию пользователя (подтверждение его идентичности) и авторизацию (предоставление доступа к определенным ресурсам и операциям). Токены безопасности, такие как JWT (JSON Web Tokens), часто используются для управления сессиями пользователя и контроля доступа.\n7.\nСессии и кеширование:\nДля улучшения производительности и пользовательского опыта бэкенд может использовать сессии и механизмы кеширования. Это позволяет сохранять состояние пользователя и ускорять загрузку часто запрашиваемых данных.\nЭффективное взаимодействие между фронтендом и бэкендом требует хорошо спроектированного API, четкого определения форматов данных и использования подходящих технологий для общения. Понимание этих аспектов жизненно важно для разработчиков, стремящихся создавать современные, масштабируемые и производительные веб-приложения.",
    videos: [
      {
        url: "https://youtu.be/-HfKMcP_yt4?t=528",
        title: "Публичное собеседование: frontend-ра…",
        time: 528,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1962,
    question: "Что такое репозиторий",
    explanation:
      "Репозиторий — это централизованное место хранения для управления кодом, документацией или другими данными, связанными с проектом. Репозитории используются для версионирования, совместной работы и хранения истории изменений в проекте. Они позволяют эффективно сотрудничать, отслеживать и откатывать изменения, а также управлять различными версиями проекта.\nОсновные характеристики репозиториев:\nВерсионирование:\nПоддержка истории изменений, позволяющая возвращаться к предыдущим версиям файлов и проекта в целом.\nСовместная работа:\nВозможность для множества разработчиков работать над одним проектом, предоставляя инструменты для слияния изменений и разрешения конфликтов.\nОтслеживание изменений:\nРегистрация кто, когда и какие изменения внёс в проект.\nРазделение на ветки:\nВозможность создания параллельных веток разработки для экспериментов, разработки новых функций или исправления ошибок, не затрагивая основной код проекта.\nТипы:\nЛокальные:\nХранятся на компьютере разработчика и позволяют управлять версиями проекта локально.\nУдалённые:\nРасполагаются на сервере или в облаке (например, на GitHub, GitLab, Bitbucket), обеспечивая доступ, совместную работу и резервное копирование проекта для команды разработчиков.\nПримеры систем управления версиями:\nGit:\nНаиболее популярная распределённая система управления версиями, позволяющая каждому разработчику иметь полную копию репозитория на своём компьютере.\nSubversion (SVN):\nЦентрализованная система управления версиями, где один центральный репозиторий содержит все файлы и историю их изменений.\nMercurial:\nРаспределённая система управления версиями, схожая с Git, но с упором на простоту и удобство использования.\nРепозитории играют ключевую роль в разработке ПО, облегчая управление кодом и сотрудничество в командах, а также повышая надёжность и безопасность проекта за счёт сохранения его истории и возможности восстановления после сбоев или ошибок.",
    videos: [
      {
        url: "https://youtu.be/-HfKMcP_yt4?t=775",
        title: "Публичное собеседование: frontend-ра…",
        time: 775,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1964,
    question: "Каким образом html превращается в страницу",
    explanation:
      'Процесс преобразования HTML-кода в визуальную веб-страницу, которую вы видите в браузере, включает в себя несколько ключевых этапов. Вот основные шаги этого процесса:\n1.\nЗагрузка HTML\nЗапрос к серверу:\nВсё начинается с того, что ваш браузер отправляет запрос на веб-сервер для получения HTML-файла. Это происходит после ввода URL-адреса в адресную строку или при переходе по ссылке.\nПолучение HTML:\nВеб-сервер отвечает на запрос, отправляя HTML-файл обратно браузеру.\n2.\nПарсинг HTML\nПостроение DOM:\nБраузер анализирует HTML-код и строит из него Document Object Model (DOM) — иерархическое дерево, в котором каждый тег становится узлом дерева. DOM представляет структуру документа и позволяет языкам программирования (например, JavaScript) взаимодействовать с содержимым и структурой веб-страницы.\n3.\nЗагрузка и парсинг CSS\nЗагрузка CSS:\nВ то время как DOM строится, браузер также анализирует HTML на наличие ссылок на CSS-файлы и загружает их.\nПостроение CSSOM:\nПодобно DOM, браузер строит CSS Object Model (CSSOM) для каждого CSS-файла. CSSOM содержит стилизацию элементов и используется вместе с DOM для построения визуального представления страницы.\n4.\nРендеринг страницы\nСоздание Render Tree:\nИспользуя DOM и CSSOM, браузер создаёт Render Tree — дерево, которое содержит только те узлы DOM, которые должны быть отображены, и применяет к ним соответствующие CSS-стили.\nРасчёт макета (Layout):\nБраузер вычисляет местоположение и размер каждого узла в Render Tree на странице. Этот процесс также известен как "reflow".\nОтрисовка (Painting):\nПосле расчёта макета браузер переходит к отрисовке — процессу, в ходе которого каждый узел Render Tree превращается в фактические пиксели на экране пользователя.\n5.\nИнтерактивность\nJavaScript:\nПараллельно с загрузкой HTML и CSS браузер загружает и выполняет JavaScript-код, который может динамически изменять DOM и CSSOM, повлиять на Render Tree и вызвать перерасчёт макета и перерисовку.\nДинамическое изменение:\nJS позволяет изменять содержимое страницы, добавлять или удалять элементы, менять стили и отвечать на действия пользователя, делая страницу интерактивной.\nЭтот процесс делает возможным превращение статичного HTML-кода в динамические, интерактивные веб-страницы, которые мы видим в браузере.',
    videos: [
      {
        url: "https://youtu.be/-HfKMcP_yt4?t=935",
        title: "Публичное собеседование: frontend-ра…",
        time: 935,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1966,
    question: "Почему реакт",
    explanation:
      "React (также известный как React.js или ReactJS) — это популярная библиотека для разработки пользовательских интерфейсов, особенно одностраничных приложений (SPA). Он быстро завоевал популярность по множеству причин:\n1.\nДекларативный подход\nПозволяет описывать, какие интерфейсы должны быть созданы для каждого состояния в приложении, делая код более предсказуемым и легким для отладки. Декларативное создание UI облегчает разработку и поддержку приложений.\n2.\nКомпонентный подход\nИспользует компонентный подход к разработке UI, позволяя строить сложные пользовательские интерфейсы из мелких, изолированных и переиспользуемых компонентов. Это не только упрощает управление каждым компонентом и его разработку, но и способствует повторному использованию кода.\n3.\nВиртуальный DOM\nИспользует концепцию виртуального DOM для минимизации операций с реальным DOM, что значительно повышает производительность приложения. Изменения в пользовательском интерфейсе сначала применяются к виртуальному DOM, а затем, с помощью эффективного алгоритма сравнения, минимально необходимые изменения отражаются в реальном DOM.\n4.\nОднонаправленный поток данных\nВ нем поток данных однонаправленный. Это значит, что информация передаётся от родительских компонентов к дочерним через пропсы, что делает поведение компонентов более предсказуемым и упрощает отладку приложений.\n5.\nЭкосистема и сообщество\nИмеет огромное активное сообщество разработчиков и богатую экосистему. Существует множество готовых решений, библиотек и инструментов, которые упрощают разработку и расширение функциональности приложений на React.\n6.\nГибкость и интеграция\nМожет использоваться в различных частях приложения, не ограничиваясь одностраничными приложениями. Его можно интегрировать в существующие проекты или использовать вместе с другими библиотеками и фреймворками.\n7.\nПоддержка корпораций\nАктивно поддерживается и развивается Facebook, что обеспечивает его постоянное обновление и оптимизацию.\nВыбор React для разработки проекта часто обусловлен его производительностью, гибкостью и мощной поддержкой сообщества. Эти факторы делают React отличным выбором для разработки современных веб-приложений.",
    videos: [
      {
        url: "https://youtu.be/-HfKMcP_yt4?t=1555",
        title: "Публичное собеседование: frontend-ра…",
        time: 1555,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1968,
    question: "Что делает веб пак",
    explanation:
      "Webpack — это современный инструмент сборки модулей и пакетов, который помогает организовывать и упаковывать ресурсы (JavaScript, CSS, изображения и так далее) для браузера. Он предоставляет мощные возможности для оптимизации фронтенд проектов, включая, но не ограничиваясь:\n1.\nМодульность и управление зависимостями\nАнализирует ваш проект, находит JavaScript модули и другие ресурсы, такие как CSS и изображения, которые импортируются или требуются вашим кодом, и создаёт один или несколько пакетов (бандлов), которые могут быть эффективно загружены в браузере.\n2.\nТранспиляция и преобразования\nС помощью загрузчиков (loaders) он может транспилировать и преобразовывать ресурсы из одного формата в другой. Например, он может использовать Babel для преобразования современного JavaScript (ES6, ESNext) в код, совместимый с более старыми браузерами, или преобразовывать SASS/LESS в CSS.\n3.\nПлагины\nИмеет широкий спектр плагинов, расширяющих его функциональность. С помощью плагинов можно оптимизировать пакеты, минифицировать CSS и JavaScript, оптимизировать изображения, генерировать HTML файлы, которые автоматически включают ссылки на сгенерированные пакеты, и многое другое.\n4.\nHot Module Replacement (HMR)\nПоддерживает HMR, который позволяет заменять, добавлять или удалять модули во время выполнения приложения без полной перезагрузки страницы. Это значительно ускоряет разработку и помогает сохранять состояние приложения между обновлениями.\n5.\nРазделение кода\nПозволяет разделять код на несколько пакетов, которые могут быть загружены по требованию или параллельно. Это улучшает время загрузки приложения, так как пользователю сначала загружается только минимально необходимый код.\n6.\nОптимизация для продакшена\nПри сборке проекта для продакшена, он может минифицировать код, оптимизировать изображения и выполнять другие задачи по улучшению производительности и уменьшению размера пакетов.\nWebpack — это мощный и гибкий инструмент, который стал стандартом в современной веб-разработке. Он облегчает многие аспекты разработки и сборки проектов, делая процесс более эффективным и позволяя разработчикам сосредоточиться на написании кода, а не на его подготовке к продакшену.",
    videos: [
      {
        url: "https://www.youtube.com/live/-HfKMcP_yt4?feature=share&t=1803",
        title: "Публичное собеседование: frontend-ра…",
        time: 1803,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1970,
    question: "В чем отличие между серверным ренгом и спа",
    explanation:
      "Серверный рендеринг (Server-Side Rendering, SSR) и одностраничные приложения (Single Page Applications, SPA) представляют собой два различных подхода к разработке веб-приложений. Каждый из них имеет свои преимущества и недостатки, и выбор между ними зависит от требований проекта, целевой аудитории и других факторов.\nСерверный рендеринг (SSR)\nПри нем HTML-страницы генерируются на сервере и отправляются в браузер пользователя в уже готовом виде. Это означает, что сервер обрабатывает запрос, выполняет необходимую логику (например, запросы к базе данных), генерирует соответствующий HTML и отправляет его клиенту.\nПреимущества:\nБыстрая первоначальная загрузка:\nПользователь получает полностью сформированную страницу, что ускоряет отображение контента.\nЛучшая индексация поисковыми системами:\nПоскольку контент страницы уже сформирован при первом запросе, поисковые системы легче индексируют такие страницы.\nУлучшенный пользовательский опыт:\nБыстрая отрисовка страницы способствует повышению удовлетворенности пользователей.\nНедостатки:\nНагрузка на сервер:\nКаждый запрос требует генерации новой страницы, что может увеличить нагрузку на сервер.\nЗамедление динамических интеракций:\nДля изменения контента или динамического взаимодействия страница должна обновляться, что может замедлить работу приложения.\nОдностраничные приложения (SPA)\nЗагружаются в браузере пользователя один раз, после чего все дальнейшие взаимодействия с приложением происходят через JS без перезагрузки страницы. При переходе между разделами приложения новый HTML не загружается; вместо этого JS динамически изменяет текущий контент.\nПреимущества:\nПлавность и скорость работы:\nПосле первоначальной загрузки приложения переходы между его разделами происходят практически мгновенно.\nУменьшение нагрузки на сервер:\nСервер отправляет необходимые данные, а не целые страницы, что может снизить его нагрузку.\nУлучшенный пользовательский опыт:\nSPA может предложить более близкий к настольным приложениям опыт использования веб-приложений.\nНедостатки:\nСложности с SEO:\nДинамическое содержимое SPA может затруднить индексацию поисковыми системами, хотя современные технологии и подходы (например, Server-Side Rendering для SPA) позволяют решать эту проблему.\nЗависимость от JavaScript:\nЕсли по каким-либо причинам JavaScript отключен в браузере пользователя, SPA не сможет корректно функционировать.\nВыбор между SSR и SPA зависит от целей проекта, ожидаемой нагрузки, требований к SEO и предпочтений в плане пользовательского опыта. Очень часто комбинируют эти подходы, используя преимущества каждого из них для создания быстрых, удобных и хорошо индексируемых приложений.",
    videos: [
      {
        url: "https://www.youtube.com/live/-HfKMcP_yt4?feature=share&t=2119",
        title: "Публичное собеседование: frontend-ра…",
        time: 2119,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1972,
    question: "Что будет если передать функцию по ссылке",
    explanation:
      "Передача функции по ссылке позволяет использовать эту функцию в другом месте кода, не вызывая её непосредственно в момент передачи. Это означает, что вы передаёте не результат выполнения функции, а саму функцию как объект, который можно вызвать позже. Этот подход широко используется для реализации колбэков (функций обратного вызова), обработчиков событий, а также в паттернах проектирования, таких как стратегия.\nJavaScript\nФункции являются объектами первого класса, что позволяет передавать их как аргументы в другие функции, возвращать из функций и присваивать переменным.\nfunction greet(name) {\n  console.log(`Привет, ${name}!`);\n}\n// Передача функции по ссылке\nfunction processUserInput(callback) {\n  const name = \"Алиса\";\n  callback(name);\n}\n// Вызов функции с передачей другой функции в качестве аргумента\nprocessUserInput(greet);\nВ этом примере\n`greet`\nпередаётся по ссылке в функцию\n`processUserInput`\nи вызывается внутри неё с аргументом\n`name`\n.\nDart/FlutterФункции можно передавать по ссылке, что делает язык гибким для разработки сложных приложений.\nvoid greet(String name) {\n  print('Привет, $name!');\n}\nvoid processUserInput(Function callback) {\n  String name = 'Алиса';\n  callback(name);\n}\nvoid main() {\n  processUserInput(greet);\n}\nЧто происходит при передаче функции по ссылке\nПереиспользование логики:\nФункция может быть определена в одном месте и переиспользована в разных частях приложения без необходимости дублирования кода.\nОтложенный вызов:\nФункция может быть вызвана в нужный момент времени, не сразу при передаче.\nГибкость:\nМожно легко изменять поведение программы, передавая разные функции в зависимости от условий выполнения или конфигурации.\nОбратные вызовы и асинхронность:\nОсобенно актуально для асинхронного кода, где результат операции нужно обработать позже, когда он станет доступен.\nПередача функции по ссылке — мощный инструмент, обеспечивающий высокую степень абстракции и гибкости при разработке ПО.",
    videos: [
      {
        url: "https://youtu.be/-HfKMcP_yt4?t=3856",
        title: "Публичное собеседование: frontend-ра…",
        time: 3856,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1974,
    question: "Откуда взялся css",
    explanation:
      "CSS (Cascading Style Sheets, каскадные таблицы стилей) был разработан для улучшения веб-дизайна и обеспечения большей гибкости в оформлении веб-страниц. Данная идея впервые была предложена Хоконом Виумом Ли (Håkon Wium Lie) 10 октября 1994 года. В то время Хокон работал в CERN (Европейском центре ядерных исследований) вместе с Тимом Бернерсом-Ли, известным как изобретатель Всемирной паутины (WWW).\nПервоначальная мотивация его создания заключалась в необходимости разделить содержание документа (HTML) от его представления (стили оформления). До его появления оформление веб-страниц ограничивалось использованием HTML-тегов, таких как `<font>` для изменения шрифта, цвета текста и размера, что приводило к смешению содержания с оформлением и затрудняло поддержку и изменение внешнего вида веб-страниц.\nПредложил способ, с помощью которого разработчики могли централизованно управлять внешним видом веб-страниц, задавая стили для HTML-элементов в отдельных файлах\n`.css`\n. Это позволило сделать веб-дизайн более структурированным и гибким, а также упростить обновление и поддержку веб-сайтов.\nПервая версия, CSS1, была опубликована W3C (Всемирной организацией по стандартизации веба) в декабре 1996 года. Этот стандарт включал основные возможности по стилизации текста, фона, маржинов и паддингов. Позже были разработаны CSS2 и CSS3, вводящие новые возможности, такие как медиа-запросы для адаптивного дизайна, анимации, градиенты и многое другое, что значительно расширило инструментарий веб-дизайнеров и разработчиков.\nС тех пор CSS продолжает развиваться, добавляя новые свойства, селекторы и функции, которые делают веб-дизайн ещё более мощным и выразительным.",
    videos: [
      {
        url: "https://youtu.be/-HfKMcP_yt4?t=463",
        title: "Публичное собеседование: frontend-ра…",
        time: 463,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1976,
    question: "С какими инструментами работал",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/Awnog8KYub4?feature=share&t=336",
        title: "Публичное собеседование: Ведущий fro…",
        time: 336,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1978,
    question: "Чем нравится redux",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/Awnog8KYub4?feature=share&t=403",
        title: "Публичное собеседование: Ведущий fro…",
        time: 403,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1980,
    question: "Какие преимущества redux",
    explanation:
      "Redux — это библиотека для управления состоянием приложения, особенно популярная в связке с React, но также может использоваться с другими фреймворками и библиотеками. Она предлагает ряд преимуществ, делающих её полезной для разработки сложных веб-приложений:\n1.\nПредсказуемость состояния\nИспользует строгий однонаправленный поток данных, что делает поведение приложения более предсказуемым. Каждое изменение состояния происходит через диспетчеризацию действий и обработку редьюсерами, что обеспечивает прозрачность и контроль над всеми изменениями состояния.\n2.\nЦентрализованное управление состоянием\nВсё состояние приложения хранится в одном месте (store), что облегчает отслеживание изменений, отладку и сохранение состояния приложения. Это также упрощает реализацию таких функций, как отмена/повтор действий или инициализация состояния из сохранённого состояния.\n3.\nУлучшенная отладка\nС ним можно получить мощные инструменты для отладки приложений: просмотр состояния store в реальном времени, пошаговое выполнение действий, путешествие во времени по истории изменений состояния и даже импорт/экспорт состояния приложения.\n4.\nУпрощение тестирования\nБлагодаря чистым функциям редьюсерам и изолированному хранению состояния, тестирование логики приложения становится проще. Это чистые функции, которые можно тестировать независимо от остальной части приложения.\n5.\nСохранение и восстановление состояния\nПозволяет легко сохранять состояние приложения и восстанавливать его позже, что может быть полезно для функций отладки, сохранения сессий пользователей или выполнения тестов.\n6.\nЭкосистема и сообщество\nВокруг него сформировалась обширная экосистема с множеством готовых решений, расширений и полезных библиотек, которые могут существенно ускорить разработку. Большое и активное сообщество означает также большое количество обучающих материалов, примеров и готовых к использованию паттернов разработки.\n7.\nСовместимость с различными фреймворками\nХотя он чаще всего ассоциируется с React, он может использоваться с любым другим JavaScript-фреймворком или библиотекой, такими как Angular, Vue и даже с чистым JavaScript.\nRedux предлагает сильную архитектуру для управления состоянием приложения, что особенно полезно для крупных и сложных проектов. Однако его использование может быть избыточным для маленьких проектов или проектов, где требования к управлению состоянием не так высоки. В таких случаях разработчики могут рассмотреть более простые альтернативы или использовать контекст и хуки в React для управления состоянием.",
    videos: [
      {
        url: "https://www.youtube.com/live/Awnog8KYub4?feature=share&t=996",
        title: "Публичное собеседование: Ведущий fro…",
        time: 996,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1982,
    question: "Что нужно сделать, чтобы поменять данные в хранилище redux",
    explanation:
      "Чтобы изменить данные в хранилище (store) Redux, необходимо выполнить следующие шаги:\n1.\nОпределить Действие (Action)\nДействие (action) — это обычный объект, который описывает, что именно должно произойти. Каждое действие должно иметь поле\n`type`\n, которое указывает тип выполняемого действия. Поле\n`type`\n— это строка, которая действует как уникальный идентификатор действия. Действие может также содержать другие данные, необходимые для обновления состояния.\nconst addAction = {\n  type: 'ADD_ITEM',\n  payload: 'Learn Redux'\n};\n2.\nСоздать Редьюсер (Reducer)\nЭто чистая функция, которая принимает предыдущее состояние хранилища и действие, а затем возвращает новое состояние. Он определяет, как именно изменяется состояние в ответ на различные действия.\nfunction listReducer(state = [], action) {\n  switch (action.type) {\n    case 'ADD_ITEM':\n      return [...state, action.payload];\n    default:\n      return state;\n  }\n}\n3.\nРегистрация Редьюсера в Хранилище\nПри создании хранилища с помощью функции\n`createStore`\n, вы должны указать редьюсер, который будет управлять обновлением состояния хранилища.\nimport { createStore } from 'redux';\nconst store = createStore(listReducer);\n4.\nОтправка Действия\nЧтобы инициировать изменение состояния, необходимо \"отправить\" (dispatch) действие в хранилище с помощью метода\n`dispatch()`\n.\nstore.dispatch(addAction);\nПосле отправки действия, он вызовет редьюсер, передав ему текущее состояние хранилища и отправленное действие. Редьюсер должен определить, как действие влияет на состояние, и вернуть новое состояние. Хранилище затем обновит своё состояние на основе возвращенного редьюсером нового состояния.\nИзменение данных в хранилище Redux требует создания действия, определения редьюсера, который знает, как обрабатывать это действие, и отправки действия в хранилище. Этот процесс обеспечивает предсказуемое и управляемое обновление состояния в приложении.",
    videos: [
      {
        url: "https://www.youtube.com/live/Awnog8KYub4?feature=share&t=1159",
        title: "Публичное собеседование: Ведущий fro…",
        time: 1159,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1984,
    question: "Как развернуть строку в js",
    explanation:
      'Разворот строки можно выполнить несколькими способами. Вот несколько примеров:\n1.\nИспользование методов массивов\nОдин из самых распространенных способов — преобразовать строку в массив с помощью метода\n`split(\'\')`\n, затем развернуть массив методом\n`reverse()`\n, и снова преобразовать массив в строку с помощью метода\n`join(\'\')`\n.\nfunction reverseString(str) {\n  return str.split(\'\').reverse().join(\'\');\n}\nconsole.log(reverseString("hello")); // "olleh"\n2.\nЦикл for\nМожно также использовать его, чтобы пройти по строке с конца к началу и собрать символы в новую строку.\nfunction reverseString(str) {\n  let reversed = "";\n  for (let i = str.length - 1; i >= 0; i--) {\n    reversed += str[i];\n  }\n  return reversed;\n}\nconsole.log(reverseString("world")); // "dlrow"\n3.\nРекурсия\nМожет быть использован для разворота строки, хотя это не самый эффективный способ с точки зрения производительности и использования памяти, особенно для длинных строк.\nfunction reverseString(str) {\n  if (str === "") {\n    return "";\n  } else {\n    return reverseString(str.substr(1)) + str[0];\n  }\n}\nconsole.log(reverseString("recursion")); // "noisrucer"\n4.\nРасширение строки через for...of и шаблонные строки\nС ECMAScript 6 (ES6) можно использовать цикл\n`for...of`\nдля итерации по строке и шаблонные строки для конкатенации символов.\nfunction reverseString(str) {\n  let reversed = "";\n  for (let char of str) {\n    reversed = char + reversed;\n  }\n  return reversed;\n}\nconsole.log(reverseString("es6")); // "6se"\n5.\nИспользование метода `Array.prototype.reduce()`\nМетод\n`reduce()`\nтакже может быть использован для создания развернутой строки, применяя аналогичный подход преобразования строки в массив.\nfunction reverseString(str) {\n  return str.split(\'\').reduce((reversed, character) => character + reversed, \'\');\n}\nconsole.log(reverseString("reduce")); // "ecuder"\nКаждый из этих методов имеет свои преимущества и может быть выбран в зависимости от конкретной задачи, стиля кодирования и требований к производительности.',
    videos: [
      {
        url: "https://www.youtube.com/live/t52BuzKzqWw?feature=share&t=257",
        title: "Публичное собеседование: junior-fron…",
        time: 257,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1986,
    question: "Что сделать, чтобы settimeout выполнился позже",
    explanation:
      'Чтобы функция, вызываемая с помощью\n`setTimeout`\n, выполнилась позже, нужно увеличить задержку (время ожидания в миллисекундах), указанное во втором аргументе этой функции. Функция\n`setTimeout`\nпозволяет запланировать выполнение кода один раз после истечения заданного интервала времени.\nВот базовый пример использования\n`setTimeout`\n:\nsetTimeout(function() {\n  console.log("Это сообщение появится позже");\n}, 1000); // Задержка в 1000 мс (1 секунда)\nЕсли вы хотите, чтобы код выполнился позже, чем в примере выше, просто увеличьте значение задержки. Например, чтобы код выполнился через 5 секунд (5000 мс), измените вызов следующим образом:\nsetTimeout(function() {\n  console.log("Это сообщение появится через 5 секунд");\n}, 5000); // Задержка в 5000 мс (5 секунд)\nДополнительные советы и моменты для учета:\nМинимальная задержка: В современных браузерах существует минимальная задержка, которая может быть применена к\n`setTimeout`\n, даже если вы укажете меньшее значение. Так, например, задержка менее 4 мс будет увеличена до 4 мс.\nФоновые вкладки и неактивные окна: Современные браузеры могут регулировать таймеры для фоновых вкладок и неактивных окон для улучшения производительности и эффективности использования энергии. Это может повлиять на время выполнения\n`setTimeout`\nв таких условиях.\nРекурсивный\n`setTimeout`\n: Если вам нужно регулярно выполнять код с определенными интервалами, рассмотрите возможность использования рекурсивного\n`setTimeout`\nвместо\n`setInterval`\n, особенно если время выполнения кода может варьироваться. Это позволит установить новый таймер после завершения предыдущего вызова, обеспечивая более точное соблюдение интервалов.\nОтмена выполнения: Если вы передумали и хотите отменить запланированное выполнение, вы можете использовать возвращаемое значение\n`setTimeout`\nс функцией\n`clearTimeout`\n:\nconst timeoutId = setTimeout(() => {\n  console.log("Этот код не будет выполнен");\n}, 5000);\n// Отмена выполнения\nclearTimeout(timeoutId);\nИзменение времени ожидания в\n`setTimeout`\n— это простой и эффективный способ контролировать, когда ваш код должен быть выполнен.',
    videos: [
      {
        url: "https://www.youtube.com/live/t52BuzKzqWw?feature=share&t=487",
        title: "Публичное собеседование: junior-fron…",
        time: 487,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1988,
    question: "Как обратиться к методу в цепочке",
    explanation:
      'Цепочка прототипов — это механизм, благодаря которому объекты могут наследовать свойства и методы от других объектов. Каждый объект имеет свойство\n`__proto__`\n, которое ссылается на прототип объекта-родителя. Когда вы пытаетесь получить доступ к свойству или методу объекта, интерпретатор сначала ищет это свойство в самом объекте. Если свойство не найдено, поиск продолжается в прототипе объекта (\n`__proto__`\n), затем в прототипе прототипа и так далее вверх по цепочке прототипов, пока не будет достигнут конец цепочки (\n`null`\n) или пока не будет найдено соответствующее свойство или метод.\nОбращение к методу в цепочке прототипов\nНужно вызвать этот метод у объекта, как если бы метод был определен непосредственно в самом объекте. JS автоматически пройдет по цепочке прототипов в поисках этого метода.\nfunction Animal(name) {\n  this.name = name;\n}\nAnimal.prototype.sayName = function() {\n  console.log(this.name);\n};\nfunction Dog(name) {\n  Animal.call(this, name);\n}\n// Устанавливаем Dog.prototype на объект, созданный из Animal.prototype\nDog.prototype = Object.create(Animal.prototype);\n// Устанавливаем конструктор Dog.prototype обратно на Dog\nDog.prototype.constructor = Dog;\nconst myDog = new Dog("Rex");\n// Обращаемся к методу sayName, который найден в цепочке прототипов\nmyDog.sayName(); // Выведет "Rex"\nВ этом примере метод\n`sayName`\nопределен в\n`Animal.prototype`\n. Поскольку\n`Dog.prototype`\nбыл установлен на объект, созданный из\n`Animal.prototype`\n, все экземпляры\n`Dog`\nнаследуют методы, определенные в\n`Animal.prototype`\n, включая\n`sayName`\n. При вызове\n`myDog.sayName()`\n, метод успешно вызывается, несмотря на то, что он не был определен в\n`Dog.prototype`\nили непосредственно в объекте\n`myDog`\n.\nВажные моменты\nЦепочка прототипов\nподдерживает принцип наследования, позволяя объектам наследовать функциональность от других объектов.\nПроизводительность:\nЧрезмерное использование цепочки прототипов может повлиять на производительность, так как поиск свойств в глубокой цепочке прототипов требует больше времени.\n`__proto__` vs `Object.getPrototypeOf`:\nСвойство\n`__proto__`\nявляется устаревшим, и рекомендуется использовать метод\n`Object.getPrototypeOf()`\nдля получения прототипа объекта.\nЦепочка прототипов является фундаментальной концепцией, обеспечивающей механизм наследования и делающей структуру объектов в языке гибкой и мощной.',
    videos: [
      {
        url: "https://www.youtube.com/live/t52BuzKzqWw?feature=share&t=641",
        title: "Публичное собеседование: junior-fron…",
        time: 641,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1990,
    question: "От чего зависит this",
    explanation:
      "`this`\nзависит от того, как и где вызывается функция. Вот основные правила, определяющие, чему он равен в различных ситуациях:\n1.\nГлобальный контекст\nВне любой функции он ссылается на глобальный объект. В браузере глобальным объектом является\n`window`\n, а в Node.js —\n`global`\n.\nconsole.log(this === window); // true в браузере\n2.\nФункции, вызванные в глобальном контексте\nКогда функция вызывается не как метод объекта, он ссылается на глобальный объект (в строгом режиме\n`this`\nбудет\n`undefined`\n, чтобы предотвратить несанкционированный доступ к глобальному объекту).\nfunction myFunction() {\n  console.log(this === window); // true в браузере в нестрогом режиме\n}\nmyFunction();\n3.\nМетоды объектов\nКогда функция вызывается как метод объекта, он ссылается на объект, для которого вызывается метод.\nconst myObject = {\n  myMethod: function() {\n    console.log(this === myObject); // true\n  }\n};\nmyObject.myMethod();\n4.\nКонструкторы\nВнутри конструктора он ссылается на новосозданный объект.\nfunction MyConstructor() {\n  // this ссылается на новосозданный объект\n  this.myProperty = 'value';\n}\nconst myInstance = new MyConstructor();\nconsole.log(myInstance.myProperty); // \"value\"\n5.\nЯвная привязка\nС помощью методов\n`call`\n,\n`apply`\nи\n`bind`\nможно явно указать, что должно быть\n`this`\nпри вызове функции.\nfunction sayName() {\n  console.log(this.name);\n}\nconst person = { name: 'Alice' };\nsayName.call(person); // \"Alice\"\n6.\nСтрелочные функции\nНе создают собственный контекст\n`this`\n, а \"заимствуют\" его из внешней области видимости, где были определены.\nconst myObject = {\n  myMethod: () => {\n    console.log(this === window); // true в браузере, потому что стрелочная функция наследует this из глобального контекста\n  }\n};\nmyObject.myMethod();\n7.\nОбработчики событий\nВ обработчиках событий DOM он обычно ссылается на элемент, для которого обработчик был вызван.\ndocument.getElementById('myButton').addEventListener('click', function() {\n  console.log(this === document.getElementById('myButton')); // true\n});\nПонимание того, как работает\n`this`\n, критически важно для правильной организации кода и избежания ошибок в поведении программы.",
    videos: [
      {
        url: "https://www.youtube.com/live/t52BuzKzqWw?feature=share&t=802",
        title: "Публичное собеседование: junior-fron…",
        time: 802,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1992,
    question: "Как оцениваешь качество своего кода",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/t52BuzKzqWw?feature=share&t=2244",
        title: "Публичное собеседование: junior-fron…",
        time: 2244,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1994,
    question: "Что такое z-index",
    explanation:
      "`z-index`\n— это свойство, которое определяет порядок наложения элементов на веб-странице по оси Z (перпендикулярно экрану пользователя). Элементы с таким более высоким  значением будут располагаться поверх элементов с более низким значением этого свойства, что позволяет управлять тем, как элементы перекрывают друг друга на странице.\nКлючевые аспекты:\nТолько для позиционированных элементов:\nРаботает только для элементов, у которых свойство\n`position`\nустановлено как\n`relative`\n,\n`absolute`\n,\n`fixed`\n, или\n`sticky`\n. Для элементов с\n`position: static`\n(значение по умолчанию)\n`z-index`\nне применяется.\nЦелочисленные значения:\n`z-index`\nможет принимать целые числа (включая отрицательные), где элементы с более высоким значением будут находиться выше элементов с более низким значением.\nСоздание контекста наложения:\nКаждый элемент с установленным\n`z-index`\nсоздаёт новый контекст наложения для своих дочерних элементов. Это означает, что индекс дочерних элементов будет работать относительно их ближайшего родителя с позиционированием, а не всей страницы в целом.\nАвто:\nЗначение по умолчанию для него —\n`auto`\n. Это означает, что элемент наследует порядок наложения своего родителя и не создаёт новый контекст наложения.Пример:\n.background {\n  position: absolute;\n  z-index: 1; /* Задний фон */\n}\n.foreground {\n  position: absolute;\n  z-index: 2; /* Передний план */\n}\nВ этом примере элемент с классом\n`.foreground`\nбудет отображаться поверх элемента с классом\n`.background\n` из-за более высокого значения `z-index`.\nВажно помнить:\nЭлементы с более высоким\n`z-index`\nиногда могут блокировать доступ к элементам с более низким\n`z-index`\n, например, при попытке взаимодействия с формой или кнопками.\nБезумное использование высоких значений\n`z-index`\n(например,\n`z-index: 99999`\n) может привести к сложностям с поддержкой и отладкой кода. Лучше использовать умеренные значения и хорошо продуманную структуру наложения.\nПорядок элементов в HTML также влияет на их наложение. По умолчанию, элементы, которые идут позже в коде, будут располагаться поверх элементов, расположенных ранее, если их `z-index` не изменён.",
    videos: [
      {
        url: "https://www.youtube.com/live/t52BuzKzqWw?feature=share&t=2878",
        title: "Публичное собеседование: junior-fron…",
        time: 2878,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1996,
    question: "Что такое inline blok в отличии от inline элемента",
    explanation:
      "Есть несколько значений для свойства\n`display`\n, которые определяют, как элемент будет отображаться на странице. Два из этих значений —\n`inline`\nи\n`inline-block`\n— имеют некоторые сходства, но и значительные отличия.\nInline элементы\nЭлементы с\n`display: inline;`\nведут себя как часть текста. Это значит, что:\nОни располагаются на одной строке с другими инлайн-элементами или текстом, если только ширина родительского элемента не заставляет их обтекать.\nУ инлайн-элементов нельзя задать ширину (\n`width`\n) и высоту (\n`height`\n), так как размеры определяются содержимым.\nВертикальные отступы (\n`margin-top`\nи\n`margin-bottom`\n) и вертикальные внутренние отступы (\n`padding-top`\nи\n`padding-bottom`\n) не влияют на расстояние между инлайн-элементами вертикально, хотя могут влиять на фоновое изображение или цвет.\nГоризонтальные отступы и внутренние отступы применяются нормально.\nПримеры инлайн-элементов:\n`<span>`\n,\n`<a>`\n,\n`<img>`\n.\nInline-block элементы\nЭлементы с `display: inline-block;` комбинируют некоторые свойства инлайн и блочных элементов:\nКак и инлайн элементы, эти элементы располагаются на одной строке с другими инлайн-элементами или текстом.\nВ то же время, у них можно задать ширину и высоту, как у блочных элементов.\nВертикальные и горизонтальные отступы (\n`margin`\nи\n`padding`)\nработают как у блочных элементов, влияя на расстояние вокруг элемента во всех направлениях.\nЭлементы могут содержать другие блочные или инлайн элементы.\nЭто делает его очень удобным для создания компонентов пользовательского интерфейса, которые должны располагаться в одной строке (например, кнопок), но при этом требуют точного контроля над размерами и отступами.\nОсновное отличие между\n`inline`\nи\n`inline-block`\nэлементами заключается в том, что\n`inline-block`\nсочетает в себе способность располагаться в строке с другими элементами, как у `inline` элементов, и при этом позволяет контролировать размеры и отступы, как у блочных элементов. Это делает\n`inline-block`\nмощным инструментом для создания сложных компонентов интерфейса, которые требуют одновременно и горизонтального выравнивания, и точного контроля над макетом.",
    videos: [
      {
        url: "https://www.youtube.com/live/t52BuzKzqWw?feature=share&t=3166",
        title: "Публичное собеседование: junior-fron…",
        time: 3166,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 1998,
    question: "Что будешь делать, чтобы претендовать на эту зп",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/MdRE18dGmNU?feature=share&t=6617",
        title: "Публичное собеседование: Junior Fron…",
        time: 6617,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2000,
    question: "Зачем изучение функционального языка",
    explanation:
      'Изучение функционального языка предлагает уникальную перспективу и набор преимуществ, дополняющих понимание и навыки, полученные от императивного и объектно-ориентированного программирования. Вот несколько ключевых причин, по которым стоит изучать функциональное программирование:\n1.\nЧистота функций и побочные эффекты\nАкцентирует внимание на использовании чистых функций, которые возвращают одинаковый результат для одинаковых входных данных и не имеют побочных эффектов (т.е., не изменяют состояние вне своей области видимости). Это делает код более предсказуемым, упрощает отладку и тестирование.\n2.\nНеизменяемость данных\nДанные часто рассматриваются как неизменяемые. Это означает, что вместо изменения существующих данных создаются новые версии этих данных с применёнными изменениями. Такой подход упрощает разработку многопоточных приложений и помогает избежать ошибок, связанных с изменяемым состоянием.\n3.\nПервоклассные и высшие функции\nОбрабатывают функции как "граждан первого класса", позволяя использовать их в качестве аргументов других функций, возвращать их из функций и присваивать переменным. Это открывает двери для мощных абстракций и шаблонов проектирования, таких как функции высшего порядка, каррирование и композиция функций.\n4.\nУпрощение параллельного и асинхронного кода\nНеизменяемость данных и чистые функции делают функциональные программы более подходящими для параллельного выполнения, поскольку отсутствие общего изменяемого состояния снижает риск возникновения гонок данных. Это делает функциональное программирование особенно актуальным для современных приложений, где асинхронное выполнение и обработка больших объёмов данных на клиенте и сервере становятся всё более важными.\n5.\nФункциональное мышление\nРазвивает навык декомпозиции проблемы на небольшие, независимые части, которые затем могут быть решены с помощью чистых функций. Этот подход может применяться и в нефункциональных языках программирования, улучшая структуру и читаемость кода.\n6.\nРазнообразие и инновации\nВдохновило множество инноваций в области компьютерных наук, от ленивых вычислений до монад. Изучение функциональных языков может расширить горизонты разработчика и предложить новые подходы к решению задач.\nХотя функциональное программирование может казаться сложным на первый взгляд, оно предлагает мощные абстракции и принципы, которые могут значительно улучшить качество ПО. Оно способствует написанию кода, который легче понять, тестировать и поддерживать, а также обеспечивает полезные навыки, применимые в широком спектре программных проектов.',
    videos: [
      {
        url: "https://www.youtube.com/live/MdRE18dGmNU?feature=share&t=6773",
        title: "Публичное собеседование: Junior Fron…",
        time: 6773,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2002,
    question: "Какой план развития в обучении",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/5U3Fy9mpu5Q?feature=share&t=1899",
        title: "Публичное собеседование с frontend-р…",
        time: 1899,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2004,
    question: "Какие библиотеки популярны в react",
    explanation:
      'В экосистеме React существует множество популярных библиотек, которые используются для улучшения разработки, повышения производительности и добавления дополнительного функционала в ваши приложения. Рассмотрим некоторые из них:\n1.\nReact Router\nЭто стандартная библиотека для маршрутизации в React-приложениях. Она позволяет вам внедрять динамическую навигацию в приложение, без перезагрузки страницы. React Router поддерживает как веб, так и мобильные приложения.\n2.\nRedux\nЭто библиотека для управления состоянием приложения. Она чаще всего используется в сложных приложениях с большим объемом данных и множеством действий, которые могут изменять это состояние. Помогает упростить управление состоянием, делая его предсказуемым.\n3.\nAxios\nЭто библиотека для выполнения HTTP-запросов. Она может использоваться в браузере и на сервере (Node.js). Предлагает широкий набор функций и удобный API для выполнения запросов к серверу и обработки ответов.\n4.\nMaterial-UI\nСодержит готовые компоненты, стилизованные согласно Material Design от Google. Это позволяет легко и быстро создавать красивые и функциональные пользовательские интерфейсы.\n5.\nStyled Components\nИспользуется для стилизации компонентов в приложениях React. Это библиотека, позволяющая писать CSS-код непосредственно в файлах, используя тегированные шаблонные строки. Это помогает создавать стилизованные компоненты, которые легко переиспользовать и поддерживать.\n6.\nReact Testing Library\nПредназначена для тестирования компонентов. Она позволяет тестировать компоненты "как они есть", симулируя взаимодействие пользователя с интерфейсом, что делает тесты более надежными и удобными в поддержке.\n7.\nReact Query\nПредлагает удобные инструменты для выполнения, кэширования и синхронизации асинхронных запросов в React-приложениях. Она автоматически обрабатывает обновление данных, кэширование и инвалидацию, значительно упрощая работу с асинхронными данными.\nЭти библиотеки являются лишь частью большой экосистемы инструментов, доступных для разработчиков React. Выбор конкретных библиотек зависит от требований проекта, предпочтений разработчика и специфики задач.\nВ экосистеме React популярны библиотеки для маршрутизации (React Router), управления состоянием (Redux), выполнения HTTP-запросов (Axios), стилизации (Material-UI, Styled Components), тестирования (React Testing Library) и работы с асинхронными данными (React Query).',
    videos: [
      {
        url: "https://www.youtube.com/live/5U3Fy9mpu5Q?feature=share&t=2369",
        title: "Публичное собеседование с frontend-р…",
        time: 2369,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2006,
    question: "Какие популярные подходы изобрели для redux",
    explanation:
      'Для упрощения работы с Redux и повышения эффективности разработки вокруг него возникло несколько популярных подходов и инструментов. Эти подходы помогают решать типичные проблемы, связанные с бойлерплейтом, управлением асинхронными операциями и повторным использованием логики. Рассмотрим некоторые из них:\n1.\nRedux Toolkit (RTK)\nЭто официальный инструмент, предназначенный для упрощения работы с Redux. Он предоставляет набор утилит, которые помогают сократить количество бойлерплейта при инициализации хранилища, создании редюсеров и действий. Он включает в себя такие функции, как\n`configureStore`\n,\n`createReducer`\n,\n`createAction`\n, и\n`createSlice`\n, которые значительно упрощают процесс работы с состоянием.\n2.\nRedux Saga\nЭто библиотека, предназначенная для управления асинхронными операциями (например, доступом к данным, чистыми функциями для побочных эффектов) в приложениях React с использованием Redux. Саги написаны с использованием генераторов, что облегчает управление сложными потоками асинхронных действий.\n3.\nRedux Thunk\nЭто промежуточное программное обеспечение (middleware) для Redux, позволяющее диспетчеризации функций вместо действий. Это позволяет откладывать выполнение действия или диспетчеризировать только при выполнении определённых условий. Thunk часто используется для работы с асинхронными запросами.\n4.\nReselect\nЭто библиотека для создания "мемоизированных" селекторов. Селекторы позволяют вычислять производные данные, основываясь на состоянии Redux, и эффективно пересчитывать результаты только при изменении соответствующих частей состояния. Это улучшает производительность, особенно в сложных приложениях.\n5.\nNormalizr\nЭто библиотека для нормализации вложенных JSON структур. В контексте Redux она помогает преобразовать вложенные данные в плоскую структуру, что упрощает хранение и манипуляцию данными в хранилище.\n6.\nImmutable.js\nПредоставляет коллекции неизменяемых данных, которые помогают эффективно работать со сложными структурами данных. Неизменяемость данных упрощает отслеживание изменений, повышает производительность приложения и упрощает разработку.\nЭти подходы и инструменты были разработаны для решения общих проблем разработки с использованием Redux, таких как управление бойлерплейтом, асинхронные операции и обработка данных. Они делают работу с ним более удобной и эффективной, позволяя разработчикам сосредоточиться на бизнес-логике приложения.',
    videos: [
      {
        url: "https://www.youtube.com/live/5U3Fy9mpu5Q?feature=share&t=2750",
        title: "Публичное собеседование с frontend-р…",
        time: 2750,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2008,
    question: "Какие протоколы взаимодействия знаешь",
    explanation:
      "В сфере веб-разработки и сетевых технологий существует множество протоколов взаимодействия, каждый из которых предназначен для решения определённых задач. Вот некоторые из наиболее распространённых и важных протоколов:\nHTTP (HyperText Transfer Protocol)\nЭто основной протокол для передачи данных в интернете, используемый для загрузки веб-страниц (HTML, CSS, JavaScript и изображений) от сервера к клиенту, обычно веб-браузеру. HTTP определяет методы (например, GET и POST), которые клиенты могут использовать для выполнения запросов к серверам.\nHTTPS (HTTP Secure)\nЭто расширение HTTP, обеспечивающее зашифрованное соединение между клиентом и сервером. Это критически важно для обеспечения безопасности данных пользователя, особенно при передаче конфиденциальной информации, такой как логины и пароли, платёжные данные.\nWebSocket\nЭто протокол, позволяющий устанавливать двусторонние интерактивные соединения между браузером пользователя и сервером. Это особенно полезно для создания веб-приложений, требующих реального времени обмена данными, таких как чаты, игры и торговые платформы.\nFTP (File Transfer Protocol)\nЭто стандартный протокол передачи файлов между компьютерами по сети. Он используется для загрузки и скачивания файлов с сервера, администрирования сайтов и управления содержимым сервера.\nSMTP (Simple Mail Transfer Protocol)\nЭто протокол для отправки электронных писем. Он используется почтовыми серверами для доставки отправленных писем в почтовые ящики получателей.\nIMAP (Internet Message Access Protocol) и POP3 (Post Office Protocol version 3)\nЭто протоколы, используемые для извлечения электронной почты из почтового сервера. IMAP предлагает более сложные функции по сравнению с POP3, включая возможность работы с электронной почтой непосредственно на сервере, что позволяет пользователям доступ к почте с разных устройств.\nTCP/IP (Transmission Control Protocol/Internet Protocol)\nЭто основные протоколы, лежащие в основе интернета, обеспечивающие передачу данных между различными устройствами в сети. Он отвечает за установление соединения и гарантию доставки данных, в то время как IP обеспечивает адресацию и маршрутизацию пакетов данных.\nDNS (Domain Name System)\nЭто система, которая переводит доменные имена в IP-адреса, позволяя пользователям легко находить веб-сайты в интернете без необходимости запоминать числовые IP-адреса.\nЭти протоколы являются ключевыми для функционирования интернета и веб-технологий, обеспечивая различные аспекты передачи данных, безопасности, обмена сообщениями и доступа к ресурсам.",
    videos: [
      {
        url: "https://www.youtube.com/live/5U3Fy9mpu5Q?feature=share&t=3822",
        title: "Публичное собеседование с frontend-р…",
        time: 3822,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2010,
    question: "Зачем нужны сокеты",
    explanation:
      "Сокеты — это программные интерфейсы (API), позволяющие обеспечивать взаимодействие между приложениями по сети. Они используются для создания сетевых соединений для обмена данными между клиентом и сервером или между узлами в сети. Вот основные причины, по которым сокеты являются важным инструментом в разработке сетевых приложений:\n1.\nОбеспечение двусторонней коммуникации\nПозволяют реализовать двустороннюю, непрерывную коммуникацию между клиентом и сервером. Это означает, что данные могут передаваться в обоих направлениях как постоянный поток, что идеально подходит для реалтаймовых приложений, таких как чаты, игры и системы мониторинга в реальном времени.\n2.\nРабота в реальном времени\nПозволяют создавать приложения, работающие в реальном времени, благодаря минимальным задержкам передачи данных. Это особенно важно для приложений, требующих мгновенного обмена данными, например, в онлайн-играх, видеоконференциях и финансовых торговых платформах.\n3.\nПоддержка множества клиентов\nС их использованием сервер может обрабатывать множество соединений с клиентами одновременно. Это достигается через механизмы многопоточности или асинхронного ввода-вывода, позволяя серверу эффективно масштабироваться для обслуживания большого числа пользователей.\n4.\nГибкость и контроль\nПредоставляют разработчикам большую гибкость и контроль над тем, как устанавливаются и управляются сетевые соединения. Разработчики могут определять, какие протоколы использовать (TCP, UDP и др.), как обрабатывать ошибки и потерю пакетов, а также как оптимизировать производительность для конкретных требований приложения.\n5.\nПередача различных типов данных\nС их помощью можно передавать практически любые типы данных — от простого текста до сложных двоичных форматов, таких как видео, аудио и структурированные данные. Это делает сокеты универсальным инструментом для разработки сетевых приложений.\nСокеты необходимы для создания сетевых приложений, которые требуют эффективной, двусторонней коммуникации между клиентами и серверами в реальном времени. Они обеспечивают гибкость, масштабируемость и контроль над процессом обмена данными, что делает их незаменимым инструментом в разработке приложений для различных сценариев использования, от веб-сервисов до интерактивных онлайн-игр.",
    videos: [
      {
        url: "https://www.youtube.com/live/5U3Fy9mpu5Q?feature=share&t=4210",
        title: "Публичное собеседование с frontend-р…",
        time: 4210,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2012,
    question: "Какие структуры используете в проекте",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/JERUf-xKU1o?feature=share&t=2153",
        title: "Публичное собеседование #6: Дмитрий …",
        time: 2153,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2014,
    question: "Зачем отправляется http запрос",
    explanation:
      "HTTP-запросы отправляются для обмена данными между клиентом (обычно веб-браузером) и сервером в интернете. Этот процесс является основой работы веба. Клиент отправляет запрос серверу, когда пользователь взаимодействует с веб-страницей: например, когда он открывает страницу, нажимает на ссылку, отправляет форму или выполняет любое другое действие, которое требует получения данных с сервера или отправки данных на сервер.\nЗачем они нужны:\n1.\nПолучение контента:\nПозволяют пользователям получать контент веб-страниц, такой как HTML-документы, стили, скрипты, изображения и многое другое. Без них веб-браузер не смог бы получить необходимые данные для отображения веб-страницы.\n2.\nОтправка данных:\nКогда пользователь заполняет форму на веб-сайте (например, форму регистрации или поиска), данные формы отправляются на сервер с их использованием. Это позволяет серверу обработать полученные данные и выполнить соответствующие действия, например, создать новую учетную запись пользователя или вернуть результаты поиска.\n3.\nВзаимодействие с веб-приложениями:\nСовременные веб-приложения часто используют AJAX для их отправки в фоновом режиме. Это позволяет обновлять содержимое веб-страницы без необходимости перезагрузки всей страницы, делая взаимодействие пользователя с приложением более плавным и интерактивным.\nПример:\nПредставим, что вы хотите посмотреть видео на YouTube. Когда вы вводите адрес видео в браузере и нажимаете Enter, браузер отправляет его на сервер YouTube с просьбой отправить данные, необходимые для отображения страницы видео. Сервер обрабатывает запрос и отвечает, отправляя обратно HTML, CSS, JavaScript и любые другие данные, необходимые для отображения страницы и воспроизведения видео.\nHTTP-запросы — это фундаментальная часть взаимодействия между веб-браузерами и серверами, позволяющая пользователям получать и отправлять данные в интернете. Они делают возможным получение веб-страниц, отправку форм, взаимодействие с веб-приложениями и многие другие действия, которые мы считаем само собой разумеющимися в современном интернете. Проще говоря, благодаря HTTP-запросам интернет работает так, как мы привыкли его видеть: веб-страницы загружаются, формы отправляются, а веб-приложения отвечают на наши действия.",
    videos: [
      {
        url: "https://www.youtube.com/live/JERUf-xKU1o?feature=share&t=2265",
        title: "Публичное собеседование #6: Дмитрий …",
        time: 2265,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2016,
    question: "Что такое dns",
    explanation:
      "DNS (система доменных имен, Domain Name System) — это распределённая система для перевода доменных имен в IP-адреса и обратно. Она необходима для того, чтобы упростить доступ к ресурсам Интернета, поскольку запоминать численные IP-адреса серверов сложно, а вот читаемые человеком доменные имена — гораздо проще.\nКак работает:\n1.\nПеревод доменных имен в IP-адреса:\nКогда вы вводите в браузере адрес веб-сайта, например, www.example.com, ваш компьютер сначала обращается к такому серверу, чтобы узнать IP-адрес, соответствующий этому доменному имени. DNS-сервер ищет нужную информацию в своей базе данных и возвращает IP-адрес веб-сервера, на котором хранится сайт.\n2.\nИерархическая структура:\nСистема доменных имен организована иерархически. На вершине иерархии находятся корневые серверы. Ниже располагаются серверы верхнего уровня (TLD серверы, отвечающие за домены верхнего уровня, такие как .com, .net, .org и т.д.), ещё ниже — авторитетные DNS-серверы, которые содержат информацию о конкретных доменах.\n3.\nРаспределённость:\nЯвляется распределённой системой, что означает, что информация о доменных именах распределена по множеству серверов по всему миру. Это обеспечивает высокую доступность и устойчивость системы к отказам.\n4.\nКэширование:\nДля повышения эффективности такие запросы могут кэшироваться на различных уровнях: в вашем браузере, на вашем локальном DNS-сервере (предоставляется вашим интернет-провайдером) и на промежуточных DNS-серверах. Благодаря кэшированию повторные запросы к уже посещённым сайтам обрабатываются быстрее.\nЗачем нужен:\nУдобство:\nДелает Интернет удобным для использования, позволяя обращаться к сайтам по понятным доменным именам вместо запоминания IP-адресов.\nМасштабируемость:\nБлагодаря иерархической и распределённой структуре он легко масштабируется, обеспечивая быстрое разрешение доменных имен даже при росте числа интернет-ресурсов.\nГибкость:\nПозволяет веб-сайтам изменять свои IP-адреса (например, при переезде на другой хостинг) без изменения доменного имени, что невозможно без такой системы.\nDNS — это критически важная инфраструктура Интернета, делающая его более доступным и удобным для пользователей по всему миру, позволяя легко находить и посещать веб-сайты, используя запоминающиеся доменные имена.",
    videos: [
      {
        url: "https://www.youtube.com/live/JERUf-xKU1o?feature=share&t=2430",
        title: "Публичное собеседование #6: Дмитрий …",
        time: 2430,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2018,
    question: "Какие особенности в js",
    explanation:
      'JavaScript (JS) — это мощный, гибкий и широко используемый язык для веб-разработки. Он имеет ряд особенностей и принципов, делающих его уникальным:\n1.\nИнтерпретируемый язык\nDыполняется в браузере пользователя на лету, без необходимости предварительной компиляции. Это означает, что его код интерпретируется и выполняется напрямую браузером, что обеспечивает быстрое время отклика и упрощает разработку.\n2.\nДинамическая типизация\nНе требуется заранее объявлять тип переменной. Типы данных присваиваются автоматически во время выполнения программы, что делает язык гибким, но также повышает вероятность ошибок из-за неявных преобразований типов.\n3.\nОбъектно-ориентированный\nПоддерживает объектно-ориентированное программирование (ООП). Всё в нем является объектом, включая функции. Однако он использует прототипное наследование вместо классического наследования, используемого во многих других языках ООП.\n4.\nАсинхронность\nПоддерживает асинхронное программирование, в частности, через промисы (Promises) и асинхронные функции (async/await). Это позволяет ему выполнять долгие операции, такие как запросы к серверу, без блокировки основного потока выполнения, что критически важно для создания отзывчивых веб-приложений.\n5.\nСобытийно-ориентированное программирование\nПозволяет легко обрабатывать пользовательские события (например, клики мышью, нажатия клавиш) с помощью событийных обработчиков. Это делает его идеальным для создания интерактивных веб-страниц.\n6.\nВысокая переносимость\nЕго код может выполняться в любом современном веб-браузере без необходимости специальных адаптаций, что обеспечивает высокую переносимость между различными платформами и устройствами.\n7.\nИсполнение в одном потоке\nВ браузере работает в однопоточном режиме с использованием механизма цикла событий (event loop), что упрощает модель выполнения, но требует внимательного управления асинхронными операциями, чтобы избежать "зависания" веб-страницы.\n8.\nСовместимость с HTML и CSS\nТесно интегрирован с ними, что позволяет разработчикам легко манипулировать элементами веб-страницы, изменять стили и реагировать на действия пользователя в реальном времени.\nJavaScript обладает уникальным набором характеристик, таких как интерпретируемость, динамическая типизация, объектно-ориентированность с прототипным наследованием, поддержка асинхронного программирования и событийно-ориентированное программирование, что делает его весьма мощным инструментом для создания динамичных и интерактивных веб-приложений.',
    videos: [
      {
        url: "https://www.youtube.com/live/fk_eTY2IZQE?feature=share&t=384",
        title: "Публичное собеседование: фронтендер …",
        time: 384,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2020,
    question: "Какой смысл замыканий, если бы не было функций высшего порядка",
    explanation:
      'Замыкания — это функции, которые запоминают своё лексическое окружение на момент создания, даже если они вызываются вне своей области видимости. Эта особенность позволяет им доступ к переменным из своего внешнего лексического контекста.\nДаже если бы не существовало функций высшего порядка (функций, которые могут принимать другие функции в качестве аргументов или возвращать их), замыкания всё равно играли бы важную роль по нескольким причинам:\n1.\nСохранение состояния\nПозволяют функции сохранять состояние между вызовами без использования глобальных переменных. Это делает код более чистым и менее подверженным ошибкам, связанным с глобальным состоянием.\nfunction makeCounter() {\n  let count = 0;\n  return function() {\n    return count++;\n  };\n}\nconst counter = makeCounter();\nconsole.log(counter()); // 0\nconsole.log(counter()); // 1\n2.\nИнкапсуляция данных\nОбеспечивают инкапсуляцию, позволяя скрыть переменные внутри функции, делая их недоступными извне. Это способствует созданию более безопасного и модульного кода.\nfunction createBankAccount(initialBalance) {\n  let balance = initialBalance;\n  return {\n    deposit: function(amount) {\n      balance += amount;\n      return balance;\n    },\n    withdraw: function(amount) {\n      if (amount <= balance) {\n        balance -= amount;\n        return balance;\n      }\n    }\n  };\n}\nconst account = createBankAccount(100);\nconsole.log(account.deposit(50)); // 150\nconsole.log(account.withdraw(20)); // 130\n// Здесь balance недоступен напрямую\n3.\nМодульность и структурирование кода\nМогут помочь в создании модулей и организации кода. Функции, которые возвращают другие функции, могут служить основой для создания модульных и хорошо структурированных приложений.\nfunction setupAlertTimeout(message, delay) {\n  return setTimeout(function() {\n    alert(message);\n  }, delay);\n}\nsetupAlertTimeout("Привет!", 1000);\nДаже без функций высшего порядка, замыкания остаются мощным инструментом для сохранения состояния, инкапсуляции данных и организации кода. Они позволяют разработчикам создавать более безопасный, модульный и поддерживаемый код, обеспечивая при этом эффективное управление состоянием и областями видимости.',
    videos: [
      {
        url: "https://www.youtube.com/live/fk_eTY2IZQE?feature=share&t=650",
        title: "Публичное собеседование: фронтендер …",
        time: 650,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2022,
    question: "Какую проблему решает асинхронность в js",
    explanation:
      "Асинхронность\nрешает проблему блокировки основной нити выполнения (main thread) при выполнении длительных операций. Основная нить выполнения отвечает за обработку пользовательского интерфейса, а также за выполнение кода. Если длительные операции, такие как сетевые запросы, таймеры или ввод/вывод, выполняются синхронно, они могут блокировать пользовательский интерфейс, делая приложение неотзывчивым и неудобным для пользователя. Асинхронность позволяет выполнять такие операции параллельно, не блокируя основную нить.\nОсновные проблемы:\n1. Блокировка пользовательского интерфейса (UI)\nСинхронные операции, такие как загрузка данных из сети, чтение файлов или выполнение сложных вычислений, могут блокировать основной поток, замораживая интерфейс и делая приложение неотзывчивым.\nАсинхронные операции позволяют избежать этой блокировки, выполняя задачи в фоновом режиме и возвращаясь к основному потоку, когда результаты готовы.\nfunction fetchData() {\n  const request = new XMLHttpRequest();\n  request.open('GET', 'https://api.example.com/data', false); // false для синхронного запроса\n  request.send();\n  if (request.status === 200) {\n    console.log(request.responseText);\n  }\n}\nfetchData();\nconsole.log('Этот код выполнится только после завершения fetchData');\n2. Параллельное выполнение задач\nАсинхронные операции позволяют выполнять несколько задач параллельно, что повышает производительность и эффективность приложения.\nНапример, загрузка нескольких ресурсов (изображений, скриптов, стилей) одновременно может значительно ускорить время загрузки страницы.\nconst urls = [\n  'https://api.example.com/data1',\n  'https://api.example.com/data2',\n  'https://api.example.com/data3'\n];\nPromise.all(urls.map(url => fetch(url).then(response => response.json())))\n  .then(results => {\n    console.log('All data fetched:', results);\n  })\n  .catch(error => console.error('Error fetching data:', error));\n3. Обработка событий и таймеров\nАсинхронные функции, такие как setTimeout и setInterval, позволяют выполнять задачи с задержкой или периодически, не блокируя основной поток.\nЭто полезно для выполнения задач по расписанию, создания анимаций, обработки пользовательских событий и многого другого.\nconsole.log('Start');\nsetTimeout(() => {\n  console.log('Executed after 2 seconds');\n}, 2000);\nconsole.log('End');\n4. Работа с I/O (ввод/вывод)\nАсинхронные операции ввода/вывода позволяют эффективно обрабатывать задачи чтения и записи данных, например, при работе с файлами или базами данных.\nЭто важно для серверных приложений, обрабатывающих множество одновременных запросов без блокировки.\nconst fs = require('fs');\nfs.readFile('example.txt', 'utf8', (err, data) => {\n  if (err) {\n    console.error('Error reading file:', err);\n    return;\n  }\n  console.log('File content:', data);\n});\nconsole.log('This code runs while the file is being read');\nОсновные механизмы:\n1. Коллбэки (Callbacks)\nФункции обратного вызова, которые вызываются по завершении асинхронной операции.\nfunction fetchData(callback) {\n  setTimeout(() => {\n    const data = 'Some data';\n    callback(data);\n  }, 1000);\n}\nfetchData(data => {\n  console.log('Data received:', data);\n});\nАсинхронность решает проблему блокировки основной нити выполнения при выполнении длительных операций, таких как сетевые запросы, таймеры и операции ввода/вывода. Она позволяет выполнять эти задачи параллельно, не блокируя пользовательский интерфейс и обеспечивая более отзывчивое и эффективное поведение приложений. Асинхронность реализуется с помощью коллбэков, промисов и синтаксиса\nasync/await\n.\nJuly 1, 2024, easyoffer",
    videos: [
      {
        url: "https://www.youtube.com/live/fk_eTY2IZQE?feature=share&t=885",
        title: "Публичное собеседование: фронтендер …",
        time: 885,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2024,
    question: "Зачем создавались библиотеки react и другие",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/fk_eTY2IZQE?feature=share&t=2089",
        title: "Публичное собеседование: фронтендер …",
        time: 2089,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2026,
    question: "Как часто происходит рендер",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/fk_eTY2IZQE?feature=share&t=2520",
        title: "Публичное собеседование: фронтендер …",
        time: 2520,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2028,
    question: "Чем занимается компания",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/live/wGVdU1Jje2M?feature=share&t=349",
        title: "Frontend-разработчик: публичное собе…",
        time: 349,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2030,
    question: "Что такое доступность интерфейсов",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/9nBbRK-Gfjg?t=3026",
        title: "Мок-интервью для джуна-фронтендера: …",
        time: 3026,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2034,
    question: "Как мы отрисовывается сайт для пользователя",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/U3-TSl4cRn0?t=1464",
        title: "Как мы отрисовывается сайт для польз…",
        time: 1464,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2036,
    question: "Как задать последовательность выполнения скриптов",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/U3-TSl4cRn0?t=1698",
        title: "Из питониста во фронтендеры: собесед…",
        time: 1698,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2038,
    question: "Как оптимизировать сайт",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/U3-TSl4cRn0?t=2089",
        title: "Из питониста во фронтендеры: собесед…",
        time: 2089,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2040,
    question: "Что если микрозадача создаст еще микрозадачу",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/U3-TSl4cRn0?t=2379",
        title: "Из питониста во фронтендеры: собесед…",
        time: 2379,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2042,
    question: "Чем отличается пропс от стейта",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/U3-TSl4cRn0?t=2983",
        title: "Из питониста во фронтендеры: собесед…",
        time: 2983,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2043,
    question: "Что выбираешь ооп или функции",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/U3-TSl4cRn0?t=3084",
        title: "Из питониста во фронтендеры: собесед…",
        time: 3084,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2044,
    question: "Для чего скрипт подключают в концe body",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/5gplqEVgajc?t=1308",
        title: "Cобеседование Junior Frontend разраб…",
        time: 1308,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2045,
    question: "Зачем нужна семантика",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/5gplqEVgajc?t=1484",
        title: "Cобеседование Junior Frontend разраб…",
        time: 1484,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2046,
    question: "Как использовать селектор",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/5gplqEVgajc?t=1841",
        title: "Cобеседование Junior Frontend разраб…",
        time: 1841,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2047,
    question: "Почему селекторы перенаследуются",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/5gplqEVgajc?t=1944",
        title: "Cобеседование Junior Frontend разраб…",
        time: 1944,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2048,
    question: "Какие есть значения у box-sizing",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/5gplqEVgajc?t=2204",
        title: "Cобеседование Junior Frontend разраб…",
        time: 2204,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2049,
    question: "Как значения box-size влияют на размер элемента",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/5gplqEVgajc?t=2204",
        title: "Cобеседование Junior Frontend разраб…",
        time: 2204,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2050,
    question: "Какое значение box-size стоит в браузере по умолчанию",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/5gplqEVgajc?t=2251",
        title: "Cобеседование Junior Frontend разраб…",
        time: 2251,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2051,
    question: "Как пользовался линтер js",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/5gplqEVgajc?t=2458",
        title: "Cобеседование Junior Frontend разраб…",
        time: 2458,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2052,
    question: "Зачем нужен линтер",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/5gplqEVgajc?t=2491",
        title: "Cобеседование Junior Frontend разраб…",
        time: 2491,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2053,
    question: "Сколько есть способов что-то сделать асинхронно",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/5gplqEVgajc?t=3144",
        title: "Cобеседование Junior Frontend разраб…",
        time: 3144,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2054,
    question: "Зачем придумали async/await",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/5gplqEVgajc?t=3483",
        title: "Cобеседование Junior Frontend разраб…",
        time: 3483,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2055,
    question: "Какие способы создания функций знаешь",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/5gplqEVgajc?t=3687",
        title: "Cобеседование Junior Frontend разраб…",
        time: 3687,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2056,
    question: "Какое отличие между двумя видами задания функции",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/5gplqEVgajc?t=3786",
        title: "Cобеседование Junior Frontend разраб…",
        time: 3786,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2057,
    question: "Какие методы массивов мутируют его",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/5gplqEVgajc?t=4178",
        title: "Cобеседование Junior Frontend разраб…",
        time: 4178,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2058,
    question: "Как попал в разработку",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/5GkMyQAGLXg?t=140",
        title: "Собеседование frontend-разработчика …",
        time: 140,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2059,
    question: "Что больше нравится react or vue",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/5GkMyQAGLXg?t=571",
        title: "Собеседование frontend-разработчика …",
        time: 571,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2060,
    question: "В какой команде работаешь",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/5GkMyQAGLXg?t=896",
        title: "Собеседование frontend-разработчика …",
        time: 896,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2061,
    question: "Как происходит работа с задачами в проекте",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/5GkMyQAGLXg?t=1083",
        title: "Собеседование frontend-разработчика …",
        time: 1083,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2062,
    question: "Какой подход использовал в построении архитектуры",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/5GkMyQAGLXg?t=1750",
        title: "Собеседование frontend-разработчика …",
        time: 1750,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2063,
    question: "Как привычнее работать с git",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/5GkMyQAGLXg?t=1958",
        title: "Собеседование frontend-разработчика …",
        time: 1958,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2064,
    question: "Приходилось ли делать нетипичные вещи в git",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/5GkMyQAGLXg?t=1996",
        title: "Собеседование frontend-разработчика …",
        time: 1996,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2065,
    question: "Как происходит merge or rebase в компании",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/5GkMyQAGLXg?t=2304",
        title: "Собеседование frontend-разработчика …",
        time: 2304,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2066,
    question: "Как изучал frontend в сторону верстки или только js",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/5GkMyQAGLXg?t=2457",
        title: "Собеседование frontend-разработчика …",
        time: 2457,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2067,
    question: "Как бы строил сетку сайта",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/5GkMyQAGLXg?t=2665",
        title: "Собеседование frontend-разработчика …",
        time: 2665,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2068,
    question: "Какое свойство css использовал бы для сохранения доступности",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/5GkMyQAGLXg?t=2779",
        title: "Собеседование frontend-разработчика …",
        time: 2779,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2069,
    question: "Как бы сортировал массивы с числами",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/P2x_lmvVOfE?t=80",
        title: "Собеседование JUNIOR FRONTEND REACT …",
        time: 80,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2070,
    question: "С какими перебирающими массивами знаком",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/P2x_lmvVOfE?t=240",
        title: "Собеседование JUNIOR FRONTEND REACT …",
        time: 240,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2071,
    question: "Зачем нужен redux thunk  и можно ли обойтись без него",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/P2x_lmvVOfE?t=2459",
        title: "Собеседование JUNIOR FRONTEND REACT …",
        time: 2459,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2072,
    question: "С какими нововведениями es6 знаком",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/P2x_lmvVOfE?t=2756",
        title: "Собеседование JUNIOR FRONTEND REACT …",
        time: 2756,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2073,
    question: "Для чего приходилось копировать объекты",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/P2x_lmvVOfE?t=3215",
        title: "Собеседование JUNIOR FRONTEND REACT …",
        time: 3215,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2074,
    question: "Keyframes для чего нужен и как работает",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=114",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 114,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2075,
    question: "Как бы реализовал кастомный чекбокс",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=325",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 325,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2076,
    question: "Как обрабатывает web страницу браузер",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=444",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 444,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2077,
    question: "Чем border отличается от outline",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=494",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 494,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2078,
    question: "Как при нажатии на ссылку открывать страницу в другом окне",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=583",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 583,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2079,
    question: "Что такое семантические элементы и для чего они нужны",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=623",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 623,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2080,
    question: "Свойство overflow, что делает и когда использовать",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=640",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 640,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2081,
    question: "Как изменить курсор",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=687",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 687,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2082,
    question: "Как изменить направление оси flexbox контейнера",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=708",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 708,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2083,
    question: "Какие виды инпутов бывают",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=772",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 772,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2084,
    question:
      "За что отвечает justify-content и align-tiems у flexbox контейнера",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=779",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 779,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2085,
    question: "Как убрать маркер у списка",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=820",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 820,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2086,
    question: "Какие бывают значение у background-size",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=879",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 879,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2087,
    question: "!Important для чего используется",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=988",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 988,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2088,
    question: "Как работают медиа запросы про мобильные приложения",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=1103",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 1103,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2089,
    question:
      "Какое свойство используется для перевода текста в заглавные/строчные буквы",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=1140",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 1140,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2090,
    question: "Для чего рекомендуется использовать атрибуты data",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=1160",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 1160,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2091,
    question: "Как стилизовать инпут для загрузки файлов",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=1212",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 1212,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2092,
    question: "Что такое селектор атрибутов",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=1251",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 1251,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2093,
    question: "Как изменить стили кнопок с атрибутом disabled",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=1272",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 1272,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2094,
    question: "Как изменить стили для элемента span",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=1292",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 1292,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2095,
    question:
      "С каким селектором можно добавлять стили на каждый элемент страницы",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=1315",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 1315,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2096,
    question:
      "Какое свойство позволяет вам спрятать элемент, но сохранить занимаемое им пространство на странице",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=1333",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 1333,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2097,
    question: "Как сделать тень падающую от блока",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=1371",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 1371,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2098,
    question: "Как сделать тень падающую от текста",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=1404",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 1404,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2099,
    question: "Как бы повернул блок на 45 градусов",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=1424",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 1424,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2102,
    question: "Для чего используются препроцессоры",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/4YRG6cMAASI?t=1506",
        title: "50 вопросов по CSS. Собеседование на…",
        time: 1506,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2106,
    question: "Что такое шаблонные литералы, и для чего они нужны",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/gV6eobXisYU?t=296",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 296,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2110,
    question: "Какие значения будут являться falsy значениями",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/gV6eobXisYU?t=398",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 398,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2114,
    question: "Как получить свойство объекта",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/gV6eobXisYU?t=805",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 805,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2118,
    question: "Какие основные реакт хуки знаешь и используешь",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/gV6eobXisYU?t=1345",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 1345,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2122,
    question: "Вычисляемые свойства, что такое, как использовать",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/gV6eobXisYU?t=1674",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 1674,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2126,
    question: "Как обрабатываются значения формы в vuex",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/gV6eobXisYU?t=1830",
        title: "СОБЕСЕДОВАНИЕ на FRONTEND разработчи…",
        time: 1830,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2130,
    question: "Какие альтернативы пулинга знаешь",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/NRufVTyELC4?t=930",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 930,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2134,
    question: "Как происходит аутентификация",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/NRufVTyELC4?t=1318",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 1318,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2136,
    question: "Что такое синтаксическая сложность",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/NRufVTyELC4?t=1586",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 1586,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2138,
    question: "Как относишься к работе в команде",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/lq4eefCCuVo?t=630",
        title: "Реальное СОБЕСЕДОВАНИЕ на FRONTEND р…",
        time: 630,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2140,
    question: "Что используешь в качестве системы контроля версий",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/lq4eefCCuVo?t=738",
        title: "Реальное СОБЕСЕДОВАНИЕ на FRONTEND р…",
        time: 738,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2142,
    question: "Какие различия между redux и mobx",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/lq4eefCCuVo?t=776",
        title: "Реальное СОБЕСЕДОВАНИЕ на FRONTEND р…",
        time: 776,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2146,
    question: "Что такое инверсия контроля",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/lq4eefCCuVo?t=1024",
        title: "Реальное СОБЕСЕДОВАНИЕ на FRONTEND р…",
        time: 1024,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2150,
    question: "В чём разница в работе eventloop на сервере и в браузере",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/lq4eefCCuVo?t=1384",
        title: "Реальное СОБЕСЕДОВАНИЕ на FRONTEND р…",
        time: 1384,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2154,
    question: "Какие проекты вёл самостоятельно",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/AWaL_1V9dEY?t=397",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 397,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2158,
    question: "Какое отношение к jquery",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/AWaL_1V9dEY?t=1244",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 1244,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2162,
    question: "Что такое хостинг js",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/Y1SekvuZ3M4?t=1013",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 1013,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2166,
    question: "Что не стоит писать в рендере",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/Y1SekvuZ3M4?t=1796",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 1796,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2170,
    question: "Какие есть альтернативы у redux",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/Y1SekvuZ3M4?t=2107",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 2107,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2174,
    question: "Где лучше осуществлять запросы в backend",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/Y1SekvuZ3M4?t=2292",
        title: "РЕАЛЬНОЕ СОБЕСЕДОВАНИЕ НА FRONTEND Р…",
        time: 2292,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2178,
    question:
      "Какими способами можно реализовать двустороннее связывание для input",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/umHjpWydn8I?t=52",
        title: "50 вопросов на Vue JS собеседование",
        time: 52,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2182,
    question: "Что такое computed свойства",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/umHjpWydn8I?t=517",
        title: "50 вопросов на Vue JS собеседование",
        time: 517,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2186,
    question: "Как отрисовать компонент по условию",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/umHjpWydn8I?t=756",
        title: "50 вопросов на Vue JS собеседование",
        time: 756,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2190,
    question: "Особенности использования пользовательской директивы",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/umHjpWydn8I?t=968",
        title: "50 вопросов на Vue JS собеседование",
        time: 968,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2194,
    question: "Зачем указывать key при использовании директивы v-for",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/umHjpWydn8I?t=1283",
        title: "50 вопросов на Vue JS собеседование",
        time: 1283,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2198,
    question: "Какие модификаторы есть у v-model",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/umHjpWydn8I?t=1494",
        title: "50 вопросов на Vue JS собеседование",
        time: 1494,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2202,
    question: "Как динамически изменять стили у элемента",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/umHjpWydn8I?t=1722",
        title: "50 вопросов на Vue JS собеседование",
        time: 1722,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2206,
    question: "Что такое телепорты в vue",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/umHjpWydn8I?t=1987",
        title: "50 вопросов на Vue JS собеседование",
        time: 1987,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2210,
    question:
      "В какой последователности будут вызываться хуки при использовании хуков жизненного цикла в миксине и подключении его в компонент",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/umHjpWydn8I?t=2077",
        title: "50 вопросов на Vue JS собеседование",
        time: 2077,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2214,
    question: "Расскажи о мутациях в vuex",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/umHjpWydn8I?t=2340",
        title: "50 вопросов на Vue JS собеседование",
        time: 2340,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2218,
    question: "Как принудительно обновлять компонент в vue",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/umHjpWydn8I?t=2423",
        title: "50 вопросов на Vue JS собеседование",
        time: 2423,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2222,
    question: "Какие способы хранения данных в браузере знаешь",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/jf5TkGzWqiM?t=214",
        title: "Собеседование JUNIOR FRONTEND REACT …",
        time: 214,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2226,
    question: "Для чего нужен хук usecontext",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/jf5TkGzWqiM?t=2214",
        title: "Собеседование JUNIOR FRONTEND REACT …",
        time: 2214,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 2230,
    question: "Какие семантические группы знаешь",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PLwrvZahiO4?t=125",
        title: "Собеседование на JavaScript разработ…",
        time: 125,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3464,
    question: "Что мешало начать получать коммерческий опыт",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=1000",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 1000,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3466,
    question: "Что делают выражения в js",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=1374",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 1374,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3467,
    question: "Как работают модули в es modules",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=2054",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 2054,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3469,
    question: "Чем можно заменить es modules/require",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=2348",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 2348,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3473,
    question: "Откуда берутся незаданные свойства у массивов",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=2570",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 2570,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3498,
    question: "Как задать свои свойства массиву",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=2620",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 2620,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3501,
    question: "Что знаешь про дискрипторы",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=2800",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 2800,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3504,
    question: "Почему мы не можем обратиться к элементу в input",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=3629",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 3629,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3508,
    question: "Сколько тегов нужно чтобы собрать html страницу",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=3899",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 3899,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3511,
    question: "Как еще можно структурировать html страницу",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=4288",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 4288,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3514,
    question: "Зачем нужны 6 групп заголовков в html",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=4500",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 4500,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3516,
    question: "Можно ли добавлять несколько заголовков h1",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=4579",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 4579,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3517,
    question: "Как проверить правильную иерархию html заголовков",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=4692",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 4692,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3521,
    question: "Как семантически разделять контент на странице",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=4807",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 4807,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3525,
    question: "В чем разница между aside article и section",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=4877",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 4877,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3527,
    question: "Приходилось оформлять контент в виде таблиц",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=5029",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 5029,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3531,
    question: "К чему бы склонялся для создания блока таблиц",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=5089",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 5089,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3535,
    question: "Как выглядит структура таблицы в html",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=5259",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 5259,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3539,
    question: "В чем проблема адаптации таблиц html",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=5492",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 5492,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3542,
    question: "Какие форматы изображений",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=5875",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 5875,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3544,
    question: "Как сделать webp с фолбеком",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=6119",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 6119,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3546,
    question: "Как можно вставить svg в html документ",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=6327",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 6327,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3548,
    question: "Как использовал iframe",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=6539",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 6539,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3551,
    question: "Как узнать что iframe загрузился",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=6593",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 6593,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3553,
    question: "Как общаться между iframe и самой страницой",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=6690",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 6690,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3556,
    question: "Как достигается изоляция при использовании бэм",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ScRTey_dvhI?t=6896",
        title: "#9 С Java на JavaScript в 35. Собесе…",
        time: 6896,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3559,
    question: "Какие есть и как работают циклы в js",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=ozvUaikP6cs&t=345s",
        title: "#6 Как волноваться и не облажаться? …",
        time: 345,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3561,
    question: "В чём отличие цикла for от while",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ozvUaikP6cs?t=496",
        title: "#6 Как волноваться и не облажаться? …",
        time: 496,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3563,
    question: "Какие знаешь способы клонирования объектов",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ozvUaikP6cs?t=1149",
        title: "#6 Как волноваться и не облажаться? …",
        time: 1149,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3565,
    question: "Как можно работать с датами в js",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ozvUaikP6cs?t=2765",
        title: "#6 Как волноваться и не облажаться? …",
        time: 2765,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3568,
    question: "Для чего нужно utc",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=ozvUaikP6cs&t=2940s",
        title: "#6 Как волноваться и не облажаться? …",
        time: 2940,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3569,
    question: "Как мы можем замерить скорость работы участка кода с date.Now",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=ozvUaikP6cs&t=3220s",
        title: "#6 Как волноваться и не облажаться? …",
        time: 3220,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3572,
    question: "Почему патчинг прототипа это плохо",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=ozvUaikP6cs&t=4000s",
        title: "#6 Как волноваться и не облажаться? …",
        time: 4000,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3575,
    question: "Какие есть способы фокусировки на элементе",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=ozvUaikP6cs&t=4430s",
        title: "#6 Как волноваться и не облажаться? …",
        time: 4430,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3578,
    question: "В чём разница между тегами div, img, p",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ozvUaikP6cs?t=5084",
        title: "#6 Как волноваться и не облажаться? …",
        time: 5084,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3582,
    question: "Что произойдет если мы напишем невалидную разметку",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=ozvUaikP6cs&t=5370s",
        title: "#6 Как волноваться и не облажаться? …",
        time: 5370,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3585,
    question: "Какие есть подходы к адаптивности",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ozvUaikP6cs?t=5661",
        title: "#6 Как волноваться и не облажаться? …",
        time: 5661,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3588,
    question: "Расскажи про импорты и модульность в css",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=ozvUaikP6cs&t=6000s",
        title: "#6 Как волноваться и не облажаться? …",
        time: 6000,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3590,
    question: "Для чего используешь sass",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=ozvUaikP6cs&t=6380s",
        title: "#6 Как волноваться и не облажаться? …",
        time: 6380,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3592,
    question: "Минус использование амперсанда в препроцессорах",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ozvUaikP6cs?t=6421",
        title: "#6 Как волноваться и не облажаться? …",
        time: 6421,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3594,
    question: "Какие есть варианты позиционирования в css",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=ozvUaikP6cs&t=6860s",
        title: "#6 Как волноваться и не облажаться? …",
        time: 6860,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3596,
    question: "Как мы можем заставить элемент быть выше другого",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=ozvUaikP6cs&t=7260s",
        title: "#6 Как волноваться и не облажаться? …",
        time: 7260,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3597,
    question: "Чем мы можем создать контекст позиционирования",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=ozvUaikP6cs&t=7450s",
        title: "#6 Как волноваться и не облажаться? …",
        time: 7450,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3599,
    question: "Как бороться с переполнением контентом",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=ozvUaikP6cs&t=7630s",
        title: "#6 Как волноваться и не облажаться? …",
        time: 7630,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3601,
    question: "В чем ключевое отличие мутабельных и имутабельных типов данных",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/d5weK2w1V4A?t=706",
        title: "Собеседование Junior Frontend разраб…",
        time: 706,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3603,
    question: "Чем отличается замыкание от области видимости",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/d5weK2w1V4A?t=2007",
        title: "Собеседование Junior Frontend разраб…",
        time: 2007,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3605,
    question: "Что такое ассинхронность",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/d5weK2w1V4A?t=2311",
        title: "Собеседование Junior Frontend разраб…",
        time: 2311,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3607,
    question: "В чем отличие синхронного кода от ассинхронного",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/d5weK2w1V4A?t=2312",
        title: "Собеседование Junior Frontend разраб…",
        time: 2312,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3609,
    question: "Зачем нужен use strict",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=2040",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 2040,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3611,
    question: "Как работают функции",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=441",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 441,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3612,
    question: "Как работает eventloop в web api",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=2285",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 2285,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3614,
    question: "Как взаимодействуешь с eventloop",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=2287",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 2287,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3615,
    question: "В чем принципиальная разница очереди и стека",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=2397",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 2397,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3620,
    question: "Как понять что dom загружен",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=3128",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 3128,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3621,
    question: "За счет чего достигается интерактивность в вебе",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=3422",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 3422,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3623,
    question: "Какие типы ивентов существуют",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=4002",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 4002,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3625,
    question: "Как между собой связаны html, css и js",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=4145",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 4145,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3627,
    question: "Если у нас есть css, зачем существуют теги strong, center, etc",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=4217",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 4217,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3628,
    question: "Что такое и зачем нужен iframe",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=5047",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 5047,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3630,
    question: "Какие особенности whitespace в html",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=4409",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 4409,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3632,
    question: "Какие недостатки есть в использовании iframe",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=5295",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 5295,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3634,
    question:
      "Почему для поисковых систем так важно, чтобы использовался (ssr)",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=5625",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 5625,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3636,
    question: "В чем заключаются недостатки ssr",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=5787",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 5787,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3638,
    question: "Расскажи про user agent стили и способы работы с ними",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=6559",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 6559,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3640,
    question: "Чем отличаются способы центрирования",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=6874",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 6874,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3642,
    question: "Как использовать способы центрирования",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=6875",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 6875,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3646,
    question: "Какие имеются способы горизонтального центрирования",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=7085",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 7085,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3649,
    question: "Какие есть способы центрирования через inline-block",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/0y9WmVR0rW4?t=7176",
        title: "#5 Мидл в 18 лет? Собеседование на F…",
        time: 7176,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3652,
    question: "В чем разница между es и commonjs модулями",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=g5LdFoV6iUg&t=1730s",
        title: "#12 Фронтенд-разработчик нейросети н…",
        time: 1730,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3654,
    question: "Зачем нужен eslint",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=g5LdFoV6iUg&t=4060s",
        title: "#12 Фронтенд-разработчик нейросети н…",
        time: 4060,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3657,
    question: "Зачем нужен docker",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/g5LdFoV6iUg?t=4291",
        title: "#12 Фронтенд-разработчик нейросети н…",
        time: 4291,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3659,
    question: "Что такое и как работает ci/cd",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/g5LdFoV6iUg?t=6168",
        title: "#12 Фронтенд-разработчик нейросети н…",
        time: 6168,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3662,
    question: "Зачем нужен nginx",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=g5LdFoV6iUg&t=6620s",
        title: "#12 Фронтенд-разработчик нейросети н…",
        time: 6620,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3666,
    question: "В чем преимущества node.Js",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=g5LdFoV6iUg&t=6850s",
        title: "#12 Фронтенд-разработчик нейросети н…",
        time: 6850,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3669,
    question: "Можем ли мы получить картинку по http",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/BonLyarPpqE?t=383",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 383,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3672,
    question: "Как браузер понимает что картинка является картинкой",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=BonLyarPpqE&t=412s",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 412,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3677,
    question: "Какими способами мы можем получить картинку с сервера",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=BonLyarPpqE&t=440s",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 440,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3848,
    question:
      "Каким образом браузер понимает тип содержимого в ответе от api(картинка, текст, etc)",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/BonLyarPpqE?t=498",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 498,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3851,
    question: "Как браузер понимает что нужно загрузить картинку",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/BonLyarPpqE?t=560",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 560,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3854,
    question:
      "Как браузер понимает что нужно отображать именно картинку а не текст",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/BonLyarPpqE?t=646",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 646,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3857,
    question: "Что такое коды ответа и чем они отличаются друг от друга",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=BonLyarPpqE&t=884s",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 884,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3860,
    question: "Какие методы запросов бывают",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=BonLyarPpqE&t=950s",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 950,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3862,
    question: "Как будешь делать html форму",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/BonLyarPpqE?t=1186",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 1186,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3865,
    question: "Что значит type submit",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/BonLyarPpqE?t=1344",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 1344,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3868,
    question: "Кто придумывает названия html тегам",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=BonLyarPpqE&t=1445s",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 1445,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3871,
    question: "Откуда берутся базовые стили для тегов",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=BonLyarPpqE&t=1500s",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 1500,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3873,
    question:
      "Какие проблемы могут возникнуть если всю верстку делать на дивах",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=BonLyarPpqE&t=1528s",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 1528,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3874,
    question: "Что такое html entities",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=BonLyarPpqE&t=1600s",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 1600,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3875,
    question: "Где можно найти списки с html entities",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=BonLyarPpqE&t=1686s",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 1686,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3877,
    question: "Какие особенности position: sticky ты знаешь",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=BonLyarPpqE&t=1885s",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 1885,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3882,
    question: "Как бы эмулировал поведение position: sticky",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=BonLyarPpqE&t=1930s",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 1930,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3886,
    question: "Что такое es модули",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/BonLyarPpqE?t=3496",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 3496,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3891,
    question: "Что такое и чем опасен xss",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=BonLyarPpqE&t=3670s",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 3670,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3895,
    question: "Как защитить cookie от js",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=BonLyarPpqE&t=3790s",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 3790,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3899,
    question: "Что такое csrf",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=BonLyarPpqE&t=3875s",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 3875,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3903,
    question: "В чем опасность работы с innerhtml",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=BonLyarPpqE&t=3915s",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 3915,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3908,
    question: "Как обезопасить себя от потенциально опасного клиентского ввода",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=BonLyarPpqE&t=4003s",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 4003,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3911,
    question: "Какие еще знаешь парадигмы программирования",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=BonLyarPpqE&t=4308s",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 4308,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3914,
    question: "Чем описание класса отличается от экземпляра класса",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=BonLyarPpqE&t=4435s",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 4435,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3916,
    question: "Что такое cqrs",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/BonLyarPpqE?t=4961",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 4961,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3919,
    question: "Что такое grasp",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=BonLyarPpqE&t=5680s",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 5680,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3923,
    question: "Что такое dry, kiss",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=BonLyarPpqE&t=5700s",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 5700,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3925,
    question: "Как понимаешь что код написан хорошо",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=BonLyarPpqE&t=5810s",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 5810,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3926,
    question: "Что еще является важной частью понимания кода",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=BonLyarPpqE&t=5895s",
        title: "#1 Cобеседование Middle Frontend раз…",
        time: 5895,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3929,
    question: "Что такое html, js и css",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=190s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 190,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3931,
    question: "Какие основные вещи присущи html",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=240s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 240,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3934,
    question: "В чем смысл таких тегов как section, header",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=428s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 428,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3938,
    question:
      "Почему мы не можем вместо тегов section и header использовать обычный div",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=448s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 448,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3942,
    question: "Какая будет разница для конечного пользователя в разных тегах",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=466s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 466,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3947,
    question:
      "Как называется характеристика html которая говорит о том как можно использовать разные теги для конкретных ситуаций",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=561s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 561,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3949,
    question: "Чем семантика отличается от доступности(a11y)",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=613s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 613,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3953,
    question: "В чем отличия разных подходов подключения стилей",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=735s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 735,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3955,
    question: "Какие знаешь подходы по написанию css",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/25lCunO6yDQ?t=1016",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 1016,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3957,
    question: "Как в css работают разные приоритеты стилей",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=1310s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 1310,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3959,
    question: "В чем отличие адаптивного дизайна от отзывчивого",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=1968s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 1968,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3961,
    question: "Какой тип у функции",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=2199s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 2199,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3964,
    question: "Чем похожи массивы, объекты и функции",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=2215s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 2215,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 3966,
    question: "Какие есть операторы в js",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=2255s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 2255,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4245,
    question: "Что такое делегирование",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/25lCunO6yDQ?t=3869",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 3869,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4248,
    question: "Что такое событийная модель в браузере",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/25lCunO6yDQ?t=3886",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 3886,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4250,
    question: "Что использовать, что всплытие событий не происходило",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=4273s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 4273,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4252,
    question: "Зачем нужен вью",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/25lCunO6yDQ?t=4473",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 4473,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4254,
    question: "Какие проблемы решают vue а какие jquery",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=4570s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 4570,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4256,
    question: "Знаком ли с модификаторами для v-bind",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=5250s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 5250,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4258,
    question: "Что быстрее, dom или virtual dom",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=5778s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 5778,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4260,
    question: "Что такое watch и computed, как оно работает",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=25lCunO6yDQ&t=6162s",
        title: "#0 Cобеседование Junior Frontend раз…",
        time: 6162,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4262,
    question:
      "Зачем нужна блочная область видимости если уже есть функциональная",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=qGdV5YOmtrs&t=450s",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 450,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4263,
    question: "Чем ооп в js отличается от ооп в других языках",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=qGdV5YOmtrs&t=710s",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 710,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4266,
    question:
      "В чем заключается отличие классов в js от классов в других языках",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=qGdV5YOmtrs&t=780s",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 780,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4269,
    question: "Как бы добавлял статический метод в prototype",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=qGdV5YOmtrs&t=1000s",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 1000,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4272,
    question: "Как сделать какое либо свойство объекта неизменяемым",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=qGdV5YOmtrs&t=1025s",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 1025,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4274,
    question: "В чем отличие атрибутов от свойств в html тегах",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/qGdV5YOmtrs?t=1599",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 1599,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4276,
    question:
      "Как получается так что на всех элементах есть одни теже свойства(class, id, etc)",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/qGdV5YOmtrs?t=1672",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 1672,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4279,
    question: "В чем отличие .Getelementsbyclassname от .Queryselectrorall",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=qGdV5YOmtrs&t=1810s",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 1810,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4280,
    question: "Зачем нужна система контроля версий",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/qGdV5YOmtrs?t=1983",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 1983,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4282,
    question: "Как наши изменения попадают в ветку",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=qGdV5YOmtrs&t=2770s",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 2770,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4286,
    question: "Как можно заставить git что-то забыть",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=qGdV5YOmtrs&t=2930s",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 2930,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4288,
    question: "Как можно переименовать коммит",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=qGdV5YOmtrs&t=2975s",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 2975,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4292,
    question: "В чем отличие amend от squash",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=qGdV5YOmtrs&t=3175s",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 3175,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4294,
    question: "Что такое cherry-pick",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=qGdV5YOmtrs&t=3245s",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 3245,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4298,
    question: "Что такое семантические коммиты",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=qGdV5YOmtrs&t=3320s",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 3320,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4301,
    question: "Зачем вообще что то оптимизировать",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=qGdV5YOmtrs&t=3740s",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 3740,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4317,
    question: "Что такое force layout и почему это плохо",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=qGdV5YOmtrs&t=4050s",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 4050,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4320,
    question: "Как мы будем через js анимировать что либо",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/qGdV5YOmtrs?t=4113",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 4113,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4323,
    question: "Утечки памяти, что это такое и почему плохо",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/qGdV5YOmtrs?t=4462",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 4462,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4325,
    question: "Как происходит процесс утечки",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=qGdV5YOmtrs&t=4500s",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 4500,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4328,
    question: "Мы можем повлиять на сборку мусора",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=qGdV5YOmtrs&t=4565s",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 4565,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4331,
    question: "Как исправить утечку памяти",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=qGdV5YOmtrs&t=4605s",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 4605,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4334,
    question: "Что такое компонент",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/qGdV5YOmtrs?t=4848",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 4848,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4337,
    question: "Зачем мы разбиваем код на компоненты",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=qGdV5YOmtrs&t=4910s",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 4910,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4339,
    question: "Как определить что состояние является глобальным",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/qGdV5YOmtrs?t=5575",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 5575,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4342,
    question:
      "Почему нельзя использовать контекст в качестве хранилища состояния",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/qGdV5YOmtrs?t=5756",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 5756,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4343,
    question: "Почему react не реактивный",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=qGdV5YOmtrs&t=5865s",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 5865,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4344,
    question: "Что такое двустороннее и однонаправленное связывание данных",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=qGdV5YOmtrs&t=6278s",
        title: "#4 Настоящий мидл? Собеседование на …",
        time: 6278,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4345,
    question: "Расскажи про типы операторов",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=k0dAETyBPvU&t=1005s",
        title: "#8 Маркетолог ушел на фронт. Собесед…",
        time: 1005,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4346,
    question: "Чем spa отличается от классического сайта",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/k0dAETyBPvU?t=1747",
        title: "#8 Маркетолог ушел на фронт. Собесед…",
        time: 1747,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4631,
    question: "Зачем нам разбивать приложение отдельно на backend и frontend",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=k0dAETyBPvU&t=1830s",
        title: "#8 Маркетолог ушел на фронт. Собесед…",
        time: 1830,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4632,
    question: "Как работает http",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=k0dAETyBPvU&t=2000s",
        title: "#8 Маркетолог ушел на фронт. Собесед…",
        time: 2000,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4634,
    question: "Что дает https помимо шифрования",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=k0dAETyBPvU&t=2760s",
        title: "#8 Маркетолог ушел на фронт. Собесед…",
        time: 2760,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4636,
    question: "Как мы можем ускорить загрузку ресурсов",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/k0dAETyBPvU?t=5053",
        title: "#8 Маркетолог ушел на фронт. Собесед…",
        time: 5053,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4674,
    question: "Как исправить ситуацию когда база разрослась и база тормозит",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/SR7S5NeJ_JY?t=1464",
        title: "#18 Сеньор в 23? Собеседование Middl…",
        time: 1464,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4675,
    question:
      "Что делать когда база стала слишком жирной и отчет создается очень долго,а нужен сейчас",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=SR7S5NeJ_JY&t=1860s",
        title: "#18 Сеньор в 23? Собеседование Middl…",
        time: 1860,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4677,
    question: "Куда будем складывать отчеты",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=SR7S5NeJ_JY&t=2230s",
        title: "#18 Сеньор в 23? Собеседование Middl…",
        time: 2230,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4678,
    question: "Как бы спроектировал запрос базы данных без orm",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/SR7S5NeJ_JY?t=2261",
        title: "#18 Сеньор в 23? Собеседование Middl…",
        time: 2261,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4680,
    question: "Что делать если один и тот же отчет запросили много раз",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/SR7S5NeJ_JY?t=2482",
        title: "#18 Сеньор в 23? Собеседование Middl…",
        time: 2482,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4681,
    question:
      "Разным ролям нужно по разному предоставить dataset ,как бы это сделал",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/SR7S5NeJ_JY?t=2746",
        title: "#18 Сеньор в 23? Собеседование Middl…",
        time: 2746,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4682,
    question: "Что если получение отчетов отложенное",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/SR7S5NeJ_JY?t=3067",
        title: "#18 Сеньор в 23? Собеседование Middl…",
        time: 3067,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4684,
    question: "Почему c#",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=SR7S5NeJ_JY&t=3270s",
        title: "#18 Сеньор в 23? Собеседование Middl…",
        time: 3270,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4685,
    question: "Помимо ютуба какими источниками информации пользуешься",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/SR7S5NeJ_JY?t=3429",
        title: "#18 Сеньор в 23? Собеседование Middl…",
        time: 3429,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4686,
    question: "Как докатился до cqrs",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=SR7S5NeJ_JY&t=3480s",
        title: "#18 Сеньор в 23? Собеседование Middl…",
        time: 3480,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4687,
    question: "Что интересно во фронтенде",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=1Ej0Wx2TkSs&t=260s",
        title: "#16 Собеседование Senior Frontend ра…",
        time: 260,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4688,
    question: "Что думаешь насчет stackblitz",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/1Ej0Wx2TkSs?t=1323",
        title: "#16 Собеседование Senior Frontend ра…",
        time: 1323,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4689,
    question: "Что будет если забиндить два контекста подряд",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/1Ej0Wx2TkSs?t=5372",
        title: "#16 Собеседование Senior Frontend ра…",
        time: 5372,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4696,
    question: "Почему асинхронность это важно",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=1Ej0Wx2TkSs&t=5460s",
        title: "#16 Собеседование Senior Frontend ра…",
        time: 5460,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4697,
    question: "Какие есть проблемы у di",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/1Ej0Wx2TkSs?t=7264",
        title: "#16 Собеседование Senior Frontend ра…",
        time: 7264,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4698,
    question: "Как вам живется с таким большим монорепозиторием",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=NnN4jq2lfGI&t=430s",
        title: "#14 Собеседование Senior Frontend ра…",
        time: 430,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4699,
    question: "Что вызывает трудности на работе",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=NnN4jq2lfGI&t=982s",
        title: "#14 Собеседование Senior Frontend ра…",
        time: 982,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4701,
    question: "Что не нравится в angular",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=NnN4jq2lfGI&t=1251s",
        title: "#14 Собеседование Senior Frontend ра…",
        time: 1251,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4702,
    question: "Какие есть альтернативы ssr",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=NnN4jq2lfGI&t=2365s",
        title: "#14 Собеседование Senior Frontend ра…",
        time: 2365,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4704,
    question: "Когда без ssr не обойтись",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=NnN4jq2lfGI&t=2562s",
        title: "#14 Собеседование Senior Frontend ра…",
        time: 2562,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4706,
    question: "Что такое amp страницы",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/NnN4jq2lfGI?t=2812",
        title: "#14 Собеседование Senior Frontend ра…",
        time: 2812,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4707,
    question: "Каким сайтам может быть полезно amp",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=NnN4jq2lfGI&t=2860s",
        title: "#14 Собеседование Senior Frontend ра…",
        time: 2860,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4709,
    question: "В каких случаях на проект стоит брать typescript",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/NnN4jq2lfGI?t=3387",
        title: "#14 Собеседование Senior Frontend ра…",
        time: 3387,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4710,
    question: "Что думаешь про jsdoc как альтернатива typescript",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=NnN4jq2lfGI&t=3457s",
        title: "#14 Собеседование Senior Frontend ра…",
        time: 3457,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4712,
    question: "Какой современный тулинг используешь",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=NnN4jq2lfGI&t=4205s",
        title: "#14 Собеседование Senior Frontend ра…",
        time: 4205,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4713,
    question: "Когда нужно использовать типы, а когда интерфейсы",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=NnN4jq2lfGI&t=4420s",
        title: "#14 Собеседование Senior Frontend ра…",
        time: 4420,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4714,
    question: "Какие знаешь способы оптимизации релайаута",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=NnN4jq2lfGI&t=4583s",
        title: "#14 Собеседование Senior Frontend ра…",
        time: 4583,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4716,
    question: "Почему у нас в css нет селектора на родителе",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=NnN4jq2lfGI&t=5080s",
        title: "#14 Собеседование Senior Frontend ра…",
        time: 5080,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4717,
    question: "Какие достоинства у инкрементального  dom против виртуального",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=NnN4jq2lfGI&t=5480s",
        title: "#14 Собеседование Senior Frontend ра…",
        time: 5480,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4719,
    question: "Как стал мейнтейнром phatomjs",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=x7HRQkrWz6Y&t=210s",
        title: "#10 Собеседование Frontend Senior ра…",
        time: 210,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4721,
    question: "Ошибка которая больше всего запомнилась",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/x7HRQkrWz6Y?t=803",
        title: "#10 Собеседование Frontend Senior ра…",
        time: 803,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4722,
    question: "Самая большая боль на текущей работе",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=x7HRQkrWz6Y&t=975s",
        title: "#10 Собеседование Frontend Senior ра…",
        time: 975,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4724,
    question: "Какие возникнут сложности если придется менять работу",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=x7HRQkrWz6Y&t=1480s",
        title: "#10 Собеседование Frontend Senior ра…",
        time: 1480,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4726,
    question: "Как правильно выбрать фреймворк",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/x7HRQkrWz6Y?t=1822",
        title: "#10 Собеседование Frontend Senior ра…",
        time: 1822,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4728,
    question: "Как понять что у тебя кровавый энтерпрайз",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=x7HRQkrWz6Y&t=2090s",
        title: "#10 Собеседование Frontend Senior ра…",
        time: 2090,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4730,
    question: "Как убедить разработчиков взять angular",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=x7HRQkrWz6Y&t=2150s",
        title: "#10 Собеседование Frontend Senior ра…",
        time: 2150,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4731,
    question: "Зачем переписывать легаси на новые технологии",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=x7HRQkrWz6Y&t=2360s",
        title: "#10 Собеседование Frontend Senior ра…",
        time: 2360,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4738,
    question: "В каком случае нужно spa",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/x7HRQkrWz6Y?t=2560",
        title: "#10 Собеседование Frontend Senior ра…",
        time: 2560,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4739,
    question: "Как определить  что у тебя микрофронтенды",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/x7HRQkrWz6Y?t=4251",
        title: "#10 Собеседование Frontend Senior ра…",
        time: 4251,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4741,
    question: "Какие плюсы и минусы есть у bff (backend for frontend)",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=x7HRQkrWz6Y&t=3280s",
        title: "#10 Собеседование Frontend Senior ра…",
        time: 3280,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4742,
    question: "Что лучше использовать rest или graphql",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/x7HRQkrWz6Y?t=4921",
        title: "#10 Собеседование Frontend Senior ра…",
        time: 4921,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4744,
    question: "Как должен выглядеть идеальный tdd",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/x7HRQkrWz6Y?t=5640",
        title: "#10 Собеседование Frontend Senior ра…",
        time: 5640,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4745,
    question: "Какие возникали сложности на пути к разработке",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/qika0TkDFz4?t=428",
        title: "#7 Первое собеседование Junior Front…",
        time: 428,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4746,
    question: "Как работаешь с формами в spa",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/qika0TkDFz4?t=618",
        title: "#7 Первое собеседование Junior Front…",
        time: 618,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4748,
    question: "Как очистить форму",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=qika0TkDFz4&t=720s",
        title: "#7 Первое собеседование Junior Front…",
        time: 720,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4749,
    question: "Зачем нам нужен механизм двустороннего связывания",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=qika0TkDFz4&t=840s",
        title: "#7 Первое собеседование Junior Front…",
        time: 840,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4751,
    question: "В чем заключались проблемы со сбросом формы",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=qika0TkDFz4&t=1040s",
        title: "#7 Первое собеседование Junior Front…",
        time: 1040,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4752,
    question: "Расскажи про пробелы в html",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=qika0TkDFz4&t=1260s",
        title: "#7 Первое собеседование Junior Front…",
        time: 1260,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4754,
    question: "Чем отличается блочный от инлайнового элемента",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/qika0TkDFz4?t=2447",
        title: "#7 Первое собеседование Junior Front…",
        time: 2447,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4755,
    question: "Как растянуть элемент на 100%",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=qika0TkDFz4&t=2630s",
        title: "#7 Первое собеседование Junior Front…",
        time: 2630,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4757,
    question: "Как сбросить фон у элемента",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/qika0TkDFz4?t=3806",
        title: "#7 Первое собеседование Junior Front…",
        time: 3806,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4758,
    question: "Как найти все скрытые элементы на странице",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=qika0TkDFz4&t=4100s",
        title: "#7 Первое собеседование Junior Front…",
        time: 4100,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4760,
    question: "Как выполнить действие когда произошел скролл до нужного места",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=qika0TkDFz4&t=4610s",
        title: "#7 Первое собеседование Junior Front…",
        time: 4610,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4761,
    question: "Откуда у примитива появляются методы (.Tosting(), etc...)",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/3D0IVhYzXJM?t=2311",
        title: "#2 Собеседование смелого Frontend Mi…",
        time: 2311,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4762,
    question: "Как можно запретить изменение объекта",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/3D0IVhYzXJM?t=2364",
        title: "#2 Собеседование смелого Frontend Mi…",
        time: 2364,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4764,
    question: "В чем разница циклов for .. In и for .. Of",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=3D0IVhYzXJM&t=2445s",
        title: "#2 Собеседование смелого Frontend Mi…",
        time: 2445,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4765,
    question:
      "Какие параметры могут повлиять на скорость загрузки контента для пользователя",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=3D0IVhYzXJM&t=3390s",
        title: "#2 Собеседование смелого Frontend Mi…",
        time: 3390,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4767,
    question:
      "Как мы можем подсказать браузеру подготовиться к загрузке ресурсов",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=3D0IVhYzXJM&t=3750s",
        title: "#2 Собеседование смелого Frontend Mi…",
        time: 3750,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4768,
    question: "Как браузер понимает что ресурс нужно закешировать",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=3D0IVhYzXJM&t=4163s",
        title: "#2 Собеседование смелого Frontend Mi…",
        time: 4163,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4770,
    question: "Зачем нужен хеш в названиях файлов (на примере vue cli)",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/3D0IVhYzXJM?t=4362",
        title: "#2 Собеседование смелого Frontend Mi…",
        time: 4362,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4772,
    question: "Как работает hot reload (на примере vue cli)",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/3D0IVhYzXJM?t=4650",
        title: "#2 Собеседование смелого Frontend Mi…",
        time: 4650,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4781,
    question:
      "С какими проблемами сталкивался при подключении кастомных шрифтов",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/3D0IVhYzXJM?t=4756",
        title: "#2 Собеседование смелого Frontend Mi…",
        time: 4756,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4783,
    question:
      "Многочисленное присваивание значения в data подряд будет вызывать ререндер",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=3D0IVhYzXJM&t=5575s",
        title: "#2 Собеседование смелого Frontend Mi…",
        time: 5575,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4785,
    question: "Сколько стажировался",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=lrdaRbJctaA&t=242s",
        title: "Frontend интервью. Ильнура, первая р…",
        time: 242,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4790,
    question: "Как начал работать",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=lrdaRbJctaA&t=312s",
        title: "Frontend интервью. Ильнура, первая р…",
        time: 312,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4791,
    question: "Как с английским",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/lrdaRbJctaA?t=533",
        title: "Frontend интервью. Ильнура, первая р…",
        time: 533,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4793,
    question: "Когда лучше использовать id а когда class",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/lrdaRbJctaA?t=617",
        title: "Frontend интервью. Ильнура, первая р…",
        time: 617,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4794,
    question: "В чем разница стилей с селектором id и класса",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=lrdaRbJctaA&t=786s",
        title: "Frontend интервью. Ильнура, первая р…",
        time: 786,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4795,
    question: "Какя разница между различными видами позиционирования элементов",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=lrdaRbJctaA&t=821s",
        title: "Frontend интервью. Ильнура, первая р…",
        time: 821,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4797,
    question: "Какие свойства media отличные от screen знаешь",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/lrdaRbJctaA?t=1030",
        title: "Frontend интервью. Ильнура, первая р…",
        time: 1030,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4799,
    question: "Как можно сверстать стрелочку",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/lrdaRbJctaA?t=1585",
        title: "Frontend интервью. Ильнура, первая р…",
        time: 1585,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4800,
    question: "Как удалить обработчик события",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/lrdaRbJctaA?t=1782",
        title: "Frontend интервью. Ильнура, первая р…",
        time: 1782,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4802,
    question: "В чём разница между object.Getownpropertynames и object.Keys",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/lrdaRbJctaA?t=2813",
        title: "Frontend интервью. Ильнура, первая р…",
        time: 2813,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4804,
    question: "Для чего нужен package-lock.Json",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=lrdaRbJctaA&t=4478s",
        title: "Frontend интервью. Ильнура, первая р…",
        time: 4478,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4805,
    question: "Чем отличаются put и post запросы",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=lrdaRbJctaA&t=4400s",
        title: "Frontend интервью. Ильнура, первая р…",
        time: 4400,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4807,
    question: "Что такое staging area в git",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=lrdaRbJctaA&t=4722s",
        title: "Frontend интервью. Ильнура, первая р…",
        time: 4722,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4809,
    question: "Как изучал верстку",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ktdN2upYX1I?t=279",
        title: "Стать фронтендером после 30: из рабо…",
        time: 279,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4810,
    question: "Если нужно повернуть элемент на 45 градусов,как бы это сделал",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ktdN2upYX1I?t=711",
        title: "Стать фронтендером после 30: из рабо…",
        time: 711,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4812,
    question: "В чем разница между flex и grid",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ktdN2upYX1I?t=767",
        title: "Стать фронтендером после 30: из рабо…",
        time: 767,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4814,
    question: "Как сделать сайт responsive",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ktdN2upYX1I?t=943",
        title: "Стать фронтендером после 30: из рабо…",
        time: 943,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4816,
    question: "Чем em отличается от rem",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=ktdN2upYX1I&t=992s",
        title: "Стать фронтендером после 30: из рабо…",
        time: 992,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4817,
    question:
      "Как сделать чтобы изображение грузилась  маленького размера на мобильных",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ktdN2upYX1I?t=1072",
        title: "Стать фронтендером после 30: из рабо…",
        time: 1072,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4818,
    question: "Как можно проверить что число nan",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ktdN2upYX1I?t=1153",
        title: "Стать фронтендером после 30: из рабо…",
        time: 1153,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4820,
    question: "Каким образом можно проверить что число целое",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ktdN2upYX1I?t=1208",
        title: "Стать фронтендером после 30: из рабо…",
        time: 1208,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4822,
    question: "Как поменять значения двух переменных местами",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ktdN2upYX1I?t=1567",
        title: "Стать фронтендером после 30: из рабо…",
        time: 1567,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4829,
    question: "В чем основная разница между slice и splice",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ktdN2upYX1I?t=1904",
        title: "Стать фронтендером после 30: из рабо…",
        time: 1904,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4830,
    question: "Как отсортировать массив чисел по возрастанию",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ktdN2upYX1I?t=2085",
        title: "Стать фронтендером после 30: из рабо…",
        time: 2085,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4832,
    question: "Как узнать что объект пустой",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ktdN2upYX1I?t=2443",
        title: "Стать фронтендером после 30: из рабо…",
        time: 2443,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4833,
    question: "Что делает метод freeze",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ktdN2upYX1I?t=2924",
        title: "Стать фронтендером после 30: из рабо…",
        time: 2924,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4835,
    question: "Как поменять порядок элементов массива",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ktdN2upYX1I?t=3092",
        title: "Стать фронтендером после 30: из рабо…",
        time: 3092,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4837,
    question: "Что делает spread оператор со строкой",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ktdN2upYX1I?t=3536",
        title: "Стать фронтендером после 30: из рабо…",
        time: 3536,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4838,
    question: "Каким способом можно удалить все дубликаты из массива",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ktdN2upYX1I?t=3727",
        title: "Стать фронтендером после 30: из рабо…",
        time: 3727,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4840,
    question: "Как удалить все элементы с массива",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ktdN2upYX1I?t=3863",
        title: "Стать фронтендером после 30: из рабо…",
        time: 3863,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4842,
    question: "Как отсортировать в массиве только нечетные числа",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/ktdN2upYX1I?t=3946",
        title: "Стать фронтендером после 30: из рабо…",
        time: 3946,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4844,
    question: "Какого рода проекты приходилось делать на next.Js",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/HCXDrVikPGk?t=520",
        title: "Собеседование на Middle Frontend раз…",
        time: 520,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4846,
    question: "Какой был опыт работы с backend",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/HCXDrVikPGk?t=590",
        title: "Собеседование на Middle Frontend раз…",
        time: 590,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4849,
    question: "Что понимаешь под http запросом options",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/HCXDrVikPGk?t=4209",
        title: "Собеседование на Middle Frontend раз…",
        time: 4209,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4851,
    question: "Что такое cdn",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/HCXDrVikPGk?t=4265",
        title: "Собеседование на Middle Frontend раз…",
        time: 4265,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4852,
    question: "Для чего нужен cdn",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/HCXDrVikPGk?t=4266",
        title: "Собеседование на Middle Frontend раз…",
        time: 4266,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4854,
    question: "Расскажи про отдельные домены для статики",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/HCXDrVikPGk?t=4378",
        title: "Собеседование на Middle Frontend раз…",
        time: 4378,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4898,
    question: "Расскажи о своих знаниях в js",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/BOCkaqdbdCg?t=175",
        title: "Собеседование на Junior Frontend раз…",
        time: 175,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4899,
    question: "Какие были фриланc заказы связанные с js",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/BOCkaqdbdCg?t=224",
        title: "Собеседование на Junior Frontend раз…",
        time: 224,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4900,
    question: "Какого рода обязанности выполняешь во время стажировки",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/BOCkaqdbdCg?t=258",
        title: "Собеседование на Junior Frontend раз…",
        time: 258,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4901,
    question: "В чем разница между div и span",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=BOCkaqdbdCg&t=828s",
        title: "Собеседование на Junior Frontend раз…",
        time: 828,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4902,
    question: "Что такое inline-block",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=BOCkaqdbdCg&t=874s",
        title: "Собеседование на Junior Frontend раз…",
        time: 874,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4903,
    question: "Что выведется в консоли ,если приписать this в console.Log",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/BOCkaqdbdCg?t=1822",
        title: "Собеседование на Junior Frontend раз…",
        time: 1822,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4904,
    question: "Как проверить что объект это массив",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=BOCkaqdbdCg&t=1966s",
        title: "Собеседование на Junior Frontend раз…",
        time: 1966,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4905,
    question: "Для чего нужны логические операторы && и ||",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/BOCkaqdbdCg?t=2132",
        title: "Собеседование на Junior Frontend раз…",
        time: 2132,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4906,
    question: "Откуда черпаешь новые знания",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/BOCkaqdbdCg?t=4044",
        title: "Собеседование на Junior Frontend раз…",
        time: 4044,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4907,
    question: "Как попал в unit city",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/wP7XVriACtA?t=668",
        title: "Frontend Собеседование на Junior раз…",
        time: 668,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4908,
    question: "Разница между подключением скриптов async и defer",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/wP7XVriACtA?t=861",
        title: "Frontend Собеседование на Junior раз…",
        time: 861,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4909,
    question: "Какие перебирающие методы массивов знаешь",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/wP7XVriACtA?t=1553",
        title: "Frontend Собеседование на Junior раз…",
        time: 1553,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4910,
    question: "В чем кардинальная разница между for и foreach",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/wP7XVriACtA?t=1632",
        title: "Frontend Собеседование на Junior раз…",
        time: 1632,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4911,
    question: "Когда стоит использовать метод reduce",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/wP7XVriACtA?t=1970",
        title: "Frontend Собеседование на Junior раз…",
        time: 1970,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4912,
    question: "В чем плюсы ssr",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/wP7XVriACtA?t=3815",
        title: "Frontend Собеседование на Junior раз…",
        time: 3815,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4913,
    question: "Какие в http есть заголовки которые отвечают за кеширование",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/wP7XVriACtA?t=4161",
        title: "Frontend Собеседование на Junior раз…",
        time: 4161,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4914,
    question: "Как поставить cookies-файл так,чтобы он удалились через 3 дня",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/wP7XVriACtA?t=4249",
        title: "Frontend Собеседование на Junior раз…",
        time: 4249,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4915,
    question: "Какие поля в cookies есть,отвечающие за security",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/wP7XVriACtA?t=4312",
        title: "Frontend Собеседование на Junior раз…",
        time: 4312,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4916,
    question: "Какого рода проекты в этой компании делаешь",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=331",
        title: "Первое интервью фронтендера самоучки…",
        time: 331,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4917,
    question: "Как долго работаешь в этой компании",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=333",
        title: "Первое интервью фронтендера самоучки…",
        time: 333,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4918,
    question: "Какая команда в проектах",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=336",
        title: "Первое интервью фронтендера самоучки…",
        time: 336,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4919,
    question: "Что изучал в js",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=455",
        title: "Первое интервью фронтендера самоучки…",
        time: 455,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4920,
    question: "Какими способами изучал js",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=456",
        title: "Первое интервью фронтендера самоучки…",
        time: 456,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4921,
    question: "Когда начал заниматься codewars",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=697",
        title: "Первое интервью фронтендера самоучки…",
        time: 697,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4922,
    question: "Какие книги по js изучал",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=727",
        title: "Первое интервью фронтендера самоучки…",
        time: 727,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4923,
    question: "Какой опыт работы был с bem",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=1081",
        title: "Первое интервью фронтендера самоучки…",
        time: 1081,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4924,
    question: "Расскажи про систему сборки проектов",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=1167",
        title: "Первое интервью фронтендера самоучки…",
        time: 1167,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4925,
    question: "Расскажи про опыт в вёрстке",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=1211",
        title: "Первое интервью фронтендера самоучки…",
        time: 1211,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4926,
    question: "Расскажи про опыт работы с анимациями",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=1296",
        title: "Первое интервью фронтендера самоучки…",
        time: 1296,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4927,
    question: "Почему оператор называется тернарным",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=1383",
        title: "Первое интервью фронтендера самоучки…",
        time: 1383,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4928,
    question: "В каких случаях используются array.Foreach и array.Map",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=1678",
        title: "Первое интервью фронтендера самоучки…",
        time: 1678,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4929,
    question: "Как понять, что в переменной находится массив",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=2120",
        title: "Первое интервью фронтендера самоучки…",
        time: 2120,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4930,
    question: "Как удалить eventlistener",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=2278",
        title: "Первое интервью фронтендера самоучки…",
        time: 2278,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4931,
    question:
      "Как с помощью js можно передвигать вперед/назад по истории браузера",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=2363",
        title: "Первое интервью фронтендера самоучки…",
        time: 2363,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4932,
    question: "Как получить текущий url страницы",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=2409",
        title: "Первое интервью фронтендера самоучки…",
        time: 2409,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4933,
    question: "Как заредиректить пользователя на url",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=2453",
        title: "Первое интервью фронтендера самоучки…",
        time: 2453,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4934,
    question: "В чём разница между spread и rest операторами",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=2484",
        title: "Первое интервью фронтендера самоучки…",
        time: 2484,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4935,
    question: "Для чего используются spread и rest операторы",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=2492",
        title: "Первое интервью фронтендера самоучки…",
        time: 2492,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4936,
    question: "Что такое promise.All",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=3076",
        title: "Первое интервью фронтендера самоучки…",
        time: 3076,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4937,
    question: "Как поставить cookie в браузере",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/8Xuftz2IiAI?t=5105",
        title: "Первое интервью фронтендера самоучки…",
        time: 5105,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4938,
    question: "Расскажи про последний проект, над которым ты работал",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=176",
        title: "Собеседование cтажера Frontend разра…",
        time: 176,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4939,
    question: "Что произойдёт, если написать typeof null",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=520",
        title: "Собеседование cтажера Frontend разра…",
        time: 520,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4940,
    question: "Какими способами можно изменить контекст объекта",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=987",
        title: "Собеседование cтажера Frontend разра…",
        time: 987,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4941,
    question: "Что такое массив arguments",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=1510",
        title: "Собеседование cтажера Frontend разра…",
        time: 1510,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4942,
    question:
      "В каком случае важен порядок: при копировании объекта или массива",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=1625",
        title: "Собеседование cтажера Frontend разра…",
        time: 1625,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4943,
    question: "Что такое методы массива",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=1658",
        title: "Собеседование cтажера Frontend разра…",
        time: 1658,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4944,
    question: "В каких случаях лучше использовать map",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=1763",
        title: "Собеседование cтажера Frontend разра…",
        time: 1763,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4945,
    question: "В каких случаях лучше использовать foreach",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=1766",
        title: "Собеседование cтажера Frontend разра…",
        time: 1766,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4946,
    question: "Какой способ изменяет массив",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=1826",
        title: "Собеседование cтажера Frontend разра…",
        time: 1826,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4947,
    question: "Какие инструменты используешь при взаимодействии с сервером",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=1998",
        title: "Собеседование cтажера Frontend разра…",
        time: 1998,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4948,
    question: "Какие статусы есть у promise",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=2061",
        title: "Собеседование cтажера Frontend разра…",
        time: 2061,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4949,
    question: "Что использовали до promise",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=2183",
        title: "Собеседование cтажера Frontend разра…",
        time: 2183,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4950,
    question:
      "Кому видны данные, хранящиеся в local storage, session storage и cookies",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=2592",
        title: "Собеседование cтажера Frontend разра…",
        time: 2592,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4951,
    question: "В каком формате хранятся данные в local storage",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=2685",
        title: "Собеседование cтажера Frontend разра…",
        time: 2685,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4952,
    question: "Для чего нужен react",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=2709",
        title: "Собеседование cтажера Frontend разра…",
        time: 2709,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4953,
    question: "Какие преимущества есть у react",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=2737",
        title: "Собеседование cтажера Frontend разра…",
        time: 2737,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4954,
    question: "Как можно использовать в рамках jsx js код",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=2790",
        title: "Собеседование cтажера Frontend разра…",
        time: 2790,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4955,
    question: "Что не допускается писать в js коде в рамках jsx",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=2829",
        title: "Собеседование cтажера Frontend разра…",
        time: 2829,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4956,
    question: "Что можно использовать при написании js кода в рамках jsx",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=2862",
        title: "Собеседование cтажера Frontend разра…",
        time: 2862,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4957,
    question: "Какой тип данных представляет из себя virtual dom в js",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=2911",
        title: "Собеседование cтажера Frontend разра…",
        time: 2911,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4958,
    question: "Почему нельзя напрямую использовать браузерный dom",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=2953",
        title: "Собеседование cтажера Frontend разра…",
        time: 2953,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4959,
    question: "Что такое state и props",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=2990",
        title: "Собеседование cтажера Frontend разра…",
        time: 2990,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4960,
    question: "Как нужно изменять состояние компонентов",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=3012",
        title: "Собеседование cтажера Frontend разра…",
        time: 3012,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4961,
    question: "Что возвращает usestate",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=3074",
        title: "Собеседование cтажера Frontend разра…",
        time: 3074,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4962,
    question: "В чём находятся значения функции",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=3078",
        title: "Собеседование cтажера Frontend разра…",
        time: 3078,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4963,
    question: "Что такое useeffect",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=3088",
        title: "Собеседование cтажера Frontend разра…",
        time: 3088,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4964,
    question: "Что можно использовать в useeffect",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=3104",
        title: "Собеседование cтажера Frontend разра…",
        time: 3104,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4965,
    question: "Для чего указывается массив зависимостей",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=3115",
        title: "Собеседование cтажера Frontend разра…",
        time: 3115,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4966,
    question:
      "Приведи примеры того, что можно использовать в useeffect, помимо запросов на сервер",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=3138",
        title: "Собеседование cтажера Frontend разра…",
        time: 3138,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4967,
    question: "Что такое побочные эффекты",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=3164",
        title: "Собеседование cтажера Frontend разра…",
        time: 3164,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4968,
    question: "Как работаешь со списками",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=3295",
        title: "Собеседование cтажера Frontend разра…",
        time: 3295,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4969,
    question: "Что используется для отображения списка данных в jsx",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=3304",
        title: "Собеседование cтажера Frontend разра…",
        time: 3304,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4970,
    question: "Для чего используются ключи в jsx",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=3313",
        title: "Собеседование cтажера Frontend разра…",
        time: 3313,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4971,
    question: "Какие есть ключи в jsx",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=3310",
        title: "Собеседование cтажера Frontend разра…",
        time: 3310,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4972,
    question: "Расскажи про упрявляемые и неуправляемые компоненты",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=3360",
        title: "Собеседование cтажера Frontend разра…",
        time: 3360,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4973,
    question: "Как работает поток данных между redux и компонентом",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=3479",
        title: "Собеседование cтажера Frontend разра…",
        time: 3479,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4974,
    question: "Как можно изменить состояние в redux",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=3488",
        title: "Собеседование cтажера Frontend разра…",
        time: 3488,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4975,
    question: "Какой способ помогает бороться с прокидыванием, помимо redux",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/FrP3AGanqX0?t=3542",
        title: "Собеседование cтажера Frontend разра…",
        time: 3542,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4976,
    question: "Что такое переменная",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/KvPUlwkSs_E?t=193",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 193,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4977,
    question: "Что такое константа",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/KvPUlwkSs_E?t=222",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 222,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4978,
    question: "Что такое массив",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/KvPUlwkSs_E?t=302",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 302,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4979,
    question: "Какая цель у оператора присваивания",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/KvPUlwkSs_E?t=377",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 377,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4980,
    question: "Как происходит взаимодействие клиентов и сервера",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/KvPUlwkSs_E?t=401",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 401,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4981,
    question: "Что такое область видимости",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/KvPUlwkSs_E?t=536",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 536,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4982,
    question: "Сколько может длиться тех собеседование",
    explanation: "",
    videos: [
      {
        url: "https://www.youtube.com/watch?v=KvPUlwkSs_E&t=701s",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 701,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4983,
    question: "Что такое json",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/KvPUlwkSs_E?t=825",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 825,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4984,
    question: "Какие числовые значения имеют true/false",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/KvPUlwkSs_E?t=1203",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 1203,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4985,
    question: "Как преобразуется строка в число",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/KvPUlwkSs_E?t=1249",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 1249,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4986,
    question: "Что такое singleton",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/KvPUlwkSs_E?t=1422",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 1422,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4987,
    question: "Что такое классы",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/KvPUlwkSs_E?t=1456",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 1456,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4988,
    question: "Что такое паттерны проектирования",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/KvPUlwkSs_E?t=1540",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 1540,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4989,
    question: "Что такое debug",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/KvPUlwkSs_E?t=1865",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 1865,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4990,
    question: "Как стал it специалистом",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/OzLjBPjsGgg?t=101",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 101,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4991,
    question:
      "Как решить проблему несовместимости некоторых css-cвойств в браузере",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/OzLjBPjsGgg?t=711",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 711,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4992,
    question: "Когда используются теги div и span",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/OzLjBPjsGgg?t=1070",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 1070,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4993,
    question: "Расскажи про частный случай - settimeout 0",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/OzLjBPjsGgg?t=1638",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 1638,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4994,
    question: "Назови основные методы перебора массивов и объектов",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/OzLjBPjsGgg?t=1761",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 1761,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4995,
    question: "Какая ключевая особенность react-рендера",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/OzLjBPjsGgg?t=2020",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 2020,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4996,
    question: "Для чего в react используется react-router-dom",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/OzLjBPjsGgg?t=2135",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 2135,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4997,
    question: "Что такое spa",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/OzLjBPjsGgg?t=2451",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 2451,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4998,
    question: "Что такое сrud и его параметры запроса",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/OzLjBPjsGgg?t=2780",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 2780,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 4999,
    question: "Какие типы данных  поддерживаются в typescript",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/OzLjBPjsGgg?t=3054",
        title: "FRONT-END РАЗРАБОТЧИК: Как пройти СО…",
        time: 3054,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5000,
    question: "Как происходит загрузка страницы",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=192",
        title: "Public interview for Frontend/HTML/C…",
        time: 192,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5001,
    question: "Как браузер парсит html файл",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=280",
        title: "Public interview for Frontend/HTML/C…",
        time: 280,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5002,
    question:
      "Что происходит с внешними ресурсами который считывает браузер при парсинге html",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=320",
        title: "Public interview for Frontend/HTML/C…",
        time: 320,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5003,
    question: "Что такое метатеги и для чего они нужны",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=477",
        title: "Public interview for Frontend/HTML/C…",
        time: 477,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5004,
    question: "Какие внесли новые теги в html5 и какие теги устарели",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=632",
        title: "Public interview for Frontend/HTML/C…",
        time: 632,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5005,
    question: "Что такое screen reader и аccessibility",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=745",
        title: "Public interview for Frontend/HTML/C…",
        time: 745,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5006,
    question: "Для чего нужна методология в html",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=1332",
        title: "Public interview for Frontend/HTML/C…",
        time: 1332,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5007,
    question: "Какие бывают css unity",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=3439",
        title: "Public interview for Frontend/HTML/C…",
        time: 3439,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5008,
    question: "Какие популярные форматы картинок используются в веб-верстке",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=2518",
        title: "Public interview for Frontend/HTML/C…",
        time: 2518,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5009,
    question: "Как оптимизировать загрузку картинок на странице",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=2549",
        title: "Public interview for Frontend/HTML/C…",
        time: 2549,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5010,
    question: "Что лучше использовать шрифт svg или sprite",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=2640",
        title: "Public interview for Frontend/HTML/C…",
        time: 2640,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5011,
    question: "Опиши псевдоклассы и псевдоэлементы",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=3309",
        title: "Public interview for Frontend/HTML/C…",
        time: 3309,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5012,
    question:
      "Что такое боксовая модель, из чего она состоит, и какие бывают виды",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=3872",
        title: "Public interview for Frontend/HTML/C…",
        time: 3872,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5013,
    question: "Что такое margin collaps и для чего",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=4145",
        title: "Public interview for Frontend/HTML/C…",
        time: 4145,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5014,
    question: "Что такое float",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=4275",
        title: "Public interview for Frontend/HTML/C…",
        time: 4275,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5015,
    question: "Как отменить обтекание картинки текстом",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=4301",
        title: "Public interview for Frontend/HTML/C…",
        time: 4301,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5016,
    question: "Что такое поток",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=4412",
        title: "Public interview for Frontend/HTML/C…",
        time: 4412,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5017,
    question: "Почему flow плохо влияет на перформанс страницы",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=4493",
        title: "Public interview for Frontend/HTML/C…",
        time: 4493,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5018,
    question: "В чем смысл работы flex-box",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=4535",
        title: "Public interview for Frontend/HTML/C…",
        time: 4535,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5019,
    question: "Чем отличается display: block от display: inline",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=4696",
        title: "Public interview for Frontend/HTML/C…",
        time: 4696,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5020,
    question: "Что такое adaptive и responsive web-страницы",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=5407",
        title: "Public interview for Frontend/HTML/C…",
        time: 5407,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5021,
    question: "Чем отличается display: none от visibility hidden",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=4777",
        title: "Public interview for Frontend/HTML/C…",
        time: 4777,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5022,
    question: "Что такое вендорные префиксы",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=5582",
        title: "Public interview for Frontend/HTML/C…",
        time: 5582,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5023,
    question:
      "Что необходимо указать в css для срабатывания данных брэкпоинтов",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=5485",
        title: "Public interview for Frontend/HTML/C…",
        time: 5485,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5024,
    question: "Почему стали популярны препроцессоры",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=5645",
        title: "Public interview for Frontend/HTML/C…",
        time: 5645,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5025,
    question: "В чем отличие переменных в css от пременных в препроцессорах",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=5796",
        title: "Public interview for Frontend/HTML/C…",
        time: 5796,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5026,
    question: "В чем отличие импортов в css от импортов в препроцессорах",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=5726",
        title: "Public interview for Frontend/HTML/C…",
        time: 5726,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5027,
    question: "Как выбрать правильные библиотеки для подключения к проекту",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=5849",
        title: "Public interview for Frontend/HTML/C…",
        time: 5849,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5028,
    question: "Что такое код quality в html и css",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/cebz6w8o-fU?t=5974",
        title: "Public interview for Frontend/HTML/C…",
        time: 5974,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5029,
    question: "Расскажи о hexagonal архитектуре и откуда она возникла",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/d751EisK0CY?t=23",
        title: "Публичное собеседование #7 гексагона…",
        time: 23,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5030,
    question: "Что такое архитектура портов и адаптеров",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/d751EisK0CY?t=155",
        title: "Публичное собеседование #7 гексагона…",
        time: 155,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5031,
    question: "Для чего нужен адаптер",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/d751EisK0CY?t=326",
        title: "Публичное собеседование #7 гексагона…",
        time: 326,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5032,
    question: "Как вписывается graphql в гексагональную архитектуру",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/d751EisK0CY?t=439",
        title: "Публичное собеседование #7 гексагона…",
        time: 439,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5033,
    question: "Как адаптер связан с овп паттерном",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/d751EisK0CY?t=330",
        title: "Публичное собеседование #7 гексагона…",
        time: 330,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5034,
    question: "Как связан cqrs с event sourcing",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/d751EisK0CY?t=550",
        title: "Публичное собеседование #7 гексагона…",
        time: 550,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5035,
    question: "Расскажи о внедрении зависимостей",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/d751EisK0CY?t=649",
        title: "Публичное собеседование #7 гексагона…",
        time: 649,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5036,
    question: "Как из react осуществить доступ к данным",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/d751EisK0CY?t=1347",
        title: "Публичное собеседование #7 гексагона…",
        time: 1347,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5037,
    question:
      "Какие могут быть оптимизации для снижения обмена данных между front-end и сервером",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/d751EisK0CY?t=1453",
        title: "Публичное собеседование #7 гексагона…",
        time: 1453,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5038,
    question: "Людям какого возраста преподаёшь",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/9sZCii1DHOM?t=25",
        title: "Публичное собеседование #4: JavaScri…",
        time: 25,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5039,
    question: "Какой язык программирования используешь в работе",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/9sZCii1DHOM?t=35",
        title: "Публичное собеседование #4: JavaScri…",
        time: 35,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5040,
    question: "Какие языки программирования преподаёшь",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/9sZCii1DHOM?t=40",
        title: "Публичное собеседование #4: JavaScri…",
        time: 40,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5041,
    question: "В чём сходства js и python",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/9sZCii1DHOM?t=69",
        title: "Публичное собеседование #4: JavaScri…",
        time: 69,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5042,
    question: "В чём разница между js и python",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/9sZCii1DHOM?t=73",
        title: "Публичное собеседование #4: JavaScri…",
        time: 73,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5043,
    question: "Что создаёт scope переменных",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/9sZCii1DHOM?t=155",
        title: "Публичное собеседование #4: JavaScri…",
        time: 155,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5044,
    question: "Какие блоки порождают новые контексты",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/9sZCii1DHOM?t=221",
        title: "Публичное собеседование #4: JavaScri…",
        time: 221,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5045,
    question:
      "Зачем создавать самовызывающуюся функции, если есть создание контекста через фигурные скобки",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/9sZCii1DHOM?t=312",
        title: "Публичное собеседование #4: JavaScri…",
        time: 312,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5046,
    question: "С помощью чего можно рассчитать идентификатор в js",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/9sZCii1DHOM?t=655",
        title: "Публичное собеседование #4: JavaScri…",
        time: 655,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5047,
    question: "Расскажи про асинхронность в js",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/9sZCii1DHOM?t=720",
        title: "Публичное собеседование #4: JavaScri…",
        time: 720,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5048,
    question: "С какими абстракциями встречался",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/9sZCii1DHOM?t=911",
        title: "Публичное собеседование #4: JavaScri…",
        time: 911,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5049,
    question: "Почему обычные генераторы позволяют написать асинхронный код",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/9sZCii1DHOM?t=1100",
        title: "Публичное собеседование #4: JavaScri…",
        time: 1100,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5050,
    question: "Расскажи про оптимизацию рендеринга в react",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/9sZCii1DHOM?t=1186",
        title: "Публичное собеседование #4: JavaScri…",
        time: 1186,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5051,
    question: "Есть ли в react shadow dom или только virtual",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/9sZCii1DHOM?t=1398",
        title: "Публичное собеседование #4: JavaScri…",
        time: 1398,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5052,
    question: "Какие существуют способы реализации роутинга",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/9sZCii1DHOM?t=1732",
        title: "Публичное собеседование #4: JavaScri…",
        time: 1732,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5053,
    question: "С какими структурами проекта знаком",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/9sZCii1DHOM?t=1915",
        title: "Публичное собеседование #4: JavaScri…",
        time: 1915,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5054,
    question: "Какие парадигмы можно использовать на typescript",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/TakH5i5VRGk?t=32",
        title: "Публичное собеседование #3: TypeScri…",
        time: 32,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5055,
    question:
      "Чем отличается функциональное программирование на typescript от других подходов на других языках",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/TakH5i5VRGk?t=47",
        title: "Публичное собеседование #3: TypeScri…",
        time: 47,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5056,
    question:
      "Сравни паттерны которые использовал на других языках с паттернами с typescript",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/TakH5i5VRGk?t=61",
        title: "Публичное собеседование #3: TypeScri…",
        time: 61,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5057,
    question: "Чем черевато при написанни кода на типах и интерфейсах",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/TakH5i5VRGk?t=204",
        title: "Публичное собеседование #3: TypeScri…",
        time: 204,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5058,
    question: "Как мы можем порождать классы динамически в run-time",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/TakH5i5VRGk?t=321",
        title: "Публичное собеседование #3: TypeScri…",
        time: 321,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5059,
    question:
      "Как можно описать класс в typescript которые мы создаем в функции возвращая наружу",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/TakH5i5VRGk?t=358",
        title: "Публичное собеседование #3: TypeScri…",
        time: 358,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5060,
    question:
      "Каким образом необходимо восстановить объекты из json таким способом, чтобы сохранились метаданные",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/TakH5i5VRGk?t=484",
        title: "Публичное собеседование #3: TypeScri…",
        time: 484,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5061,
    question:
      "Расскажи про шаблонное проектирование которое ты использовал в разработке",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/TakH5i5VRGk?t=1059",
        title: "Публичное собеседование #3: TypeScri…",
        time: 1059,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5062,
    question: "Расскажи про mobx",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/TakH5i5VRGk?t=1130",
        title: "Публичное собеседование #3: TypeScri…",
        time: 1130,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5063,
    question: "Сравни mobx с другими  системами управления state",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/TakH5i5VRGk?t=1195",
        title: "Публичное собеседование #3: TypeScri…",
        time: 1195,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5064,
    question: "Где функции не могут быть чистыми",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/TakH5i5VRGk?t=1419",
        title: "Публичное собеседование #3: TypeScri…",
        time: 1419,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5065,
    question:
      "Какие используешь подходы для написания приложения которую проще  поддерживать, чем делать первоначальную разработку",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/H_ICtXCmGAY?t=66",
        title: "Публичное собеседование #9: JavaScri…",
        time: 66,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5066,
    question: "На что можно заменить интерфейсы в js",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/H_ICtXCmGAY?t=195",
        title: "Публичное собеседование #9: JavaScri…",
        time: 195,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5067,
    question: "Чем можно описывать контракты",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/H_ICtXCmGAY?t=201",
        title: "Публичное собеседование #9: JavaScri…",
        time: 201,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5068,
    question:
      "Какая машинерия нужна для слоеной архитектуры или domain-driver design,  и для чего",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/H_ICtXCmGAY?t=313",
        title: "Публичное собеседование #9: JavaScri…",
        time: 313,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5069,
    question:
      "Какие применял шаблоны проектирования (очередь сообщений,  ассинхронные пулы, enterprise bus, разделение сommand–query )",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/H_ICtXCmGAY?t=551",
        title: "Публичное собеседование #9: JavaScri…",
        time: 551,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5070,
    question:
      "Приведи пример архитектурных решений для проектов на node.Js какой был  опыт и какой результат",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/H_ICtXCmGAY?t=705",
        title: "Публичное собеседование #9: JavaScri…",
        time: 705,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5071,
    question:
      "Расскажи про высоконагруженние системы и системы реального времени",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/H_ICtXCmGAY?t=1101",
        title: "Публичное собеседование #9: JavaScri…",
        time: 1101,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5072,
    question:
      "В чем разница систем приближенных к реальному времени и системами  реального времени на производстве",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/H_ICtXCmGAY?t=1142",
        title: "Публичное собеседование #9: JavaScri…",
        time: 1142,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5073,
    question: "Какие проблемы с подключением языков встречал",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/H_ICtXCmGAY?t=1519",
        title: "Публичное собеседование #9: JavaScri…",
        time: 1519,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5074,
    question:
      "Какие есть доступы или подходы к базам данных из прикладного кода (active record)",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/H_ICtXCmGAY?t=1647",
        title: "Публичное собеседование #9: JavaScri…",
        time: 1647,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5075,
    question:
      "Расскажи недостатки с обзором и системами модульности которые используются в js,  node.Js",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/H_ICtXCmGAY?t=1896",
        title: "Публичное собеседование #9: JavaScri…",
        time: 1896,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5076,
    question: "В чем особенности command js",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/H_ICtXCmGAY?t=2025",
        title: "Публичное собеседование #9: JavaScri…",
        time: 2025,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5077,
    question:
      "Что есть из систем модульности помимо ecmascript-модулей и command js модулей",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/H_ICtXCmGAY?t=2240",
        title: "Публичное собеседование #9: JavaScri…",
        time: 2240,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5078,
    question: "Расскажи про механизмы в node js, domain и async hooks",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/H_ICtXCmGAY?t=2336",
        title: "Публичное собеседование #9: JavaScri…",
        time: 2336,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5079,
    question: "Расскажи про graceful shutdown и где применяется",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/H_ICtXCmGAY?t=2669",
        title: "Публичное собеседование #9: JavaScri…",
        time: 2669,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5080,
    question: "Какова была общая архитектура системы вашего проекта",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/8SNNm2kuNk8?t=501",
        title: "[180k] Первичное скайп-СОБЕСЕДОВАНИЕ…",
        time: 501,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5081,
    question: "Как был организован процесс вашего проекта",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/8SNNm2kuNk8?t=504",
        title: "[180k] Первичное скайп-СОБЕСЕДОВАНИЕ…",
        time: 504,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5082,
    question: "Расскажи что интересного разрабатывал",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/AbbX_AKHjSM?t=114",
        title: "Самое быстрое собеседование по Front…",
        time: 114,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5083,
    question: "Как работаешь с ассинхронным js",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/AbbX_AKHjSM?t=193",
        title: "Самое быстрое собеседование по Front…",
        time: 193,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5084,
    question: "С помощью чего собираешь приложения",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/AbbX_AKHjSM?t=256",
        title: "Самое быстрое собеседование по Front…",
        time: 256,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5085,
    question: "Как деплоишь приложения",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/AbbX_AKHjSM?t=283",
        title: "Самое быстрое собеседование по Front…",
        time: 283,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5086,
    question: "Как мониторишь ошибки js",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/AbbX_AKHjSM?t=428",
        title: "Самое быстрое собеседование по Front…",
        time: 428,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5087,
    question: "Максимально широко расскажи о http протоколе",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PCW2J63zlsk?t=1427",
        title: "Собеседование в Сбербанк ТОЛПОЙ! Fro…",
        time: 1427,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5088,
    question: "Какие методы общения имеются в протоколе http",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PCW2J63zlsk?t=1718",
        title: "Собеседование в Сбербанк ТОЛПОЙ! Fro…",
        time: 1718,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5089,
    question: "Что такое  crud",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PCW2J63zlsk?t=1740",
        title: "Собеседование в Сбербанк ТОЛПОЙ! Fro…",
        time: 1740,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5090,
    question: "Как реализовывается crud",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PCW2J63zlsk?t=1755",
        title: "Собеседование в Сбербанк ТОЛПОЙ! Fro…",
        time: 1755,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5091,
    question: "Какие бывают коды ответов с сервера",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PCW2J63zlsk?t=1812",
        title: "Собеседование в Сбербанк ТОЛПОЙ! Fro…",
        time: 1812,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5092,
    question: "В чем отличие кодов 400, 500",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/PCW2J63zlsk?t=1893",
        title: "Собеседование в Сбербанк ТОЛПОЙ! Fro…",
        time: 1893,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5093,
    question: "Что такое атрибут  doctype в html разметке",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/DjY76sVa7xY?t=393",
        title: "Камбоджи. Техническое собеседование …",
        time: 393,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5094,
    question:
      "В чем разница работы режимов( async , defer или type) тега script",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/DjY76sVa7xY?t=526",
        title: "Камбоджи. Техническое собеседование …",
        time: 526,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5095,
    question: "Для чего используется тег link",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/DjY76sVa7xY?t=618",
        title: "Камбоджи. Техническое собеседование …",
        time: 618,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5096,
    question: "Для чего необходим атрибут rel тега link",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/DjY76sVa7xY?t=642",
        title: "Камбоджи. Техническое собеседование …",
        time: 642,
      },
    ],
    rating: 3,
    image: null,
  },
  {
    id: 5097,
    question: "Что будет вызвав this стрелочной функцией",
    explanation: "",
    videos: [
      {
        url: "https://youtu.be/DjY76sVa7xY?t=791",
        title: "Камбоджи. Техническое собеседование …",
        time: 791,
      },
    ],
    rating: 3,
    image: null,
  },
];
export default questions;
